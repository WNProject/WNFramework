diff -rupN llvmclean/lib/ExecutionEngine/JIT/JITMemoryManager.cpp llvmandroid/lib/ExecutionEngine/JIT/JITMemoryManager.cpp
--- llvmclean/lib/ExecutionEngine/JIT/JITMemoryManager.cpp	2013-01-14 16:04:44.000000000 -0500
+++ llvmandroid/lib/ExecutionEngine/JIT/JITMemoryManager.cpp	2013-09-03 19:38:39.811170098 -0400
@@ -826,12 +826,14 @@ public:
     sys::DynamicLibrary::AddSymbol("stat", (void*)(intptr_t)stat);
     sys::DynamicLibrary::AddSymbol("fstat", (void*)(intptr_t)fstat);
     sys::DynamicLibrary::AddSymbol("lstat", (void*)(intptr_t)lstat);
+#ifndef __ANDROID__
     sys::DynamicLibrary::AddSymbol("stat64", (void*)(intptr_t)stat64);
     sys::DynamicLibrary::AddSymbol("\x1stat64", (void*)(intptr_t)stat64);
     sys::DynamicLibrary::AddSymbol("\x1open64", (void*)(intptr_t)open64);
     sys::DynamicLibrary::AddSymbol("\x1lseek64", (void*)(intptr_t)lseek64);
     sys::DynamicLibrary::AddSymbol("fstat64", (void*)(intptr_t)fstat64);
     sys::DynamicLibrary::AddSymbol("lstat64", (void*)(intptr_t)lstat64);
+#endif
     sys::DynamicLibrary::AddSymbol("atexit", (void*)(intptr_t)atexit);
     sys::DynamicLibrary::AddSymbol("mknod", (void*)(intptr_t)mknod);
   }
diff -rupN llvmclean/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp llvmandroid/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp
--- llvmclean/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp	2013-05-06 13:21:23.000000000 -0400
+++ llvmandroid/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp	2013-09-04 08:42:23.693445659 -0400
@@ -362,6 +362,9 @@ void RuntimeDyldELF::resolveARMRelocatio
                                           uint32_t Type,
                                           int32_t Addend) {
   // TODO: Add Thumb relocations.
+  uint32_t *Placeholder = reinterpret_cast<uint32_t*>(Section.ObjAddress +
+                                                      Offset);
+  
   uint32_t* TargetPtr = (uint32_t*)(Section.Address + Offset);
   uint32_t FinalAddress = ((Section.LoadAddress + Offset) & 0xFFFFFFFF);
   Value += Addend;
@@ -382,7 +385,7 @@ void RuntimeDyldELF::resolveARMRelocatio
   // implicit addend encoded in the target.
   case ELF::R_ARM_TARGET1 :
   case ELF::R_ARM_ABS32 :
-    *TargetPtr += Value;
+    *TargetPtr = *Placeholder + Value;
     break;
 
   // Write first 16 bit of 32 bit value to the mov instruction.
@@ -391,33 +394,42 @@ void RuntimeDyldELF::resolveARMRelocatio
     // We are not expecting any other addend in the relocation address.
     // Using 0x000F0FFF because MOVW has its 16 bit immediate split into 2
     // non-contiguous fields.
-    assert((*TargetPtr & 0x000F0FFF) == 0);
+    assert((*Placeholder & 0x000F0FFF) == 0);
     Value = Value & 0xFFFF;
-    *TargetPtr |= Value & 0xFFF;
+    *TargetPtr = *Placeholder | (Value & 0xFFF);
     *TargetPtr |= ((Value >> 12) & 0xF) << 16;
-    break;
+ break;
 
   // Write last 16 bit of 32 bit value to the mov instruction.
   // Last 4 bit should be shifted.
   case ELF::R_ARM_MOVT_ABS :
     // We are not expecting any other addend in the relocation address.
     // Use 0x000F0FFF for the same reason as R_ARM_MOVW_ABS_NC.
-    assert((*TargetPtr & 0x000F0FFF) == 0);
+    assert((*Placeholder & 0x000F0FFF) == 0);
     Value = (Value >> 16) & 0xFFFF;
-    *TargetPtr |= Value & 0xFFF;
+    *TargetPtr = *Placeholder | (Value & 0xFFF);
     *TargetPtr |= ((Value >> 12) & 0xF) << 16;
     break;
 
   // Write 24 bit relative value to the branch instruction.
   case ELF::R_ARM_PC24 :    // Fall through.
   case ELF::R_ARM_CALL :    // Fall through.
-  case ELF::R_ARM_JUMP24 :
-    int32_t RelValue = static_cast<int32_t>(Value - FinalAddress - 8);
-    RelValue = (RelValue & 0x03FFFFFC) >> 2;
-    *TargetPtr &= 0xFF000000;
-    *TargetPtr |= RelValue;
-    break;
-  }
+  case ELF::R_ARM_JUMP24 : {
+        int32_t RelValue = static_cast<int32_t>(Value - FinalAddress - 8);
+        RelValue = (RelValue & 0x03FFFFFC) >> 2;
+        assert((*TargetPtr & 0xFFFFFF) == 0xFFFFFE);
+        *TargetPtr &= 0xFF000000;
+        *TargetPtr |= RelValue;
+        break;
+    }
+    case ELF::R_ARM_PRIVATE_0:
+        // This relocation is reserved by the ARM ELF ABI for internal use. We
+        // appropriate it here to act as an R_ARM_ABS32 without any addend for use
+        // in the stubs created during JIT (which can't put an addend into the
+        // original object file).
+        *TargetPtr = Value;
+        break;
+    }
 }
 
 void RuntimeDyldELF::resolveMIPSRelocation(const SectionEntry &Section,
@@ -876,7 +888,7 @@ void RuntimeDyldELF::processRelocationRe
       uint8_t *StubTargetAddr = createStubFunction(Section.Address +
                                                    Section.StubOffset);
       RelocationEntry RE(SectionID, StubTargetAddr - Section.Address,
-                         ELF::R_ARM_ABS32, Value.Addend);
+                         ELF::R_ARM_PRIVATE_0, Value.Addend);
       if (Value.SymbolName)
         addRelocationForSymbol(RE, Value.SymbolName);
       else
diff -rupN llvmclean/lib/Support/Unix/Path.inc llvmandroid/lib/Support/Unix/Path.inc
--- llvmclean/lib/Support/Unix/Path.inc	2012-09-26 04:30:35.000000000 -0400
+++ llvmandroid/lib/Support/Unix/Path.inc	2013-09-03 19:33:58.835180123 -0400
@@ -67,7 +67,7 @@
 
 // Put in a hack for Cygwin which falsely reports that the mkdtemp function
 // is available when it is not.
-#ifdef __CYGWIN__
+#if defined (__CYGWIN__) | defined (__ANDROID__)
 # undef HAVE_MKDTEMP
 #endif

