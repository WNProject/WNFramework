/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.3-SNAPSHOT
 *
 *     -  From the grammar source file :
 * C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g
 *     -                            On : 2015-07-31 21:50:38
 *     -                 for the lexer : WNScriptASTLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy
 * lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include "WNScriptASTLexer.hpp"
/* ----------------------------------------- */

/** String literals used by WNScriptASTLexer that we must do things like
 * MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR_UCHAR lit_1[] = {0x21, 0x3D, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_2[] = {0x25, 0x3D, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_3[] = {0x26, 0x26, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_4[] = {0x2A, 0x3D, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_5[] = {0x2B, 0x3D, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_6[] = {0x2D, 0x3D, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_7[] = {0x2F, 0x3D, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_8[] = {0x3C, 0x3D, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_9[] = {0x3D, 0x3D, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_10[] = {0x3E, 0x3D, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_11[] = {0x7C, 0x7C, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_12[] = {0x2B, 0x2B, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_13[] = {0x2D, 0x2D, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_14[] = {
    0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_15[] = {0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x3C, 0x3D,
    0x3D, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_16[] = {
    0x77, 0x68, 0x69, 0x6C, 0x65, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_17[] = {0x64, 0x6F, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_18[] = {0x69, 0x66, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_19[] = {
    0x65, 0x6C, 0x73, 0x65, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_20[] = {
    0x66, 0x6F, 0x72, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_21[] = {
    0x73, 0x74, 0x72, 0x75, 0x63, 0x74, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_22[] = {
    0x63, 0x6C, 0x61, 0x73, 0x73, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_23[] = {
    0x76, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_24[] = {0x6F, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65,
    antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_25[] = {0x23, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x65,
    antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_26[] = {
    0x74, 0x72, 0x75, 0x65, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_27[] = {
    0x66, 0x61, 0x6C, 0x73, 0x65, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_28[] = {0x2F, 0x2F, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_29[] = {0x2F, 0x2A, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_30[] = {0x2A, 0x2F, antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR lit_31[] = {
    0x3C, 0x3D, 0x3D, antlr3::ANTLR_STRING_TERMINATOR};

/* =============================================================================
 */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */

WNScriptASTLexer::~WNScriptASTLexer() {}

void WNScriptASTLexer::reset() {
  this->get_rec()->reset();
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] =
    "C:"
    "\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecat"
    "edScripting\\lang\\WNScriptAST.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* WNScriptASTLexer::getGrammarFileName() {
  return fileName;
}

/** \brief Create a new lexer called WNScriptASTLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pWNScriptASTLexer initialized for the lex start
 *     - Fail NULL
 */
WNScriptASTLexer::WNScriptASTLexer(StreamType* instream)
  : WNScriptASTLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, NULL) {
  // See if we can create a new lexer with the standard constructor
  //
  this->init(instream);
}

/** \brief Create a new lexer called WNScriptASTLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pWNScriptASTLexer initialized for the lex start
 *     - Fail NULL
 */
WNScriptASTLexer::WNScriptASTLexer(
    StreamType* instream, RecognizerSharedStateType* state)
  : WNScriptASTLexerImplTraits::BaseLexerType(
        ANTLR_SIZE_HINT, instream, state) {
  this->init(instream);
}

void WNScriptASTLexer::init(StreamType* instream) {
  /* -------------------------------------------------------------------
   * Memory for basic structure is allocated, now to fill in
   * in base ANTLR3 structures. We initialize the function pointers
   * for the standard ANTLR3 lexer function set, but upon return
   * from here, the programmer may set the pointers to provide custom
   * implementations of each function.
   *
   * We don't use the macros defined in WNScriptASTLexer.h here so you can get a
   * sense
   * of what goes where.
   */
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    191:1: FLOAT : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' (
 * '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT );
 */
static const ANTLR_INT32 dfa11_eot[5] = {-1, -1, -1, -1, -1};
static const ANTLR_INT32 dfa11_eof[5] = {-1, -1, -1, -1, -1};
static const ANTLR_INT32 dfa11_min[5] = {46, 46, -1, -1, -1};
static const ANTLR_INT32 dfa11_max[5] = {57, 101, -1, -1, -1};
static const ANTLR_INT32 dfa11_accept[5] = {-1, -1, 2, 1, 3};
static const ANTLR_INT32 dfa11_special[5] = {-1, -1, -1, -1, -1};

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa11_T_empty = NULL;

static const ANTLR_INT32 dfa11_T0[] = {3, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, 4};
static const ANTLR_INT32 dfa11_T1[] = {2, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32* const dfa11_transitions[] = {
    dfa11_T1, dfa11_T0, NULL, NULL, NULL};

/* Declare tracking structure for Cyclic DFA 11
 */
class WNScriptASTLexerCyclicDFA11
    : public CyclicDFA<WNScriptASTLexerImplTraits, WNScriptASTLexer>,
      public WNScriptASTLexerTokens {
public:
  typedef CyclicDFA<WNScriptASTLexerImplTraits, WNScriptASTLexer> BaseType;
  typedef BaseType::ContextType CtxType;

private:
public:
  WNScriptASTLexerCyclicDFA11(ANTLR_INT32 decisionNumber,
      const ANTLR_UCHAR* description, const ANTLR_INT32* const eot,
      const ANTLR_INT32* const eof, const ANTLR_INT32* const min,
      const ANTLR_INT32* const max, const ANTLR_INT32* const accept,
      const ANTLR_INT32* const special,
      const ANTLR_INT32* const* const transition)
    : BaseType(decisionNumber, description, eot, eof, min, max, accept, special,
          transition) {}
};

static WNScriptASTLexerCyclicDFA11  cdfa11(
	    11,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"191:1: FLOAT : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT );",
	    dfa11_eot,	    /* EOT table			    */
	    dfa11_eof,	    /* EOF table			    */
	    dfa11_min,	    /* Minimum tokens for each state    */
	    dfa11_max,	    /* Maximum tokens for each state    */
	    dfa11_accept,	/* Accept table			    */
	    dfa11_special,	/* Special transition states	    */
	    dfa11_transitions	/* Table of transition tables	    */

	);

/* End of Cyclic DFA 11
 * ---------------------
 */ /** Static dfa state tables for Cyclic dfa:
                      *    1:1: Tokens : ( T__43 | T__44 | T__45 | T__46 | T__47
                      * | T__48 | T__49 | T__50 | T__51 | T__52 | T__53 | T__54
                      * | T__55 | T__56 | T__57 | T__58 | T__59 | T__60 | T__61
                      * | T__62 | T__63 | LSQBRACKET | RSQBRACKET | LBRACKET |
                      * RBRACKET | LBRACE | RBRACE | COMMA | DOUBINC | DOUBDEC |
                      * RETURN | RETURN_OWN | SEMICOLON | COLON | WHILE | DO |
                      * IF | ELSE | FOR | STRUCT | CLASS | VIRTUAL | OVERRIDE |
                      * INCLUDE | BOOL | ID | TYPE | INT | FLOAT | COMMENT | WS
                      * | STRING | CHAR | NULLTOK | CHOWN );
                      */
static const ANTLR_INT32 dfa22_eot[123] = {-1, -1, 43, -1, 45, 48, 51, 52, 56,
    58, 60, 62, -1, -1, -1, -1, -1, -1, -1, -1, -1, 35, -1, -1, 35, 35, 35, 35,
    35, 35, 35, 35, 35, -1, 35, -1, -1, 75, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 77, -1, -1, -1, -1, -1, 35, 35, 80,
    81, 35, 35, 35, 35, 35, 35, 35, 35, -1, -1, -1, 35, 35, -1, -1, 35, 93, 35,
    35, 35, 35, 35, 35, 35, 35, 102, -1, 35, 35, 35, 35, 35, 108, 35, 110, -1,
    108, 35, 112, 35, 35, -1, 116, -1, 117, -1, 35, 35, -1, -1, -1, 120, 35, -1,
    122, -1};
static const ANTLR_INT32 dfa22_eof[123] = {-1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
static const ANTLR_INT32 dfa22_min[123] = {9, -1, 61, -1, 61, 43, 45, 48, 42,
    61, 61, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, 101, -1, -1, 104, 111, 102,
    108, 97, 116, 108, 105, 118, -1, 114, -1, -1, 46, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, -1, -1,
    116, 105, 48, 48, 115, 114, 108, 114, 97, 114, 101, 117, -1, -1, -1, 117,
    108, -1, -1, 101, 48, 115, 117, 115, 116, 114, 101, 114, 101, 48, -1, 101,
    99, 115, 117, 114, 48, 110, 48, -1, 48, 116, 48, 97, 105, -1, 48, -1, 48,
    -1, 108, 100, -1, -1, -1, 48, 101, -1, 48, -1};
static const ANTLR_INT32 dfa22_max[123] = {126, -1, 61, -1, 61, 61, 61, 57, 61,
    61, 61, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, 101, -1, -1, 104, 111, 102,
    108, 111, 116, 108, 105, 118, -1, 114, -1, -1, 101, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, -1, -1,
    116, 105, 122, 122, 115, 114, 108, 114, 97, 114, 101, 117, -1, -1, -1, 117,
    108, -1, -1, 101, 122, 115, 117, 115, 116, 114, 101, 114, 101, 122, -1, 101,
    99, 115, 117, 114, 122, 110, 122, -1, 122, 116, 122, 97, 105, -1, 122, -1,
    122, -1, 108, 100, -1, -1, -1, 122, 101, -1, 122, -1};
static const ANTLR_INT32 dfa22_accept[123] = {-1, 1, -1, 4, -1, -1, -1, -1, -1,
    -1, -1, -1, 20, 21, 22, 23, 24, 25, 26, 27, 28, -1, 33, 34, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, 44, -1, 46, 47, -1, 51, 52, 53, 54, 3, 2, 6, 5, 8, 29,
    7, 10, 30, 9, 11, 49, 13, 50, 12, -1, 14, 17, 16, 19, 18, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, 48, 55, 15, -1, -1, 36, 37, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, 39, -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, -1,
    -1, -1, -1, 45, -1, 35, -1, 41, -1, -1, 32, 31, 40, -1, -1, 42, -1, 43};
static const ANTLR_INT32 dfa22_special[123] = {-1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1};

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa22_T_empty = NULL;

static const ANTLR_INT32 dfa22_T0[] = {35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
    -1, -1, -1, -1, -1, -1, -1, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, -1, -1, -1, -1, 35,
    -1, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
    35, 35, 35, 35, 35, 35, 35, 35};
static const ANTLR_INT32 dfa22_T1[] = {74};
static const ANTLR_INT32 dfa22_T2[] = {89};
static const ANTLR_INT32 dfa22_T3[] = {99};
static const ANTLR_INT32 dfa22_T4[] = {84};
static const ANTLR_INT32 dfa22_T5[] = {94};
static const ANTLR_INT32 dfa22_T6[] = {103};
static const ANTLR_INT32 dfa22_T7[] = {57};
static const ANTLR_INT32 dfa22_T8[] = {53, 53, 53, 53, 53, 53, 53, 53, 53, 53};
static const ANTLR_INT32 dfa22_T9[] = {59};
static const ANTLR_INT32 dfa22_T10[] = {42};
static const ANTLR_INT32 dfa22_T11[] = {
    69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 68};
static const ANTLR_INT32 dfa22_T12[] = {61};
static const ANTLR_INT32 dfa22_T13[] = {76};
static const ANTLR_INT32 dfa22_T14[] = {44};
static const ANTLR_INT32 dfa22_T15[] = {55, -1, -1, -1, -1, 55, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, 54};
static const ANTLR_INT32 dfa22_T16[] = {
    47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 46};
static const ANTLR_INT32 dfa22_T17[] = {38, 38, -1, -1, 38, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 38, 1, 39, 33, -1, 2, 3,
    40, 16, 17, 4, 5, 20, 6, 7, 8, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 23,
    22, 9, 10, 11, 12, -1, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 14, -1, 15, -1, 35, -1,
    35, 35, 30, 25, 27, 28, 35, 35, 26, 35, 35, 35, 35, 35, 32, 35, 35, 21, 29,
    34, 35, 31, 24, 35, 35, 35, 18, 13, 19, 41};
static const ANTLR_INT32 dfa22_T18[] = {63};
static const ANTLR_INT32 dfa22_T19[] = {78};
static const ANTLR_INT32 dfa22_T20[] = {90};
static const ANTLR_INT32 dfa22_T21[] = {100};
static const ANTLR_INT32 dfa22_T22[] = {109};
static const ANTLR_INT32 dfa22_T23[] = {
    50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49};
static const ANTLR_INT32 dfa22_T24[] = {64};
static const ANTLR_INT32 dfa22_T25[] = {79};
static const ANTLR_INT32 dfa22_T26[] = {91};
static const ANTLR_INT32 dfa22_T27[] = {101};
static const ANTLR_INT32 dfa22_T28[] = {65};
static const ANTLR_INT32 dfa22_T29[] = {66};
static const ANTLR_INT32 dfa22_T30[] = {67};
static const ANTLR_INT32 dfa22_T31[] = {82};
static const ANTLR_INT32 dfa22_T32[] = {92};
static const ANTLR_INT32 dfa22_T33[] = {35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
    -1, -1, 115, -1, -1, -1, -1, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
    35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, -1, -1, -1, -1, 35,
    -1, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
    35, 35, 35, 35, 35, 35, 35, 35};
static const ANTLR_INT32 dfa22_T34[] = {83};
static const ANTLR_INT32 dfa22_T35[] = {70};
static const ANTLR_INT32 dfa22_T36[] = {85};
static const ANTLR_INT32 dfa22_T37[] = {95};
static const ANTLR_INT32 dfa22_T38[] = {104};
static const ANTLR_INT32 dfa22_T39[] = {111};
static const ANTLR_INT32 dfa22_T40[] = {71};
static const ANTLR_INT32 dfa22_T41[] = {86};
static const ANTLR_INT32 dfa22_T42[] = {96};
static const ANTLR_INT32 dfa22_T43[] = {105};
static const ANTLR_INT32 dfa22_T44[] = {72};
static const ANTLR_INT32 dfa22_T45[] = {87};
static const ANTLR_INT32 dfa22_T46[] = {97};
static const ANTLR_INT32 dfa22_T47[] = {106};
static const ANTLR_INT32 dfa22_T48[] = {113};
static const ANTLR_INT32 dfa22_T49[] = {118};
static const ANTLR_INT32 dfa22_T50[] = {73};
static const ANTLR_INT32 dfa22_T51[] = {88};
static const ANTLR_INT32 dfa22_T52[] = {98};
static const ANTLR_INT32 dfa22_T53[] = {107};
static const ANTLR_INT32 dfa22_T54[] = {114};
static const ANTLR_INT32 dfa22_T55[] = {119};
static const ANTLR_INT32 dfa22_T56[] = {121};
static const ANTLR_INT32 dfa22_T57[] = {53, -1, 37, 37, 37, 37, 37, 37, 37, 37,
    37, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, 53};

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32* const dfa22_transitions[] = {dfa22_T17, NULL,
    dfa22_T10, NULL, dfa22_T14, dfa22_T16, dfa22_T23, dfa22_T8, dfa22_T15,
    dfa22_T7, dfa22_T9, dfa22_T12, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, dfa22_T18, NULL, NULL, dfa22_T24, dfa22_T28, dfa22_T29,
    dfa22_T30, dfa22_T11, dfa22_T35, dfa22_T40, dfa22_T44, dfa22_T50, NULL,
    dfa22_T1, NULL, NULL, dfa22_T57, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    dfa22_T13, NULL, NULL, NULL, NULL, NULL, dfa22_T19, dfa22_T25, dfa22_T0,
    dfa22_T0, dfa22_T31, dfa22_T34, dfa22_T4, dfa22_T36, dfa22_T41, dfa22_T45,
    dfa22_T51, dfa22_T2, NULL, NULL, NULL, dfa22_T20, dfa22_T26, NULL, NULL,
    dfa22_T32, dfa22_T0, dfa22_T5, dfa22_T37, dfa22_T42, dfa22_T46, dfa22_T52,
    dfa22_T3, dfa22_T21, dfa22_T27, dfa22_T0, NULL, dfa22_T6, dfa22_T38,
    dfa22_T43, dfa22_T47, dfa22_T53, dfa22_T0, dfa22_T22, dfa22_T0, NULL,
    dfa22_T0, dfa22_T39, dfa22_T0, dfa22_T48, dfa22_T54, NULL, dfa22_T33, NULL,
    dfa22_T0, NULL, dfa22_T49, dfa22_T55, NULL, NULL, NULL, dfa22_T0, dfa22_T56,
    NULL, dfa22_T0, NULL};

/* Declare tracking structure for Cyclic DFA 22
 */
class WNScriptASTLexerCyclicDFA22
    : public CyclicDFA<WNScriptASTLexerImplTraits, WNScriptASTLexer>,
      public WNScriptASTLexerTokens {
public:
  typedef CyclicDFA<WNScriptASTLexerImplTraits, WNScriptASTLexer> BaseType;
  typedef BaseType::ContextType CtxType;

private:
public:
  WNScriptASTLexerCyclicDFA22(ANTLR_INT32 decisionNumber,
      const ANTLR_UCHAR* description, const ANTLR_INT32* const eot,
      const ANTLR_INT32* const eof, const ANTLR_INT32* const min,
      const ANTLR_INT32* const max, const ANTLR_INT32* const accept,
      const ANTLR_INT32* const special,
      const ANTLR_INT32* const* const transition)
    : BaseType(decisionNumber, description, eot, eof, min, max, accept, special,
          transition) {}
};

static WNScriptASTLexerCyclicDFA22  cdfa22(
	    22,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"1:1: Tokens : ( T__43 | T__44 | T__45 | T__46 | T__47 | T__48 | T__49 | T__50 | T__51 | T__52 | T__53 | T__54 | T__55 | T__56 | T__57 | T__58 | T__59 | T__60 | T__61 | T__62 | T__63 | LSQBRACKET | RSQBRACKET | LBRACKET | RBRACKET | LBRACE | RBRACE | COMMA | DOUBINC | DOUBDEC | RETURN | RETURN_OWN | SEMICOLON | COLON | WHILE | DO | IF | ELSE | FOR | STRUCT | CLASS | VIRTUAL | OVERRIDE | INCLUDE | BOOL | ID | TYPE | INT | FLOAT | COMMENT | WS | STRING | CHAR | NULLTOK | CHOWN );",
	    dfa22_eot,	    /* EOT table			    */
	    dfa22_eof,	    /* EOF table			    */
	    dfa22_min,	    /* Minimum tokens for each state    */
	    dfa22_max,	    /* Maximum tokens for each state    */
	    dfa22_accept,	/* Accept table			    */
	    dfa22_special,	/* Special transition states	    */
	    dfa22_transitions	/* Table of transition tables	    */

	);

/* End of Cyclic DFA 22
 * ---------------------
 */
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 39:7: ( '!=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__43
 *
 * Looks to match the characters the constitute the token T__43
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__43() {
  ANTLR_UINT32 _type;

  _type = T__43;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:39:7:
  // ( '!=' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:39:9:
  // '!='
  {
    this->matchs(lit_1);
    if (this->hasException()) {
      goto ruleT__43Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__43Ex; /* Prevent compiler warnings */
ruleT__43Ex:;
}
// $ANTLR end T__43

//   Comes from: 40:7: ( '%' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__44
 *
 * Looks to match the characters the constitute the token T__44
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__44() {
  ANTLR_UINT32 _type;

  _type = T__44;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:40:7:
  // ( '%' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:40:9:
  // '%'
  {
    this->matchc('%');
    if (this->hasException()) {
      goto ruleT__44Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__44Ex; /* Prevent compiler warnings */
ruleT__44Ex:;
}
// $ANTLR end T__44

//   Comes from: 41:7: ( '%=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__45
 *
 * Looks to match the characters the constitute the token T__45
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__45() {
  ANTLR_UINT32 _type;

  _type = T__45;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:41:7:
  // ( '%=' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:41:9:
  // '%='
  {
    this->matchs(lit_2);
    if (this->hasException()) {
      goto ruleT__45Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__45Ex; /* Prevent compiler warnings */
ruleT__45Ex:;
}
// $ANTLR end T__45

//   Comes from: 42:7: ( '&&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__46
 *
 * Looks to match the characters the constitute the token T__46
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__46() {
  ANTLR_UINT32 _type;

  _type = T__46;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:42:7:
  // ( '&&' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:42:9:
  // '&&'
  {
    this->matchs(lit_3);
    if (this->hasException()) {
      goto ruleT__46Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__46Ex; /* Prevent compiler warnings */
ruleT__46Ex:;
}
// $ANTLR end T__46

//   Comes from: 43:7: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__47
 *
 * Looks to match the characters the constitute the token T__47
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__47() {
  ANTLR_UINT32 _type;

  _type = T__47;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:43:7:
  // ( '*' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:43:9:
  // '*'
  {
    this->matchc('*');
    if (this->hasException()) {
      goto ruleT__47Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__47Ex; /* Prevent compiler warnings */
ruleT__47Ex:;
}
// $ANTLR end T__47

//   Comes from: 44:7: ( '*=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__48
 *
 * Looks to match the characters the constitute the token T__48
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__48() {
  ANTLR_UINT32 _type;

  _type = T__48;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:44:7:
  // ( '*=' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:44:9:
  // '*='
  {
    this->matchs(lit_4);
    if (this->hasException()) {
      goto ruleT__48Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__48Ex; /* Prevent compiler warnings */
ruleT__48Ex:;
}
// $ANTLR end T__48

//   Comes from: 45:7: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__49
 *
 * Looks to match the characters the constitute the token T__49
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__49() {
  ANTLR_UINT32 _type;

  _type = T__49;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:45:7:
  // ( '+' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:45:9:
  // '+'
  {
    this->matchc('+');
    if (this->hasException()) {
      goto ruleT__49Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__49Ex; /* Prevent compiler warnings */
ruleT__49Ex:;
}
// $ANTLR end T__49

//   Comes from: 46:7: ( '+=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__50
 *
 * Looks to match the characters the constitute the token T__50
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__50() {
  ANTLR_UINT32 _type;

  _type = T__50;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:46:7:
  // ( '+=' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:46:9:
  // '+='
  {
    this->matchs(lit_5);
    if (this->hasException()) {
      goto ruleT__50Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__50Ex; /* Prevent compiler warnings */
ruleT__50Ex:;
}
// $ANTLR end T__50

//   Comes from: 47:7: ( '-' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__51
 *
 * Looks to match the characters the constitute the token T__51
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__51() {
  ANTLR_UINT32 _type;

  _type = T__51;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:47:7:
  // ( '-' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:47:9:
  // '-'
  {
    this->matchc('-');
    if (this->hasException()) {
      goto ruleT__51Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__51Ex; /* Prevent compiler warnings */
ruleT__51Ex:;
}
// $ANTLR end T__51

//   Comes from: 48:7: ( '-=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__52
 *
 * Looks to match the characters the constitute the token T__52
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__52() {
  ANTLR_UINT32 _type;

  _type = T__52;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:48:7:
  // ( '-=' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:48:9:
  // '-='
  {
    this->matchs(lit_6);
    if (this->hasException()) {
      goto ruleT__52Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__52Ex; /* Prevent compiler warnings */
ruleT__52Ex:;
}
// $ANTLR end T__52

//   Comes from: 49:7: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__53
 *
 * Looks to match the characters the constitute the token T__53
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__53() {
  ANTLR_UINT32 _type;

  _type = T__53;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:49:7:
  // ( '.' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:49:9:
  // '.'
  {
    this->matchc('.');
    if (this->hasException()) {
      goto ruleT__53Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__53Ex; /* Prevent compiler warnings */
ruleT__53Ex:;
}
// $ANTLR end T__53

//   Comes from: 50:7: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__54
 *
 * Looks to match the characters the constitute the token T__54
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__54() {
  ANTLR_UINT32 _type;

  _type = T__54;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:50:7:
  // ( '/' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:50:9:
  // '/'
  {
    this->matchc('/');
    if (this->hasException()) {
      goto ruleT__54Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__54Ex; /* Prevent compiler warnings */
ruleT__54Ex:;
}
// $ANTLR end T__54

//   Comes from: 51:7: ( '/=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__55
 *
 * Looks to match the characters the constitute the token T__55
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__55() {
  ANTLR_UINT32 _type;

  _type = T__55;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:51:7:
  // ( '/=' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:51:9:
  // '/='
  {
    this->matchs(lit_7);
    if (this->hasException()) {
      goto ruleT__55Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__55Ex; /* Prevent compiler warnings */
ruleT__55Ex:;
}
// $ANTLR end T__55

//   Comes from: 52:7: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__56
 *
 * Looks to match the characters the constitute the token T__56
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__56() {
  ANTLR_UINT32 _type;

  _type = T__56;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:52:7:
  // ( '<' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:52:9:
  // '<'
  {
    this->matchc('<');
    if (this->hasException()) {
      goto ruleT__56Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__56Ex; /* Prevent compiler warnings */
ruleT__56Ex:;
}
// $ANTLR end T__56

//   Comes from: 53:7: ( '<=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__57
 *
 * Looks to match the characters the constitute the token T__57
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__57() {
  ANTLR_UINT32 _type;

  _type = T__57;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:53:7:
  // ( '<=' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:53:9:
  // '<='
  {
    this->matchs(lit_8);
    if (this->hasException()) {
      goto ruleT__57Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__57Ex; /* Prevent compiler warnings */
ruleT__57Ex:;
}
// $ANTLR end T__57

//   Comes from: 54:7: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__58
 *
 * Looks to match the characters the constitute the token T__58
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__58() {
  ANTLR_UINT32 _type;

  _type = T__58;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:54:7:
  // ( '=' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:54:9:
  // '='
  {
    this->matchc('=');
    if (this->hasException()) {
      goto ruleT__58Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__58Ex; /* Prevent compiler warnings */
ruleT__58Ex:;
}
// $ANTLR end T__58

//   Comes from: 55:7: ( '==' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__59
 *
 * Looks to match the characters the constitute the token T__59
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__59() {
  ANTLR_UINT32 _type;

  _type = T__59;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:55:7:
  // ( '==' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:55:9:
  // '=='
  {
    this->matchs(lit_9);
    if (this->hasException()) {
      goto ruleT__59Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__59Ex; /* Prevent compiler warnings */
ruleT__59Ex:;
}
// $ANTLR end T__59

//   Comes from: 56:7: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__60
 *
 * Looks to match the characters the constitute the token T__60
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__60() {
  ANTLR_UINT32 _type;

  _type = T__60;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:56:7:
  // ( '>' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:56:9:
  // '>'
  {
    this->matchc('>');
    if (this->hasException()) {
      goto ruleT__60Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__60Ex; /* Prevent compiler warnings */
ruleT__60Ex:;
}
// $ANTLR end T__60

//   Comes from: 57:7: ( '>=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__61
 *
 * Looks to match the characters the constitute the token T__61
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__61() {
  ANTLR_UINT32 _type;

  _type = T__61;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:57:7:
  // ( '>=' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:57:9:
  // '>='
  {
    this->matchs(lit_10);
    if (this->hasException()) {
      goto ruleT__61Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__61Ex; /* Prevent compiler warnings */
ruleT__61Ex:;
}
// $ANTLR end T__61

//   Comes from: 58:7: ( '?' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__62
 *
 * Looks to match the characters the constitute the token T__62
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__62() {
  ANTLR_UINT32 _type;

  _type = T__62;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:58:7:
  // ( '?' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:58:9:
  // '?'
  {
    this->matchc('?');
    if (this->hasException()) {
      goto ruleT__62Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__62Ex; /* Prevent compiler warnings */
ruleT__62Ex:;
}
// $ANTLR end T__62

//   Comes from: 59:7: ( '||' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__63
 *
 * Looks to match the characters the constitute the token T__63
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mT__63() {
  ANTLR_UINT32 _type;

  _type = T__63;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:59:7:
  // ( '||' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:59:9:
  // '||'
  {
    this->matchs(lit_11);
    if (this->hasException()) {
      goto ruleT__63Ex;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleT__63Ex; /* Prevent compiler warnings */
ruleT__63Ex:;
}
// $ANTLR end T__63

//   Comes from: 156:11: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LSQBRACKET
 *
 * Looks to match the characters the constitute the token LSQBRACKET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mLSQBRACKET() {
  ANTLR_UINT32 _type;

  _type = LSQBRACKET;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:156:11:
  // ( '[' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:156:13:
  // '['
  {
    this->matchc('[');
    if (this->hasException()) {
      goto ruleLSQBRACKETEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleLSQBRACKETEx; /* Prevent compiler warnings */
ruleLSQBRACKETEx:;
}
// $ANTLR end LSQBRACKET

//   Comes from: 157:11: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RSQBRACKET
 *
 * Looks to match the characters the constitute the token RSQBRACKET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mRSQBRACKET() {
  ANTLR_UINT32 _type;

  _type = RSQBRACKET;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:157:11:
  // ( ']' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:157:13:
  // ']'
  {
    this->matchc(']');
    if (this->hasException()) {
      goto ruleRSQBRACKETEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleRSQBRACKETEx; /* Prevent compiler warnings */
ruleRSQBRACKETEx:;
}
// $ANTLR end RSQBRACKET

//   Comes from: 158:9: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LBRACKET
 *
 * Looks to match the characters the constitute the token LBRACKET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mLBRACKET() {
  ANTLR_UINT32 _type;

  _type = LBRACKET;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:158:9:
  // ( '(' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:158:11:
  // '('
  {
    this->matchc('(');
    if (this->hasException()) {
      goto ruleLBRACKETEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleLBRACKETEx; /* Prevent compiler warnings */
ruleLBRACKETEx:;
}
// $ANTLR end LBRACKET

//   Comes from: 159:9: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RBRACKET
 *
 * Looks to match the characters the constitute the token RBRACKET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mRBRACKET() {
  ANTLR_UINT32 _type;

  _type = RBRACKET;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:159:9:
  // ( ')' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:159:11:
  // ')'
  {
    this->matchc(')');
    if (this->hasException()) {
      goto ruleRBRACKETEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleRBRACKETEx; /* Prevent compiler warnings */
ruleRBRACKETEx:;
}
// $ANTLR end RBRACKET

//   Comes from: 160:7: ( '{' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LBRACE
 *
 * Looks to match the characters the constitute the token LBRACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mLBRACE() {
  ANTLR_UINT32 _type;

  _type = LBRACE;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:160:7:
  // ( '{' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:160:11:
  // '{'
  {
    this->matchc('{');
    if (this->hasException()) {
      goto ruleLBRACEEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleLBRACEEx; /* Prevent compiler warnings */
ruleLBRACEEx:;
}
// $ANTLR end LBRACE

//   Comes from: 161:7: ( '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RBRACE
 *
 * Looks to match the characters the constitute the token RBRACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mRBRACE() {
  ANTLR_UINT32 _type;

  _type = RBRACE;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:161:7:
  // ( '}' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:161:11:
  // '}'
  {
    this->matchc('}');
    if (this->hasException()) {
      goto ruleRBRACEEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleRBRACEEx; /* Prevent compiler warnings */
ruleRBRACEEx:;
}
// $ANTLR end RBRACE

//   Comes from: 162:6: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMA
 *
 * Looks to match the characters the constitute the token COMMA
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mCOMMA() {
  ANTLR_UINT32 _type;

  _type = COMMA;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:162:6:
  // ( ',' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:162:11:
  // ','
  {
    this->matchc(',');
    if (this->hasException()) {
      goto ruleCOMMAEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleCOMMAEx; /* Prevent compiler warnings */
ruleCOMMAEx:;
}
// $ANTLR end COMMA

//   Comes from: 163:8: ( '++' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBINC
 *
 * Looks to match the characters the constitute the token DOUBINC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mDOUBINC() {
  ANTLR_UINT32 _type;

  _type = DOUBINC;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:163:8:
  // ( '++' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:163:12:
  // '++'
  {
    this->matchs(lit_12);
    if (this->hasException()) {
      goto ruleDOUBINCEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleDOUBINCEx; /* Prevent compiler warnings */
ruleDOUBINCEx:;
}
// $ANTLR end DOUBINC

//   Comes from: 164:8: ( '--' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBDEC
 *
 * Looks to match the characters the constitute the token DOUBDEC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mDOUBDEC() {
  ANTLR_UINT32 _type;

  _type = DOUBDEC;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:164:8:
  // ( '--' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:164:12:
  // '--'
  {
    this->matchs(lit_13);
    if (this->hasException()) {
      goto ruleDOUBDECEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleDOUBDECEx; /* Prevent compiler warnings */
ruleDOUBDECEx:;
}
// $ANTLR end DOUBDEC

//   Comes from: 165:7: ( 'return' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RETURN
 *
 * Looks to match the characters the constitute the token RETURN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mRETURN() {
  ANTLR_UINT32 _type;

  _type = RETURN;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:165:7:
  // ( 'return' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:165:12:
  // 'return'
  {
    this->matchs(lit_14);
    if (this->hasException()) {
      goto ruleRETURNEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleRETURNEx; /* Prevent compiler warnings */
ruleRETURNEx:;
}
// $ANTLR end RETURN

//   Comes from: 166:11: ( 'return<==' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RETURN_OWN
 *
 * Looks to match the characters the constitute the token RETURN_OWN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mRETURN_OWN() {
  ANTLR_UINT32 _type;

  _type = RETURN_OWN;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:166:11:
  // ( 'return<==' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:166:13:
  // 'return<=='
  {
    this->matchs(lit_15);
    if (this->hasException()) {
      goto ruleRETURN_OWNEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleRETURN_OWNEx; /* Prevent compiler warnings */
ruleRETURN_OWNEx:;
}
// $ANTLR end RETURN_OWN

//   Comes from: 167:10: ( ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEMICOLON
 *
 * Looks to match the characters the constitute the token SEMICOLON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mSEMICOLON() {
  ANTLR_UINT32 _type;

  _type = SEMICOLON;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:167:10:
  // ( ';' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:167:12:
  // ';'
  {
    this->matchc(';');
    if (this->hasException()) {
      goto ruleSEMICOLONEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleSEMICOLONEx; /* Prevent compiler warnings */
ruleSEMICOLONEx:;
}
// $ANTLR end SEMICOLON

//   Comes from: 168:6: ( ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COLON
 *
 * Looks to match the characters the constitute the token COLON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mCOLON() {
  ANTLR_UINT32 _type;

  _type = COLON;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:168:6:
  // ( ':' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:168:12:
  // ':'
  {
    this->matchc(':');
    if (this->hasException()) {
      goto ruleCOLONEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleCOLONEx; /* Prevent compiler warnings */
ruleCOLONEx:;
}
// $ANTLR end COLON

//   Comes from: 169:6: ( 'while' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHILE
 *
 * Looks to match the characters the constitute the token WHILE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mWHILE() {
  ANTLR_UINT32 _type;

  _type = WHILE;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:169:6:
  // ( 'while' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:169:12:
  // 'while'
  {
    this->matchs(lit_16);
    if (this->hasException()) {
      goto ruleWHILEEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleWHILEEx; /* Prevent compiler warnings */
ruleWHILEEx:;
}
// $ANTLR end WHILE

//   Comes from: 170:3: ( 'do' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DO
 *
 * Looks to match the characters the constitute the token DO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mDO() {
  ANTLR_UINT32 _type;

  _type = DO;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:170:3:
  // ( 'do' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:170:12:
  // 'do'
  {
    this->matchs(lit_17);
    if (this->hasException()) {
      goto ruleDOEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleDOEx; /* Prevent compiler warnings */
ruleDOEx:;
}
// $ANTLR end DO

//   Comes from: 171:3: ( 'if' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IF
 *
 * Looks to match the characters the constitute the token IF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mIF() {
  ANTLR_UINT32 _type;

  _type = IF;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:171:3:
  // ( 'if' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:171:12:
  // 'if'
  {
    this->matchs(lit_18);
    if (this->hasException()) {
      goto ruleIFEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleIFEx; /* Prevent compiler warnings */
ruleIFEx:;
}
// $ANTLR end IF

//   Comes from: 172:5: ( 'else' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ELSE
 *
 * Looks to match the characters the constitute the token ELSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mELSE() {
  ANTLR_UINT32 _type;

  _type = ELSE;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:172:5:
  // ( 'else' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:172:12:
  // 'else'
  {
    this->matchs(lit_19);
    if (this->hasException()) {
      goto ruleELSEEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleELSEEx; /* Prevent compiler warnings */
ruleELSEEx:;
}
// $ANTLR end ELSE

//   Comes from: 173:4: ( 'for' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FOR
 *
 * Looks to match the characters the constitute the token FOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mFOR() {
  ANTLR_UINT32 _type;

  _type = FOR;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:173:4:
  // ( 'for' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:173:12:
  // 'for'
  {
    this->matchs(lit_20);
    if (this->hasException()) {
      goto ruleFOREx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleFOREx; /* Prevent compiler warnings */
ruleFOREx:;
}
// $ANTLR end FOR

//   Comes from: 174:7: ( 'struct' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRUCT
 *
 * Looks to match the characters the constitute the token STRUCT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mSTRUCT() {
  ANTLR_UINT32 _type;

  _type = STRUCT;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:174:7:
  // ( 'struct' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:174:12:
  // 'struct'
  {
    this->matchs(lit_21);
    if (this->hasException()) {
      goto ruleSTRUCTEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleSTRUCTEx; /* Prevent compiler warnings */
ruleSTRUCTEx:;
}
// $ANTLR end STRUCT

//   Comes from: 175:6: ( 'class' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CLASS
 *
 * Looks to match the characters the constitute the token CLASS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mCLASS() {
  ANTLR_UINT32 _type;

  _type = CLASS;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:175:6:
  // ( 'class' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:175:12:
  // 'class'
  {
    this->matchs(lit_22);
    if (this->hasException()) {
      goto ruleCLASSEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleCLASSEx; /* Prevent compiler warnings */
ruleCLASSEx:;
}
// $ANTLR end CLASS

//   Comes from: 176:8: ( 'virtual' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VIRTUAL
 *
 * Looks to match the characters the constitute the token VIRTUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mVIRTUAL() {
  ANTLR_UINT32 _type;

  _type = VIRTUAL;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:176:8:
  // ( 'virtual' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:176:12:
  // 'virtual'
  {
    this->matchs(lit_23);
    if (this->hasException()) {
      goto ruleVIRTUALEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleVIRTUALEx; /* Prevent compiler warnings */
ruleVIRTUALEx:;
}
// $ANTLR end VIRTUAL

//   Comes from: 177:9: ( 'override' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OVERRIDE
 *
 * Looks to match the characters the constitute the token OVERRIDE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mOVERRIDE() {
  ANTLR_UINT32 _type;

  _type = OVERRIDE;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:177:9:
  // ( 'override' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:177:12:
  // 'override'
  {
    this->matchs(lit_24);
    if (this->hasException()) {
      goto ruleOVERRIDEEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleOVERRIDEEx; /* Prevent compiler warnings */
ruleOVERRIDEEx:;
}
// $ANTLR end OVERRIDE

//   Comes from: 178:8: ( '#include' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INCLUDE
 *
 * Looks to match the characters the constitute the token INCLUDE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mINCLUDE() {
  ANTLR_UINT32 _type;

  _type = INCLUDE;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:178:8:
  // ( '#include' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:178:12:
  // '#include'
  {
    this->matchs(lit_25);
    if (this->hasException()) {
      goto ruleINCLUDEEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleINCLUDEEx; /* Prevent compiler warnings */
ruleINCLUDEEx:;
}
// $ANTLR end INCLUDE

//   Comes from: 180:6: ( 'true' | 'false' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BOOL
 *
 * Looks to match the characters the constitute the token BOOL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mBOOL() {
  ANTLR_UINT32 _type;

  _type = BOOL;

  {
    //  C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:180:6:
    //  ( 'true' | 'false' )

    ANTLR_UINT32 alt1;

    alt1 = 2;

    switch (this->LA(1)) {
      case 't': {
        alt1 = 1;
      } break;
      case 'f': {
        alt1 = 2;
      } break;

      default:
        ExceptionBaseType* ex = new ANTLR_Exception<WNScriptASTLexerImplTraits,
            NO_VIABLE_ALT_EXCEPTION, StreamType>(this->get_rec(), "");
        ex->set_decisionNum(1);
        ex->set_state(0);

        goto ruleBOOLEx;
    }

    switch (alt1) {
      case 1:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:180:9:
        // 'true'
        {
          this->matchs(lit_26);
          if (this->hasException()) {
            goto ruleBOOLEx;
          }
        }
        break;
      case 2:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:180:18:
        // 'false'
        {
          this->matchs(lit_27);
          if (this->hasException()) {
            goto ruleBOOLEx;
          }
        }
        break;
    }
  }
  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleBOOLEx; /* Prevent compiler warnings */
ruleBOOLEx:;
}
// $ANTLR end BOOL

//   Comes from: 182:5: ( ( 'a' .. 'z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0'
//   .. '9' | '_' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ID
 *
 * Looks to match the characters the constitute the token ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mID() {
  ANTLR_UINT32 _type;

  _type = ID;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:182:5:
  // ( ( 'a' .. 'z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:182:10:
  // ( 'a' .. 'z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*
  {
    if (this->LA(1) == '_' || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z'))) {
      this->consume();
    } else {
      new ANTLR_Exception<WNScriptASTLexerImplTraits, MISMATCHED_SET_EXCEPTION,
          StreamType>(this->get_rec(), "");

      this->recover();
      goto ruleIDEx;
    }

    // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:182:25:
    // ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*

    for (;;) {
      int alt2 = 2;
      switch (this->LA(1)) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '_':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z': {
          alt2 = 1;
        } break;
      }

      switch (alt2) {
        case 1:
          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:
          {
            if (((this->LA(1) >= '0') && (this->LA(1) <= '9')) ||
                ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) ||
                this->LA(1) == '_' ||
                ((this->LA(1) >= 'a') && (this->LA(1) <= 'z'))) {
              this->consume();
            } else {
              new ANTLR_Exception<WNScriptASTLexerImplTraits,
                  MISMATCHED_SET_EXCEPTION, StreamType>(this->get_rec(), "");

              this->recover();
              goto ruleIDEx;
            }
          }
          break;

        default:
          goto loop2; /* break out of the loop */
          break;
      }
    }
  loop2:; /* Jump out to here if this rule does not match */
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleIDEx; /* Prevent compiler warnings */
ruleIDEx:;
}
// $ANTLR end ID

//   Comes from: 185:7: ( ( 'A' .. 'Z' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9'
//   | '_' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TYPE
 *
 * Looks to match the characters the constitute the token TYPE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mTYPE() {
  ANTLR_UINT32 _type;

  _type = TYPE;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:185:7:
  // ( ( 'A' .. 'Z' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:185:12:
  // ( 'A' .. 'Z' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*
  {
    if (((this->LA(1) >= 'A') && (this->LA(1) <= 'Z'))) {
      this->consume();
    } else {
      new ANTLR_Exception<WNScriptASTLexerImplTraits, MISMATCHED_SET_EXCEPTION,
          StreamType>(this->get_rec(), "");

      this->recover();
      goto ruleTYPEEx;
    }

    // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:185:23:
    // ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*

    for (;;) {
      int alt3 = 2;
      switch (this->LA(1)) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '_':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z': {
          alt3 = 1;
        } break;
      }

      switch (alt3) {
        case 1:
          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:
          {
            if (((this->LA(1) >= '0') && (this->LA(1) <= '9')) ||
                ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) ||
                this->LA(1) == '_' ||
                ((this->LA(1) >= 'a') && (this->LA(1) <= 'z'))) {
              this->consume();
            } else {
              new ANTLR_Exception<WNScriptASTLexerImplTraits,
                  MISMATCHED_SET_EXCEPTION, StreamType>(this->get_rec(), "");

              this->recover();
              goto ruleTYPEEx;
            }
          }
          break;

        default:
          goto loop3; /* break out of the loop */
          break;
      }
    }
  loop3:; /* Jump out to here if this rule does not match */
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleTYPEEx; /* Prevent compiler warnings */
ruleTYPEEx:;
}
// $ANTLR end TYPE

//   Comes from: 188:5: ( ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INT
 *
 * Looks to match the characters the constitute the token INT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mINT() {
  ANTLR_UINT32 _type;

  _type = INT;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:188:5:
  // ( ( '0' .. '9' )+ )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:188:10:
  // ( '0' .. '9' )+
  {
    // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:188:10:
    // ( '0' .. '9' )+
    {
      int cnt4 = 0;

      for (;;) {
        int alt4 = 2;
        switch (this->LA(1)) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9': {
            alt4 = 1;
          } break;
        }

        switch (alt4) {
          case 1:
            // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:
            {
              if (((this->LA(1) >= '0') && (this->LA(1) <= '9'))) {
                this->consume();
              } else {
                new ANTLR_Exception<WNScriptASTLexerImplTraits,
                    MISMATCHED_SET_EXCEPTION, StreamType>(this->get_rec(), "");

                this->recover();
                goto ruleINTEx;
              }
            }
            break;

          default:

            if (cnt4 >= 1) {
              goto loop4;
            }
            /* mismatchedSetEx()
             */
            new ANTLR_Exception<WNScriptASTLexerImplTraits,
                EARLY_EXIT_EXCEPTION, StreamType>(this->get_rec(), "");

            goto ruleINTEx;
        }
        cnt4++;
      }
    loop4:; /* Jump to here if this rule does not match */
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleINTEx; /* Prevent compiler warnings */
ruleINTEx:;
}
// $ANTLR end INT

//   Comes from: 192:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? |
//   '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOAT
 *
 * Looks to match the characters the constitute the token FLOAT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mFLOAT() {
  ANTLR_UINT32 _type;

  _type = FLOAT;

  {
    //  C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:192:5:
    //  ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9'
    //  )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT )

    ANTLR_UINT32 alt11;

    alt11 = 3;

    alt11 = cdfa11.predict(this, this->get_rec(), this->get_istream(), cdfa11);
    if (this->hasException()) {
      goto ruleFLOATEx;
    }

    switch (alt11) {
      case 1:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:192:9:
        // ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )?
        {
          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:192:9:
          // ( '0' .. '9' )+
          {
            int cnt5 = 0;

            for (;;) {
              int alt5 = 2;
              switch (this->LA(1)) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9': {
                  alt5 = 1;
                } break;
              }

              switch (alt5) {
                case 1:
                  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:
                  {
                    if (((this->LA(1) >= '0') && (this->LA(1) <= '9'))) {
                      this->consume();
                    } else {
                      new ANTLR_Exception<WNScriptASTLexerImplTraits,
                          MISMATCHED_SET_EXCEPTION, StreamType>(
                          this->get_rec(), "");

                      this->recover();
                      goto ruleFLOATEx;
                    }
                  }
                  break;

                default:

                  if (cnt5 >= 1) {
                    goto loop5;
                  }
                  /* mismatchedSetEx()
                   */
                  new ANTLR_Exception<WNScriptASTLexerImplTraits,
                      EARLY_EXIT_EXCEPTION, StreamType>(this->get_rec(), "");

                  goto ruleFLOATEx;
              }
              cnt5++;
            }
          loop5:; /* Jump to here if this rule does not match */
          }

          this->matchc('.');
          if (this->hasException()) {
            goto ruleFLOATEx;
          }

          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:192:25:
          // ( '0' .. '9' )*

          for (;;) {
            int alt6 = 2;
            switch (this->LA(1)) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9': {
                alt6 = 1;
              } break;
            }

            switch (alt6) {
              case 1:
                // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:
                {
                  if (((this->LA(1) >= '0') && (this->LA(1) <= '9'))) {
                    this->consume();
                  } else {
                    new ANTLR_Exception<WNScriptASTLexerImplTraits,
                        MISMATCHED_SET_EXCEPTION, StreamType>(
                        this->get_rec(), "");

                    this->recover();
                    goto ruleFLOATEx;
                  }
                }
                break;

              default:
                goto loop6; /* break out of the loop */
                break;
            }
          }
        loop6:; /* Jump out to here if this rule does not match */

          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:192:37:
          // ( EXPONENT )?
          {
            int alt7 = 2;
            switch (this->LA(1)) {
              case 'E':
              case 'e': {
                alt7 = 1;
              } break;
            }

            switch (alt7) {
              case 1:
                // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:192:37:
                // EXPONENT
                {
                  /* 192:37: EXPONENT */
                  mEXPONENT();
                  if (this->hasException()) {
                    goto ruleFLOATEx;
                  }
                }
                break;
            }
          }
        }
        break;
      case 2:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:193:9:
        // '.' ( '0' .. '9' )+ ( EXPONENT )?
        {
          this->matchc('.');
          if (this->hasException()) {
            goto ruleFLOATEx;
          }

          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:193:13:
          // ( '0' .. '9' )+
          {
            int cnt8 = 0;

            for (;;) {
              int alt8 = 2;
              switch (this->LA(1)) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9': {
                  alt8 = 1;
                } break;
              }

              switch (alt8) {
                case 1:
                  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:
                  {
                    if (((this->LA(1) >= '0') && (this->LA(1) <= '9'))) {
                      this->consume();
                    } else {
                      new ANTLR_Exception<WNScriptASTLexerImplTraits,
                          MISMATCHED_SET_EXCEPTION, StreamType>(
                          this->get_rec(), "");

                      this->recover();
                      goto ruleFLOATEx;
                    }
                  }
                  break;

                default:

                  if (cnt8 >= 1) {
                    goto loop8;
                  }
                  /* mismatchedSetEx()
                   */
                  new ANTLR_Exception<WNScriptASTLexerImplTraits,
                      EARLY_EXIT_EXCEPTION, StreamType>(this->get_rec(), "");

                  goto ruleFLOATEx;
              }
              cnt8++;
            }
          loop8:; /* Jump to here if this rule does not match */
          }

          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:193:25:
          // ( EXPONENT )?
          {
            int alt9 = 2;
            switch (this->LA(1)) {
              case 'E':
              case 'e': {
                alt9 = 1;
              } break;
            }

            switch (alt9) {
              case 1:
                // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:193:25:
                // EXPONENT
                {
                  /* 193:25: EXPONENT */
                  mEXPONENT();
                  if (this->hasException()) {
                    goto ruleFLOATEx;
                  }
                }
                break;
            }
          }
        }
        break;
      case 3:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:194:9:
        // ( '0' .. '9' )+ EXPONENT
        {
          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:194:9:
          // ( '0' .. '9' )+
          {
            int cnt10 = 0;

            for (;;) {
              int alt10 = 2;
              switch (this->LA(1)) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9': {
                  alt10 = 1;
                } break;
              }

              switch (alt10) {
                case 1:
                  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:
                  {
                    if (((this->LA(1) >= '0') && (this->LA(1) <= '9'))) {
                      this->consume();
                    } else {
                      new ANTLR_Exception<WNScriptASTLexerImplTraits,
                          MISMATCHED_SET_EXCEPTION, StreamType>(
                          this->get_rec(), "");

                      this->recover();
                      goto ruleFLOATEx;
                    }
                  }
                  break;

                default:

                  if (cnt10 >= 1) {
                    goto loop10;
                  }
                  /* mismatchedSetEx()
                   */
                  new ANTLR_Exception<WNScriptASTLexerImplTraits,
                      EARLY_EXIT_EXCEPTION, StreamType>(this->get_rec(), "");

                  goto ruleFLOATEx;
              }
              cnt10++;
            }
          loop10:; /* Jump to here if this rule does not match */
          }

          /* 194:9: ( '0' .. '9' )+ EXPONENT */
          mEXPONENT();
          if (this->hasException()) {
            goto ruleFLOATEx;
          }
        }
        break;
    }
  }
  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleFLOATEx; /* Prevent compiler warnings */
ruleFLOATEx:;
}
// $ANTLR end FLOAT

//   Comes from: 198:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '/*' (
//   options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mCOMMENT() {
  ANTLR_UINT32 _type;

  _type = COMMENT;

  {
    //  C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:198:5:
    //  ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '/*' ( options
    //  {greedy=false; } : . )* '*/' )

    ANTLR_UINT32 alt15;

    alt15 = 2;

    switch (this->LA(1)) {
      case '/': {
        switch (this->LA(2)) {
          case '/': {
            alt15 = 1;
          } break;
          case '*': {
            alt15 = 2;
          } break;

          default:
            ExceptionBaseType* ex =
                new ANTLR_Exception<WNScriptASTLexerImplTraits,
                    NO_VIABLE_ALT_EXCEPTION, StreamType>(this->get_rec(), "");
            ex->set_decisionNum(15);
            ex->set_state(1);

            goto ruleCOMMENTEx;
        }

      } break;

      default:
        ExceptionBaseType* ex = new ANTLR_Exception<WNScriptASTLexerImplTraits,
            NO_VIABLE_ALT_EXCEPTION, StreamType>(this->get_rec(), "");
        ex->set_decisionNum(15);
        ex->set_state(0);

        goto ruleCOMMENTEx;
    }

    switch (alt15) {
      case 1:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:198:9:
        // '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
        {
          this->matchs(lit_28);
          if (this->hasException()) {
            goto ruleCOMMENTEx;
          }

          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:198:14:
          // (~ ( '\\n' | '\\r' ) )*

          for (;;) {
            int alt12 = 2;
            {
              /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
               */
              int LA12_0 = this->LA(1);
              if ((((LA12_0 >= 0x0000) && (LA12_0 <= '\t')) ||
                      ((LA12_0 >= 0x000B) && (LA12_0 <= '\f')) ||
                      ((LA12_0 >= 0x000E) && (LA12_0 <= 0xFFFF)))) {
                alt12 = 1;
              }
            }
            switch (alt12) {
              case 1:
                // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:
                {
                  if (((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) ||
                      ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) ||
                      ((this->LA(1) >= 0x000E) && (this->LA(1) <= 0xFFFF))) {
                    this->consume();
                  } else {
                    new ANTLR_Exception<WNScriptASTLexerImplTraits,
                        MISMATCHED_SET_EXCEPTION, StreamType>(
                        this->get_rec(), "");

                    this->recover();
                    goto ruleCOMMENTEx;
                  }
                }
                break;

              default:
                goto loop12; /* break out of the loop */
                break;
            }
          }
        loop12:; /* Jump out to here if this rule does not match */

          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:198:28:
          // ( '\\r' )?
          {
            int alt13 = 2;
            switch (this->LA(1)) {
              case '\r': {
                alt13 = 1;
              } break;
            }

            switch (alt13) {
              case 1:
                // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:198:28:
                // '\\r'
                {
                  this->matchc('\r');
                  if (this->hasException()) {
                    goto ruleCOMMENTEx;
                  }
                }
                break;
            }
          }

          this->matchc('\n');
          if (this->hasException()) {
            goto ruleCOMMENTEx;
          }

          { this->get_state()->get_channel() = HIDDEN; }
        }
        break;
      case 2:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:199:9:
        // '/*' ( options {greedy=false; } : . )* '*/'
        {
          this->matchs(lit_29);
          if (this->hasException()) {
            goto ruleCOMMENTEx;
          }

          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:199:14:
          // ( options {greedy=false; } : . )*

          for (;;) {
            int alt14 = 2;
            {
              /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
               */
              int LA14_0 = this->LA(1);
              if ((LA14_0 == '*')) {
                {
                  /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                   */
                  int LA14_1 = this->LA(2);
                  if ((LA14_1 == '/')) {
                    alt14 = 2;
                  } else if ((((LA14_1 >= 0x0000) && (LA14_1 <= '.')) ||
                                 ((LA14_1 >= '0') && (LA14_1 <= 0xFFFF)))) {
                    alt14 = 1;
                  }
                }
              } else if ((((LA14_0 >= 0x0000) && (LA14_0 <= ')')) ||
                             ((LA14_0 >= '+') && (LA14_0 <= 0xFFFF)))) {
                alt14 = 1;
              }
            }
            switch (alt14) {
              case 1:
                // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:199:42:
                // .
                {
                  this->matchAny();
                  if (this->hasException()) {
                    goto ruleCOMMENTEx;
                  }
                }
                break;

              default:
                goto loop14; /* break out of the loop */
                break;
            }
          }
        loop14:; /* Jump out to here if this rule does not match */

          this->matchs(lit_30);
          if (this->hasException()) {
            goto ruleCOMMENTEx;
          }

          { this->get_state()->get_channel() = HIDDEN; }
        }
        break;
    }
  }
  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleCOMMENTEx; /* Prevent compiler warnings */
ruleCOMMENTEx:;
}
// $ANTLR end COMMENT

//   Comes from: 202:5: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mWS() {
  ANTLR_UINT32 _type;

  _type = WS;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:202:5:
  // ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:202:9:
  // ( ' ' | '\\t' | '\\r' | '\\n' )
  {
    if (((this->LA(1) >= '\t') && (this->LA(1) <= '\n')) ||
        this->LA(1) == '\r' || this->LA(1) == ' ') {
      this->consume();
    } else {
      new ANTLR_Exception<WNScriptASTLexerImplTraits, MISMATCHED_SET_EXCEPTION,
          StreamType>(this->get_rec(), "");

      this->recover();
      goto ruleWSEx;
    }

    { this->get_state()->get_channel() = HIDDEN; }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleWSEx; /* Prevent compiler warnings */
ruleWSEx:;
}
// $ANTLR end WS

//   Comes from: 210:5: ( '\"' ( ESC_SEQ |~ ( '\\\\' | '\"' ) )* '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING
 *
 * Looks to match the characters the constitute the token STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mSTRING() {
  ANTLR_UINT32 _type;

  _type = STRING;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:210:5:
  // ( '\"' ( ESC_SEQ |~ ( '\\\\' | '\"' ) )* '\"' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:210:8:
  // '\"' ( ESC_SEQ |~ ( '\\\\' | '\"' ) )* '\"'
  {
    this->matchc('"');
    if (this->hasException()) {
      goto ruleSTRINGEx;
    }

    // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:210:12:
    // ( ESC_SEQ |~ ( '\\\\' | '\"' ) )*

    for (;;) {
      int alt16 = 3;
      {
        /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
         */
        int LA16_0 = this->LA(1);
        if ((LA16_0 == '\\')) {
          alt16 = 1;
        } else if ((((LA16_0 >= 0x0000) && (LA16_0 <= '!')) ||
                       ((LA16_0 >= '#') && (LA16_0 <= '[')) ||
                       ((LA16_0 >= ']') && (LA16_0 <= 0xFFFF)))) {
          alt16 = 2;
        }
      }
      switch (alt16) {
        case 1:
          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:210:14:
          // ESC_SEQ
          {
            /* 210:14: ESC_SEQ */
            mESC_SEQ();
            if (this->hasException()) {
              goto ruleSTRINGEx;
            }
          }
          break;
        case 2:
          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:210:24:
          // ~ ( '\\\\' | '\"' )
          {
            if (((this->LA(1) >= 0x0000) && (this->LA(1) <= '!')) ||
                ((this->LA(1) >= '#') && (this->LA(1) <= '[')) ||
                ((this->LA(1) >= ']') && (this->LA(1) <= 0xFFFF))) {
              this->consume();
            } else {
              new ANTLR_Exception<WNScriptASTLexerImplTraits,
                  MISMATCHED_SET_EXCEPTION, StreamType>(this->get_rec(), "");

              this->recover();
              goto ruleSTRINGEx;
            }
          }
          break;

        default:
          goto loop16; /* break out of the loop */
          break;
      }
    }
  loop16:; /* Jump out to here if this rule does not match */

    this->matchc('"');
    if (this->hasException()) {
      goto ruleSTRINGEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleSTRINGEx; /* Prevent compiler warnings */
ruleSTRINGEx:;
}
// $ANTLR end STRING

//   Comes from: 213:5: ( '\\'' ( ESC_SEQ |~ ( '\\'' | '\\\\' ) ) '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHAR
 *
 * Looks to match the characters the constitute the token CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mCHAR() {
  ANTLR_UINT32 _type;

  _type = CHAR;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:213:5:
  // ( '\\'' ( ESC_SEQ |~ ( '\\'' | '\\\\' ) ) '\\'' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:213:8:
  // '\\'' ( ESC_SEQ |~ ( '\\'' | '\\\\' ) ) '\\''
  {
    this->matchc('\'');
    if (this->hasException()) {
      goto ruleCHAREx;
    }

    // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:213:13:
    // ( ESC_SEQ |~ ( '\\'' | '\\\\' ) )
    {
      int alt17 = 2;
      {
        int LA17_0 = this->LA(1);
        if ((LA17_0 == '\\')) {
          alt17 = 1;
        } else if ((((LA17_0 >= 0x0000) && (LA17_0 <= '&')) ||
                       ((LA17_0 >= '(') && (LA17_0 <= '[')) ||
                       ((LA17_0 >= ']') && (LA17_0 <= 0xFFFF)))) {
          alt17 = 2;
        } else {
          ExceptionBaseType* ex =
              new ANTLR_Exception<WNScriptASTLexerImplTraits,
                  NO_VIABLE_ALT_EXCEPTION, StreamType>(this->get_rec(), "");
          ex->set_decisionNum(17);
          ex->set_state(0);

          goto ruleCHAREx;
        }
      }
      switch (alt17) {
        case 1:
          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:213:15:
          // ESC_SEQ
          {
            /* 213:15: ESC_SEQ */
            mESC_SEQ();
            if (this->hasException()) {
              goto ruleCHAREx;
            }
          }
          break;
        case 2:
          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:213:25:
          // ~ ( '\\'' | '\\\\' )
          {
            if (((this->LA(1) >= 0x0000) && (this->LA(1) <= '&')) ||
                ((this->LA(1) >= '(') && (this->LA(1) <= '[')) ||
                ((this->LA(1) >= ']') && (this->LA(1) <= 0xFFFF))) {
              this->consume();
            } else {
              new ANTLR_Exception<WNScriptASTLexerImplTraits,
                  MISMATCHED_SET_EXCEPTION, StreamType>(this->get_rec(), "");

              this->recover();
              goto ruleCHAREx;
            }
          }
          break;
      }
    }

    this->matchc('\'');
    if (this->hasException()) {
      goto ruleCHAREx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleCHAREx; /* Prevent compiler warnings */
ruleCHAREx:;
}
// $ANTLR end CHAR

//   Comes from: 216:8: ( '~' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NULLTOK
 *
 * Looks to match the characters the constitute the token NULLTOK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mNULLTOK() {
  ANTLR_UINT32 _type;

  _type = NULLTOK;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:216:8:
  // ( '~' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:216:10:
  // '~'
  {
    this->matchc('~');
    if (this->hasException()) {
      goto ruleNULLTOKEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleNULLTOKEx; /* Prevent compiler warnings */
ruleNULLTOKEx:;
}
// $ANTLR end NULLTOK

//   Comes from: 219:6: ( '<==' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHOWN
 *
 * Looks to match the characters the constitute the token CHOWN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mCHOWN() {
  ANTLR_UINT32 _type;

  _type = CHOWN;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:219:6:
  // ( '<==' )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:219:8:
  // '<=='
  {
    this->matchs(lit_31);
    if (this->hasException()) {
      goto ruleCHOWNEx;
    }
  }

  this->get_lexstate()->set_type(_type);
  // This is where rules clean up and exit
  //
  goto ruleCHOWNEx; /* Prevent compiler warnings */
ruleCHOWNEx:;
}
// $ANTLR end CHOWN

//   Comes from: 224:10: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXPONENT
 *
 * Looks to match the characters the constitute the token EXPONENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mEXPONENT() {
  ANTLR_UINT32 _type;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:224:10:
  // ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:224:12:
  // ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+
  {
    if (this->LA(1) == 'E' || this->LA(1) == 'e') {
      this->consume();
    } else {
      new ANTLR_Exception<WNScriptASTLexerImplTraits, MISMATCHED_SET_EXCEPTION,
          StreamType>(this->get_rec(), "");

      this->recover();
      goto ruleEXPONENTEx;
    }

    // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:224:22:
    // ( '+' | '-' )?
    {
      int alt18 = 2;
      switch (this->LA(1)) {
        case '+':
        case '-': {
          alt18 = 1;
        } break;
      }

      switch (alt18) {
        case 1:
          // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:
          {
            if (this->LA(1) == '+' || this->LA(1) == '-') {
              this->consume();
            } else {
              new ANTLR_Exception<WNScriptASTLexerImplTraits,
                  MISMATCHED_SET_EXCEPTION, StreamType>(this->get_rec(), "");

              this->recover();
              goto ruleEXPONENTEx;
            }
          }
          break;
      }
    }

    // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:224:33:
    // ( '0' .. '9' )+
    {
      int cnt19 = 0;

      for (;;) {
        int alt19 = 2;
        switch (this->LA(1)) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9': {
            alt19 = 1;
          } break;
        }

        switch (alt19) {
          case 1:
            // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:
            {
              if (((this->LA(1) >= '0') && (this->LA(1) <= '9'))) {
                this->consume();
              } else {
                new ANTLR_Exception<WNScriptASTLexerImplTraits,
                    MISMATCHED_SET_EXCEPTION, StreamType>(this->get_rec(), "");

                this->recover();
                goto ruleEXPONENTEx;
              }
            }
            break;

          default:

            if (cnt19 >= 1) {
              goto loop19;
            }
            /* mismatchedSetEx()
             */
            new ANTLR_Exception<WNScriptASTLexerImplTraits,
                EARLY_EXIT_EXCEPTION, StreamType>(this->get_rec(), "");

            goto ruleEXPONENTEx;
        }
        cnt19++;
      }
    loop19:; /* Jump to here if this rule does not match */
    }
  }

  // This is where rules clean up and exit
  //
  goto ruleEXPONENTEx; /* Prevent compiler warnings */
ruleEXPONENTEx:;
}
// $ANTLR end EXPONENT

//   Comes from: 227:11: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_DIGIT
 *
 * Looks to match the characters the constitute the token HEX_DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mHEX_DIGIT() {
  ANTLR_UINT32 _type;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:227:11:
  // ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:
  {
    if (((this->LA(1) >= '0') && (this->LA(1) <= '9')) ||
        ((this->LA(1) >= 'A') && (this->LA(1) <= 'F')) ||
        ((this->LA(1) >= 'a') && (this->LA(1) <= 'f'))) {
      this->consume();
    } else {
      new ANTLR_Exception<WNScriptASTLexerImplTraits, MISMATCHED_SET_EXCEPTION,
          StreamType>(this->get_rec(), "");

      this->recover();
      goto ruleHEX_DIGITEx;
    }
  }

  // This is where rules clean up and exit
  //
  goto ruleHEX_DIGITEx; /* Prevent compiler warnings */
ruleHEX_DIGITEx:;
}
// $ANTLR end HEX_DIGIT

//   Comes from: 231:5: ( UNICODE_ESC | OCTAL_ESC | '\\\\' ( 'b' | 't' | 'n' |
//   'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ESC_SEQ
 *
 * Looks to match the characters the constitute the token ESC_SEQ
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mESC_SEQ() {
  ANTLR_UINT32 _type;

  {
    //  C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:231:5:
    //  ( UNICODE_ESC | OCTAL_ESC | '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' |
    //  '\\\"' | '\\'' | '\\\\' ) )

    ANTLR_UINT32 alt20;

    alt20 = 3;

    switch (this->LA(1)) {
      case '\\': {
        switch (this->LA(2)) {
          case 'u': {
            alt20 = 1;
          } break;
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7': {
            alt20 = 2;
          } break;
          case '"':
          case '\'':
          case '\\':
          case 'b':
          case 'f':
          case 'n':
          case 'r':
          case 't': {
            alt20 = 3;
          } break;

          default:
            ExceptionBaseType* ex =
                new ANTLR_Exception<WNScriptASTLexerImplTraits,
                    NO_VIABLE_ALT_EXCEPTION, StreamType>(this->get_rec(), "");
            ex->set_decisionNum(20);
            ex->set_state(1);

            goto ruleESC_SEQEx;
        }

      } break;

      default:
        ExceptionBaseType* ex = new ANTLR_Exception<WNScriptASTLexerImplTraits,
            NO_VIABLE_ALT_EXCEPTION, StreamType>(this->get_rec(), "");
        ex->set_decisionNum(20);
        ex->set_state(0);

        goto ruleESC_SEQEx;
    }

    switch (alt20) {
      case 1:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:231:13:
        // UNICODE_ESC
        {
          /* 231:13: UNICODE_ESC */
          mUNICODE_ESC();
          if (this->hasException()) {
            goto ruleESC_SEQEx;
          }
        }
        break;
      case 2:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:232:9:
        // OCTAL_ESC
        {
          /* 232:9: OCTAL_ESC */
          mOCTAL_ESC();
          if (this->hasException()) {
            goto ruleESC_SEQEx;
          }
        }
        break;
      case 3:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:233:9:
        // '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' )
        {
          this->matchc('\\');
          if (this->hasException()) {
            goto ruleESC_SEQEx;
          }

          if (this->LA(1) == '"' || this->LA(1) == '\'' ||
              this->LA(1) == '\\' || this->LA(1) == 'b' || this->LA(1) == 'f' ||
              this->LA(1) == 'n' || this->LA(1) == 'r' || this->LA(1) == 't') {
            this->consume();
          } else {
            new ANTLR_Exception<WNScriptASTLexerImplTraits,
                MISMATCHED_SET_EXCEPTION, StreamType>(this->get_rec(), "");

            this->recover();
            goto ruleESC_SEQEx;
          }
        }
        break;
    }
  }

  // This is where rules clean up and exit
  //
  goto ruleESC_SEQEx; /* Prevent compiler warnings */
ruleESC_SEQEx:;
}
// $ANTLR end ESC_SEQ

//   Comes from: 238:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) |
//   '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OCTAL_ESC
 *
 * Looks to match the characters the constitute the token OCTAL_ESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mOCTAL_ESC() {
  ANTLR_UINT32 _type;

  {
    //  C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:238:5:
    //  ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' ..
    //  '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )

    ANTLR_UINT32 alt21;

    alt21 = 3;

    switch (this->LA(1)) {
      case '\\': {
        switch (this->LA(2)) {
          case '0':
          case '1':
          case '2':
          case '3': {
            switch (this->LA(3)) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7': {
                switch (this->LA(4)) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7': {
                    alt21 = 1;
                  } break;

                  default:
                    alt21 = 2;
                }

              } break;

              default:
                alt21 = 3;
            }

          } break;
          case '4':
          case '5':
          case '6':
          case '7': {
            switch (this->LA(3)) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7': {
                alt21 = 2;
              } break;

              default:
                alt21 = 3;
            }

          } break;

          default:
            ExceptionBaseType* ex =
                new ANTLR_Exception<WNScriptASTLexerImplTraits,
                    NO_VIABLE_ALT_EXCEPTION, StreamType>(this->get_rec(), "");
            ex->set_decisionNum(21);
            ex->set_state(1);

            goto ruleOCTAL_ESCEx;
        }

      } break;

      default:
        ExceptionBaseType* ex = new ANTLR_Exception<WNScriptASTLexerImplTraits,
            NO_VIABLE_ALT_EXCEPTION, StreamType>(this->get_rec(), "");
        ex->set_decisionNum(21);
        ex->set_state(0);

        goto ruleOCTAL_ESCEx;
    }

    switch (alt21) {
      case 1:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:238:9:
        // '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' )
        {
          this->matchc('\\');
          if (this->hasException()) {
            goto ruleOCTAL_ESCEx;
          }

          if (((this->LA(1) >= '0') && (this->LA(1) <= '3'))) {
            this->consume();
          } else {
            new ANTLR_Exception<WNScriptASTLexerImplTraits,
                MISMATCHED_SET_EXCEPTION, StreamType>(this->get_rec(), "");

            this->recover();
            goto ruleOCTAL_ESCEx;
          }

          if (((this->LA(1) >= '0') && (this->LA(1) <= '7'))) {
            this->consume();
          } else {
            new ANTLR_Exception<WNScriptASTLexerImplTraits,
                MISMATCHED_SET_EXCEPTION, StreamType>(this->get_rec(), "");

            this->recover();
            goto ruleOCTAL_ESCEx;
          }

          if (((this->LA(1) >= '0') && (this->LA(1) <= '7'))) {
            this->consume();
          } else {
            new ANTLR_Exception<WNScriptASTLexerImplTraits,
                MISMATCHED_SET_EXCEPTION, StreamType>(this->get_rec(), "");

            this->recover();
            goto ruleOCTAL_ESCEx;
          }
        }
        break;
      case 2:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:239:9:
        // '\\\\' ( '0' .. '7' ) ( '0' .. '7' )
        {
          this->matchc('\\');
          if (this->hasException()) {
            goto ruleOCTAL_ESCEx;
          }

          if (((this->LA(1) >= '0') && (this->LA(1) <= '7'))) {
            this->consume();
          } else {
            new ANTLR_Exception<WNScriptASTLexerImplTraits,
                MISMATCHED_SET_EXCEPTION, StreamType>(this->get_rec(), "");

            this->recover();
            goto ruleOCTAL_ESCEx;
          }

          if (((this->LA(1) >= '0') && (this->LA(1) <= '7'))) {
            this->consume();
          } else {
            new ANTLR_Exception<WNScriptASTLexerImplTraits,
                MISMATCHED_SET_EXCEPTION, StreamType>(this->get_rec(), "");

            this->recover();
            goto ruleOCTAL_ESCEx;
          }
        }
        break;
      case 3:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:240:9:
        // '\\\\' ( '0' .. '7' )
        {
          this->matchc('\\');
          if (this->hasException()) {
            goto ruleOCTAL_ESCEx;
          }

          if (((this->LA(1) >= '0') && (this->LA(1) <= '7'))) {
            this->consume();
          } else {
            new ANTLR_Exception<WNScriptASTLexerImplTraits,
                MISMATCHED_SET_EXCEPTION, StreamType>(this->get_rec(), "");

            this->recover();
            goto ruleOCTAL_ESCEx;
          }
        }
        break;
    }
  }

  // This is where rules clean up and exit
  //
  goto ruleOCTAL_ESCEx; /* Prevent compiler warnings */
ruleOCTAL_ESCEx:;
}
// $ANTLR end OCTAL_ESC

//   Comes from: 245:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNICODE_ESC
 *
 * Looks to match the characters the constitute the token UNICODE_ESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void WNScriptASTLexer::mUNICODE_ESC() {
  ANTLR_UINT32 _type;

  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:245:5:
  // ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
  // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:245:9:
  // '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
  {
    this->matchc('\\');
    if (this->hasException()) {
      goto ruleUNICODE_ESCEx;
    }

    this->matchc('u');
    if (this->hasException()) {
      goto ruleUNICODE_ESCEx;
    }

    /* 245:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
    mHEX_DIGIT();
    if (this->hasException()) {
      goto ruleUNICODE_ESCEx;
    }

    /* 245:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
    mHEX_DIGIT();
    if (this->hasException()) {
      goto ruleUNICODE_ESCEx;
    }

    /* 245:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
    mHEX_DIGIT();
    if (this->hasException()) {
      goto ruleUNICODE_ESCEx;
    }

    /* 245:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
    mHEX_DIGIT();
    if (this->hasException()) {
      goto ruleUNICODE_ESCEx;
    }
  }

  // This is where rules clean up and exit
  //
  goto ruleUNICODE_ESCEx; /* Prevent compiler warnings */
ruleUNICODE_ESCEx:;
}
// $ANTLR end UNICODE_ESC

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
void WNScriptASTLexer::mTokens() {
  {
    //  C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:8:
    //  ( T__43 | T__44 | T__45 | T__46 | T__47 | T__48 | T__49 | T__50 | T__51
    //  | T__52 | T__53 | T__54 | T__55 | T__56 | T__57 | T__58 | T__59 | T__60
    //  | T__61 | T__62 | T__63 | LSQBRACKET | RSQBRACKET | LBRACKET | RBRACKET
    //  | LBRACE | RBRACE | COMMA | DOUBINC | DOUBDEC | RETURN | RETURN_OWN |
    //  SEMICOLON | COLON | WHILE | DO | IF | ELSE | FOR | STRUCT | CLASS |
    //  VIRTUAL | OVERRIDE | INCLUDE | BOOL | ID | TYPE | INT | FLOAT | COMMENT
    //  | WS | STRING | CHAR | NULLTOK | CHOWN )

    ANTLR_UINT32 alt22;

    alt22 = 55;

    alt22 = cdfa22.predict(this, this->get_rec(), this->get_istream(), cdfa22);
    if (this->hasException()) {
      goto ruleTokensEx;
    }

    switch (alt22) {
      case 1:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:10:
        // T__43
        {
          /* 1:10: T__43 */
          mT__43();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 2:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:16:
        // T__44
        {
          /* 1:16: T__44 */
          mT__44();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 3:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:22:
        // T__45
        {
          /* 1:22: T__45 */
          mT__45();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 4:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:28:
        // T__46
        {
          /* 1:28: T__46 */
          mT__46();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 5:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:34:
        // T__47
        {
          /* 1:34: T__47 */
          mT__47();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 6:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:40:
        // T__48
        {
          /* 1:40: T__48 */
          mT__48();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 7:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:46:
        // T__49
        {
          /* 1:46: T__49 */
          mT__49();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 8:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:52:
        // T__50
        {
          /* 1:52: T__50 */
          mT__50();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 9:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:58:
        // T__51
        {
          /* 1:58: T__51 */
          mT__51();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 10:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:64:
        // T__52
        {
          /* 1:64: T__52 */
          mT__52();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 11:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:70:
        // T__53
        {
          /* 1:70: T__53 */
          mT__53();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 12:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:76:
        // T__54
        {
          /* 1:76: T__54 */
          mT__54();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 13:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:82:
        // T__55
        {
          /* 1:82: T__55 */
          mT__55();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 14:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:88:
        // T__56
        {
          /* 1:88: T__56 */
          mT__56();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 15:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:94:
        // T__57
        {
          /* 1:94: T__57 */
          mT__57();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 16:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:100:
        // T__58
        {
          /* 1:100: T__58 */
          mT__58();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 17:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:106:
        // T__59
        {
          /* 1:106: T__59 */
          mT__59();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 18:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:112:
        // T__60
        {
          /* 1:112: T__60 */
          mT__60();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 19:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:118:
        // T__61
        {
          /* 1:118: T__61 */
          mT__61();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 20:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:124:
        // T__62
        {
          /* 1:124: T__62 */
          mT__62();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 21:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:130:
        // T__63
        {
          /* 1:130: T__63 */
          mT__63();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 22:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:136:
        // LSQBRACKET
        {
          /* 1:136: LSQBRACKET */
          mLSQBRACKET();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 23:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:147:
        // RSQBRACKET
        {
          /* 1:147: RSQBRACKET */
          mRSQBRACKET();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 24:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:158:
        // LBRACKET
        {
          /* 1:158: LBRACKET */
          mLBRACKET();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 25:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:167:
        // RBRACKET
        {
          /* 1:167: RBRACKET */
          mRBRACKET();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 26:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:176:
        // LBRACE
        {
          /* 1:176: LBRACE */
          mLBRACE();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 27:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:183:
        // RBRACE
        {
          /* 1:183: RBRACE */
          mRBRACE();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 28:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:190:
        // COMMA
        {
          /* 1:190: COMMA */
          mCOMMA();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 29:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:196:
        // DOUBINC
        {
          /* 1:196: DOUBINC */
          mDOUBINC();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 30:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:204:
        // DOUBDEC
        {
          /* 1:204: DOUBDEC */
          mDOUBDEC();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 31:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:212:
        // RETURN
        {
          /* 1:212: RETURN */
          mRETURN();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 32:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:219:
        // RETURN_OWN
        {
          /* 1:219: RETURN_OWN */
          mRETURN_OWN();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 33:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:230:
        // SEMICOLON
        {
          /* 1:230: SEMICOLON */
          mSEMICOLON();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 34:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:240:
        // COLON
        {
          /* 1:240: COLON */
          mCOLON();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 35:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:246:
        // WHILE
        {
          /* 1:246: WHILE */
          mWHILE();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 36:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:252:
        // DO
        {
          /* 1:252: DO */
          mDO();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 37:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:255:
        // IF
        {
          /* 1:255: IF */
          mIF();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 38:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:258:
        // ELSE
        {
          /* 1:258: ELSE */
          mELSE();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 39:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:263:
        // FOR
        {
          /* 1:263: FOR */
          mFOR();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 40:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:267:
        // STRUCT
        {
          /* 1:267: STRUCT */
          mSTRUCT();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 41:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:274:
        // CLASS
        {
          /* 1:274: CLASS */
          mCLASS();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 42:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:280:
        // VIRTUAL
        {
          /* 1:280: VIRTUAL */
          mVIRTUAL();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 43:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:288:
        // OVERRIDE
        {
          /* 1:288: OVERRIDE */
          mOVERRIDE();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 44:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:297:
        // INCLUDE
        {
          /* 1:297: INCLUDE */
          mINCLUDE();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 45:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:305:
        // BOOL
        {
          /* 1:305: BOOL */
          mBOOL();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 46:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:310:
        // ID
        {
          /* 1:310: ID */
          mID();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 47:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:313:
        // TYPE
        {
          /* 1:313: TYPE */
          mTYPE();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 48:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:318:
        // INT
        {
          /* 1:318: INT */
          mINT();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 49:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:322:
        // FLOAT
        {
          /* 1:322: FLOAT */
          mFLOAT();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 50:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:328:
        // COMMENT
        {
          /* 1:328: COMMENT */
          mCOMMENT();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 51:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:336:
        // WS
        {
          /* 1:336: WS */
          mWS();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 52:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:339:
        // STRING
        {
          /* 1:339: STRING */
          mSTRING();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 53:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:346:
        // CHAR
        {
          /* 1:346: CHAR */
          mCHAR();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 54:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:351:
        // NULLTOK
        {
          /* 1:351: NULLTOK */
          mNULLTOK();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
      case 55:
        // C:\\Users\\Andre\\Documents\\Development\\WNFramework\\Libraries\\WNDeprecatedScripting\\lang\\WNScriptAST.g:1:359:
        // CHOWN
        {
          /* 1:359: CHOWN */
          mCHOWN();
          if (this->hasException()) {
            goto ruleTokensEx;
          }
        }
        break;
    }
  }

  goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx:;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */

/* End of code
 * =============================================================================
 */
