/** \file
 *  This C++ source file was generated by $ANTLR version 3.5
 *
 *     -  From the grammar source file : WNScriptAST.g
 *     -                            On : 2013-12-01 11:12:12
 *     -                for the parser : WNScriptASTParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

    #include "WNCore/inc/WNBase.h"
#ifdef _WN_MSVC
    #pragma warning(disable: 4703)
#endif
    #include "WNScripting/src/WNScriptASTLexer.hpp"
    #include "WNScripting/inc/WNScriptingAllocations.h"
    #include "WNScripting/inc/WNArgList.h"
    #include "WNScripting/inc/WNArrayAccessExpression.h"
    #include "WNScripting/inc/WNArrayAllocation.h"
    #include "WNScripting/inc/WNAssignment.h"
    #include "WNScripting/inc/WNBinExpression.h"
    #include "WNScripting/inc/WNCondExpression.h"
    #include "WNScripting/inc/WNConstantExpression.h"
    #include "WNScripting/inc/WNDeclaration.h"
    #include "WNScripting/inc/WNDeclList.h"
    #include "WNScripting/inc/WNDoInstruction.h"
    #include "WNScripting/inc/WNExpression.h"
    #include "WNScripting/inc/WNForInstruction.h"
    #include "WNScripting/inc/WNFunction.h"
    #include "WNScripting/inc/WNFunctionCallExpression.h"
    #include "WNScripting/inc/WNIDExpression.h"
    #include "WNScripting/inc/WNIfInstruction.h"
    #include "WNScripting/inc/WNInstruction.h"
    #include "WNScripting/inc/WNInstructionList.h"
    #include "WNScripting/inc/WNLValue.h"
    #include "WNScripting/inc/WNMemberAccessExpression.h"
    #include "WNScripting/inc/WNNode.h"
    #include "WNScripting/inc/WNNullAllocation.h"
    #include "WNScripting/inc/WNPostExpression.h"
    #include "WNScripting/inc/WNPostUNExpression.h"
    #include "WNScripting/inc/WNScriptFile.h"
    #include "WNScripting/inc/WNSSExpression.h"
    #include "WNScripting/inc/WNStruct.h"
    #include "WNScripting/inc/WNStructAllocation.h"
    #include "WNScripting/inc/WNTypeNode.h"
    #include "WNScripting/inc/WNUnExpression.h"
    #include "WNScripting/inc/WNWhileInstruction.h"
    #include "WNScripting/inc/WNReturn.h"
    using namespace WNScripting;
    //
    //

    #ifndef SetLocation
    #define SetLocation(node, tok) { WNScriptLocation loc; \
                                     loc.mStartIndex = tok->get_startIndex();\
                                     loc.mEndIndex = tok->get_stopIndex();\
                                     loc.mLineStart = tok->get_lineStart();\
                                     loc.mLineNumber = tok->get_line();\
                                     loc.mCharNumber = tok->get_charPositionInLine();\
                                     node->SetStartPosition(loc); \
                                   }
    #define SetLocationFromNode(node, node2) { \
                                        if(node2) { \
                                        node->SetStartPosition(node2->GetStartPosition()); \
                                        } \
                                   }
    #define SetStartLocationFromNode(node, node2) { \
                                        if(node2) { \
                                        WNScriptLocation loc = node->GetStartPosition(); \
                                        WNScriptLocation loc2 = node2->GetStartPosition(); \
                                        loc.mStartIndex = loc2.mStartIndex; \
                                        loc.mLineStart = loc2.mLineStart; \
                                        loc.mLineNumber = loc2.mLineNumber; \
                                        loc.mCharNumber = loc2.mCharNumber; \
                                        node->SetStartPosition(loc); \
                                        } \
                                    }
    #define SetEndLocation(node, tok) { \
                                        node->SetEndIndex(tok->get_stopIndex()); \
                                      }
    #define SetEndLocationFromNode(node, node2) { \
                                            if(node2) { \
                                            node->SetEndIndex(node2->GetStartPosition().mEndIndex); \
                                            } \
                                            }
    #endif

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "WNScriptASTParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   WNScriptASTParserTokenNames[60+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "BOOL",
        (ANTLR_UINT8*) "CHAR",
        (ANTLR_UINT8*) "CHOWN",
        (ANTLR_UINT8*) "CLASS",
        (ANTLR_UINT8*) "COLON",
        (ANTLR_UINT8*) "COMMA",
        (ANTLR_UINT8*) "COMMENT",
        (ANTLR_UINT8*) "DO",
        (ANTLR_UINT8*) "DOUBDEC",
        (ANTLR_UINT8*) "DOUBINC",
        (ANTLR_UINT8*) "ELSE",
        (ANTLR_UINT8*) "ESC_SEQ",
        (ANTLR_UINT8*) "EXPONENT",
        (ANTLR_UINT8*) "FLOAT",
        (ANTLR_UINT8*) "FOR",
        (ANTLR_UINT8*) "HEX_DIGIT",
        (ANTLR_UINT8*) "ID",
        (ANTLR_UINT8*) "IF",
        (ANTLR_UINT8*) "INCLUDE",
        (ANTLR_UINT8*) "INT",
        (ANTLR_UINT8*) "LBRACE",
        (ANTLR_UINT8*) "LBRACKET",
        (ANTLR_UINT8*) "LSQBRACKET",
        (ANTLR_UINT8*) "NULLTOK",
        (ANTLR_UINT8*) "OCTAL_ESC",
        (ANTLR_UINT8*) "OVERRIDE",
        (ANTLR_UINT8*) "RBRACE",
        (ANTLR_UINT8*) "RBRACKET",
        (ANTLR_UINT8*) "RETURN",
        (ANTLR_UINT8*) "RETURN_OWN",
        (ANTLR_UINT8*) "RSQBRACKET",
        (ANTLR_UINT8*) "SEMICOLON",
        (ANTLR_UINT8*) "STRING",
        (ANTLR_UINT8*) "STRUCT",
        (ANTLR_UINT8*) "TYPE",
        (ANTLR_UINT8*) "UNICODE_ESC",
        (ANTLR_UINT8*) "VIRTUAL",
        (ANTLR_UINT8*) "WHILE",
        (ANTLR_UINT8*) "WS",
        (ANTLR_UINT8*) "'!='",
        (ANTLR_UINT8*) "'%'",
        (ANTLR_UINT8*) "'%='",
        (ANTLR_UINT8*) "'&&'",
        (ANTLR_UINT8*) "'*'",
        (ANTLR_UINT8*) "'*='",
        (ANTLR_UINT8*) "'+'",
        (ANTLR_UINT8*) "'+='",
        (ANTLR_UINT8*) "'-'",
        (ANTLR_UINT8*) "'-='",
        (ANTLR_UINT8*) "'.'",
        (ANTLR_UINT8*) "'/'",
        (ANTLR_UINT8*) "'/='",
        (ANTLR_UINT8*) "'<'",
        (ANTLR_UINT8*) "'<='",
        (ANTLR_UINT8*) "'='",
        (ANTLR_UINT8*) "'=='",
        (ANTLR_UINT8*) "'>'",
        (ANTLR_UINT8*) "'>='",
        (ANTLR_UINT8*) "'?'",
        (ANTLR_UINT8*) "'||'"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "WNScriptAST.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* WNScriptASTParser::getGrammarFileName()
{
    return fileName;
}
/** \brief Create a new WNScriptASTParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
WNScriptASTParser::WNScriptASTParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
    // See if we can create a new parser with the standard constructor
    //
    this->init(instream);
}

/** \brief Create a new WNScriptASTParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
WNScriptASTParser::WNScriptASTParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
    this->init(instream );
}

void WNScriptASTParser::init(StreamType* instream)
{
    /* Install the token table
    */
    this->get_psrstate()->set_tokenNames( WNScriptASTParserTokenNames );


}

void
WNScriptASTParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
WNScriptASTParser::~WNScriptASTParser()
 {
}

/** Return token names used by this
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**    getTokenNames()
{
        return WNScriptASTParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_TYPE_in_scalarType1128_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_TYPE_in_scalarType1128( FOLLOW_TYPE_in_scalarType1128_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_scalarType_in_type1167_bits[]    = { ANTLR_UINT64_LIT(0x0000000004000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_scalarType_in_type1167( FOLLOW_scalarType_in_type1167_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LSQBRACKET_in_type1188_bits[]    = { ANTLR_UINT64_LIT(0x0000000400000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LSQBRACKET_in_type1188( FOLLOW_LSQBRACKET_in_type1188_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RSQBRACKET_in_type1190_bits[]    = { ANTLR_UINT64_LIT(0x0000000004000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RSQBRACKET_in_type1190( FOLLOW_RSQBRACKET_in_type1190_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_type_in_decl1222_bits[]    = { ANTLR_UINT64_LIT(0x0000000000100000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_type_in_decl1222( FOLLOW_type_in_decl1222_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_ID_in_decl1224_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_ID_in_decl1224( FOLLOW_ID_in_decl1224_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_decl_in_declList1256_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000202) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_decl_in_declList1256( FOLLOW_decl_in_declList1256_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_COMMA_in_declList1269_bits[]    = { ANTLR_UINT64_LIT(0x0000004000000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_COMMA_in_declList1269( FOLLOW_COMMA_in_declList1269_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_decl_in_declList1273_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000202) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_decl_in_declList1273( FOLLOW_decl_in_declList1273_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACKET_in_parameterList1305_bits[]    = { ANTLR_UINT64_LIT(0x0000004000000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACKET_in_parameterList1305( FOLLOW_LBRACKET_in_parameterList1305_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_declList_in_parameterList1307_bits[]    = { ANTLR_UINT64_LIT(0x0000000080000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_declList_in_parameterList1307( FOLLOW_declList_in_parameterList1307_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACKET_in_parameterList1309_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACKET_in_parameterList1309( FOLLOW_RBRACKET_in_parameterList1309_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACKET_in_parameterList1326_bits[]    = { ANTLR_UINT64_LIT(0x0000000080000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACKET_in_parameterList1326( FOLLOW_LBRACKET_in_parameterList1326_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACKET_in_parameterList1328_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACKET_in_parameterList1328( FOLLOW_RBRACKET_in_parameterList1328_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_58_in_assign_op1364_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_58_in_assign_op1364( FOLLOW_58_in_assign_op1364_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_50_in_assign_op1378_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_50_in_assign_op1378( FOLLOW_50_in_assign_op1378_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_52_in_assign_op1391_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_52_in_assign_op1391( FOLLOW_52_in_assign_op1391_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_48_in_assign_op1404_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_48_in_assign_op1404( FOLLOW_48_in_assign_op1404_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_55_in_assign_op1417_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_55_in_assign_op1417( FOLLOW_55_in_assign_op1417_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_45_in_assign_op1430_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_45_in_assign_op1430( FOLLOW_45_in_assign_op1430_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_CHOWN_in_assign_op1443_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_CHOWN_in_assign_op1443( FOLLOW_CHOWN_in_assign_op1443_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_unary_ex_in_lvalue1481_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_unary_ex_in_lvalue1481( FOLLOW_unary_ex_in_lvalue1481_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_arglist1540_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000202) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_arglist1540( FOLLOW_expression_in_arglist1540_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_CHOWN_in_arglist1567_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_CHOWN_in_arglist1567( FOLLOW_CHOWN_in_arglist1567_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_arglist1571_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000202) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_arglist1571( FOLLOW_expression_in_arglist1571_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_COMMA_in_arglist1604_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923272) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_COMMA_in_arglist1604( FOLLOW_COMMA_in_arglist1604_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_CHOWN_in_arglist1647_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_CHOWN_in_arglist1647( FOLLOW_CHOWN_in_arglist1647_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_arglist1651_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000202) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_arglist1651( FOLLOW_expression_in_arglist1651_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_arglist1683_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000202) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_arglist1683( FOLLOW_expression_in_arglist1683_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_cond_ex_in_expression1767_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_cond_ex_in_expression1767( FOLLOW_cond_ex_in_expression1767_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_or_ex_in_cond_ex1813_bits[]    = { ANTLR_UINT64_LIT(0x4000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_or_ex_in_cond_ex1813( FOLLOW_or_ex_in_cond_ex1813_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_62_in_cond_ex1836_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_62_in_cond_ex1836( FOLLOW_62_in_cond_ex1836_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_cond_ex1840_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000100) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_cond_ex1840( FOLLOW_expression_in_cond_ex1840_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_COLON_in_cond_ex1842_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_COLON_in_cond_ex1842( FOLLOW_COLON_in_cond_ex1842_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_cond_ex_in_cond_ex1846_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_cond_ex_in_cond_ex1846( FOLLOW_cond_ex_in_cond_ex1846_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_and_ex_in_or_ex1901_bits[]    = { ANTLR_UINT64_LIT(0x8000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_and_ex_in_or_ex1901( FOLLOW_and_ex_in_or_ex1901_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_63_in_or_ex1918_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_63_in_or_ex1918( FOLLOW_63_in_or_ex1918_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_and_ex_in_or_ex1922_bits[]    = { ANTLR_UINT64_LIT(0x8000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_and_ex_in_or_ex1922( FOLLOW_and_ex_in_or_ex1922_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_eq_ex_in_and_ex1973_bits[]    = { ANTLR_UINT64_LIT(0x0000400000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_eq_ex_in_and_ex1973( FOLLOW_eq_ex_in_and_ex1973_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_46_in_and_ex1990_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_46_in_and_ex1990( FOLLOW_46_in_and_ex1990_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_eq_ex_in_and_ex1994_bits[]    = { ANTLR_UINT64_LIT(0x0000400000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_eq_ex_in_and_ex1994( FOLLOW_eq_ex_in_and_ex1994_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_rel_ex_in_eq_ex2029_bits[]    = { ANTLR_UINT64_LIT(0x0800080000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_rel_ex_in_eq_ex2029( FOLLOW_rel_ex_in_eq_ex2029_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_59_in_eq_ex2068_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_59_in_eq_ex2068( FOLLOW_59_in_eq_ex2068_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_rel_ex_in_eq_ex2072_bits[]    = { ANTLR_UINT64_LIT(0x0800080000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_rel_ex_in_eq_ex2072( FOLLOW_rel_ex_in_eq_ex2072_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_43_in_eq_ex2095_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_43_in_eq_ex2095( FOLLOW_43_in_eq_ex2095_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_rel_ex_in_eq_ex2099_bits[]    = { ANTLR_UINT64_LIT(0x0800080000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_rel_ex_in_eq_ex2099( FOLLOW_rel_ex_in_eq_ex2099_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_add_ex_in_rel_ex2169_bits[]    = { ANTLR_UINT64_LIT(0x3300000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_add_ex_in_rel_ex2169( FOLLOW_add_ex_in_rel_ex2169_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_56_in_rel_ex2205_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_56_in_rel_ex2205( FOLLOW_56_in_rel_ex2205_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_add_ex_in_rel_ex2209_bits[]    = { ANTLR_UINT64_LIT(0x3300000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_add_ex_in_rel_ex2209( FOLLOW_add_ex_in_rel_ex2209_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_60_in_rel_ex2233_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_60_in_rel_ex2233( FOLLOW_60_in_rel_ex2233_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_add_ex_in_rel_ex2237_bits[]    = { ANTLR_UINT64_LIT(0x3300000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_add_ex_in_rel_ex2237( FOLLOW_add_ex_in_rel_ex2237_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_57_in_rel_ex2261_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_57_in_rel_ex2261( FOLLOW_57_in_rel_ex2261_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_add_ex_in_rel_ex2265_bits[]    = { ANTLR_UINT64_LIT(0x3300000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_add_ex_in_rel_ex2265( FOLLOW_add_ex_in_rel_ex2265_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_61_in_rel_ex2289_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_61_in_rel_ex2289( FOLLOW_61_in_rel_ex2289_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_add_ex_in_rel_ex2293_bits[]    = { ANTLR_UINT64_LIT(0x3300000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_add_ex_in_rel_ex2293( FOLLOW_add_ex_in_rel_ex2293_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_mult_ex_in_add_ex2354_bits[]    = { ANTLR_UINT64_LIT(0x000A000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_mult_ex_in_add_ex2354( FOLLOW_mult_ex_in_add_ex2354_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_49_in_add_ex2390_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_49_in_add_ex2390( FOLLOW_49_in_add_ex2390_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_mult_ex_in_add_ex2394_bits[]    = { ANTLR_UINT64_LIT(0x000A000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_mult_ex_in_add_ex2394( FOLLOW_mult_ex_in_add_ex2394_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_51_in_add_ex2416_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_51_in_add_ex2416( FOLLOW_51_in_add_ex2416_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_mult_ex_in_add_ex2420_bits[]    = { ANTLR_UINT64_LIT(0x000A000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_mult_ex_in_add_ex2420( FOLLOW_mult_ex_in_add_ex2420_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_unary_ex_in_mult_ex2479_bits[]    = { ANTLR_UINT64_LIT(0x0040900000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_unary_ex_in_mult_ex2479( FOLLOW_unary_ex_in_mult_ex2479_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_47_in_mult_ex2518_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_47_in_mult_ex2518( FOLLOW_47_in_mult_ex2518_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_unary_ex_in_mult_ex2522_bits[]    = { ANTLR_UINT64_LIT(0x0040900000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_unary_ex_in_mult_ex2522( FOLLOW_unary_ex_in_mult_ex2522_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_54_in_mult_ex2548_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_54_in_mult_ex2548( FOLLOW_54_in_mult_ex2548_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_unary_ex_in_mult_ex2552_bits[]    = { ANTLR_UINT64_LIT(0x0040900000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_unary_ex_in_mult_ex2552( FOLLOW_unary_ex_in_mult_ex2552_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_44_in_mult_ex2578_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_44_in_mult_ex2578( FOLLOW_44_in_mult_ex2578_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_unary_ex_in_mult_ex2582_bits[]    = { ANTLR_UINT64_LIT(0x0040900000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_unary_ex_in_mult_ex2582( FOLLOW_unary_ex_in_mult_ex2582_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_post_ex_in_unary_ex2643_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_post_ex_in_unary_ex2643( FOLLOW_post_ex_in_unary_ex2643_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_DOUBINC_in_unary_ex2656_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_DOUBINC_in_unary_ex2656( FOLLOW_DOUBINC_in_unary_ex2656_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_unary_ex_in_unary_ex2660_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_unary_ex_in_unary_ex2660( FOLLOW_unary_ex_in_unary_ex2660_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_DOUBDEC_in_unary_ex2673_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_DOUBDEC_in_unary_ex2673( FOLLOW_DOUBDEC_in_unary_ex2673_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_unary_ex_in_unary_ex2677_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_unary_ex_in_unary_ex2677( FOLLOW_unary_ex_in_unary_ex2677_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_51_in_unary_ex2690_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_51_in_unary_ex2690( FOLLOW_51_in_unary_ex2690_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_unary_ex_in_unary_ex2694_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_unary_ex_in_unary_ex2694( FOLLOW_unary_ex_in_unary_ex2694_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LSQBRACKET_in_post_ex_proper2740_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LSQBRACKET_in_post_ex_proper2740( FOLLOW_LSQBRACKET_in_post_ex_proper2740_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_post_ex_proper2744_bits[]    = { ANTLR_UINT64_LIT(0x0000000400000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_post_ex_proper2744( FOLLOW_expression_in_post_ex_proper2744_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RSQBRACKET_in_post_ex_proper2748_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RSQBRACKET_in_post_ex_proper2748( FOLLOW_RSQBRACKET_in_post_ex_proper2748_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACKET_in_post_ex_proper2763_bits[]    = { ANTLR_UINT64_LIT(0x0000000080000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACKET_in_post_ex_proper2763( FOLLOW_LBRACKET_in_post_ex_proper2763_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACKET_in_post_ex_proper2767_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACKET_in_post_ex_proper2767( FOLLOW_RBRACKET_in_post_ex_proper2767_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACKET_in_post_ex_proper2795_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923070) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACKET_in_post_ex_proper2795( FOLLOW_LBRACKET_in_post_ex_proper2795_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_arglist_in_post_ex_proper2801_bits[]    = { ANTLR_UINT64_LIT(0x0000000080000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_arglist_in_post_ex_proper2801( FOLLOW_arglist_in_post_ex_proper2801_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACKET_in_post_ex_proper2805_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACKET_in_post_ex_proper2805( FOLLOW_RBRACKET_in_post_ex_proper2805_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_53_in_post_ex_proper2818_bits[]    = { ANTLR_UINT64_LIT(0x0000000000100000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_53_in_post_ex_proper2818( FOLLOW_53_in_post_ex_proper2818_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_ID_in_post_ex_proper2822_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_ID_in_post_ex_proper2822( FOLLOW_ID_in_post_ex_proper2822_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_DOUBINC_in_post_ex_proper2849_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_DOUBINC_in_post_ex_proper2849( FOLLOW_DOUBINC_in_post_ex_proper2849_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_DOUBDEC_in_post_ex_proper2878_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_DOUBDEC_in_post_ex_proper2878( FOLLOW_DOUBDEC_in_post_ex_proper2878_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_prim_ex_in_post_ex2935_bits[]    = { ANTLR_UINT64_LIT(0x0020000006003002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_prim_ex_in_post_ex2935( FOLLOW_prim_ex_in_post_ex2935_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_post_ex_proper_in_post_ex2954_bits[]    = { ANTLR_UINT64_LIT(0x0020000006003002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_post_ex_proper_in_post_ex2954( FOLLOW_post_ex_proper_in_post_ex2954_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_lvalue_in_assignment2983_bits[]    = { ANTLR_UINT64_LIT(0x0495200000000042) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_lvalue_in_assignment2983( FOLLOW_lvalue_in_assignment2983_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_assign_op_in_assignment2996_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_assign_op_in_assignment2996( FOLLOW_assign_op_in_assignment2996_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_assignment2998_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_assignment2998( FOLLOW_expression_in_assignment2998_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_INT_in_constant3031_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_INT_in_constant3031( FOLLOW_INT_in_constant3031_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_FLOAT_in_constant3047_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_FLOAT_in_constant3047( FOLLOW_FLOAT_in_constant3047_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_CHAR_in_constant3061_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_CHAR_in_constant3061( FOLLOW_CHAR_in_constant3061_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_STRING_in_constant3076_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_STRING_in_constant3076( FOLLOW_STRING_in_constant3076_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_BOOL_in_constant3088_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_BOOL_in_constant3088( FOLLOW_BOOL_in_constant3088_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_ID_in_prim_ex3120_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_ID_in_prim_ex3120( FOLLOW_ID_in_prim_ex3120_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACKET_in_prim_ex3135_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACKET_in_prim_ex3135( FOLLOW_LBRACKET_in_prim_ex3135_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_prim_ex3139_bits[]    = { ANTLR_UINT64_LIT(0x0000000080000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_prim_ex3139( FOLLOW_expression_in_prim_ex3139_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACKET_in_prim_ex3143_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACKET_in_prim_ex3143( FOLLOW_RBRACKET_in_prim_ex3143_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_constant_in_prim_ex3158_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_constant_in_prim_ex3158( FOLLOW_constant_in_prim_ex3158_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_scalarType_in_prim_ex3173_bits[]    = { ANTLR_UINT64_LIT(0x0000000006000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_scalarType_in_prim_ex3173( FOLLOW_scalarType_in_prim_ex3173_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_structInit_in_prim_ex3206_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_structInit_in_prim_ex3206( FOLLOW_structInit_in_prim_ex3206_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_arrayInit_in_prim_ex3230_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_arrayInit_in_prim_ex3230( FOLLOW_arrayInit_in_prim_ex3230_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_NULLTOK_in_prim_ex3259_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_NULLTOK_in_prim_ex3259( FOLLOW_NULLTOK_in_prim_ex3259_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACKET_in_structInit3284_bits[]    = { ANTLR_UINT64_LIT(0x0000000080000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACKET_in_structInit3284( FOLLOW_LBRACKET_in_structInit3284_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACKET_in_structInit3288_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACKET_in_structInit3288( FOLLOW_RBRACKET_in_structInit3288_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACKET_in_structInit3300_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACKET_in_structInit3300( FOLLOW_LBRACKET_in_structInit3300_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_structInit3304_bits[]    = { ANTLR_UINT64_LIT(0x0000000080000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_structInit3304( FOLLOW_expression_in_structInit3304_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACKET_in_structInit3308_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACKET_in_structInit3308( FOLLOW_RBRACKET_in_structInit3308_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LSQBRACKET_in_arrayInit3370_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LSQBRACKET_in_arrayInit3370( FOLLOW_LSQBRACKET_in_arrayInit3370_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_arrayInit3374_bits[]    = { ANTLR_UINT64_LIT(0x0000000400000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_arrayInit3374( FOLLOW_expression_in_arrayInit3374_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RSQBRACKET_in_arrayInit3376_bits[]    = { ANTLR_UINT64_LIT(0x0000000006000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RSQBRACKET_in_arrayInit3376( FOLLOW_RSQBRACKET_in_arrayInit3376_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LSQBRACKET_in_arrayInit3400_bits[]    = { ANTLR_UINT64_LIT(0x0000000400000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LSQBRACKET_in_arrayInit3400( FOLLOW_LSQBRACKET_in_arrayInit3400_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RSQBRACKET_in_arrayInit3402_bits[]    = { ANTLR_UINT64_LIT(0x0000000006000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RSQBRACKET_in_arrayInit3402( FOLLOW_RSQBRACKET_in_arrayInit3402_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LSQBRACKET_in_arrayInit3440_bits[]    = { ANTLR_UINT64_LIT(0x0000000400000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LSQBRACKET_in_arrayInit3440( FOLLOW_LSQBRACKET_in_arrayInit3440_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RSQBRACKET_in_arrayInit3442_bits[]    = { ANTLR_UINT64_LIT(0x0000000006000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RSQBRACKET_in_arrayInit3442( FOLLOW_RSQBRACKET_in_arrayInit3442_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACKET_in_arrayInit3486_bits[]    = { ANTLR_UINT64_LIT(0x0000000080000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACKET_in_arrayInit3486( FOLLOW_LBRACKET_in_arrayInit3486_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACKET_in_arrayInit3490_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACKET_in_arrayInit3490( FOLLOW_RBRACKET_in_arrayInit3490_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACKET_in_arrayInit3524_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACKET_in_arrayInit3524( FOLLOW_LBRACKET_in_arrayInit3524_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_arrayInit3528_bits[]    = { ANTLR_UINT64_LIT(0x0000000080000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_arrayInit3528( FOLLOW_expression_in_arrayInit3528_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACKET_in_arrayInit3532_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACKET_in_arrayInit3532( FOLLOW_RBRACKET_in_arrayInit3532_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_decl_in_declaration3577_bits[]    = { ANTLR_UINT64_LIT(0x0400000000000040) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_decl_in_declaration3577( FOLLOW_decl_in_declaration3577_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_58_in_declaration3612_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_58_in_declaration3612( FOLLOW_58_in_declaration3612_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_declaration3619_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_declaration3619( FOLLOW_expression_in_declaration3619_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_CHOWN_in_declaration3645_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_CHOWN_in_declaration3645( FOLLOW_CHOWN_in_declaration3645_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_declaration3652_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_declaration3652( FOLLOW_expression_in_declaration3652_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_declaration_in_instructionScalar3702_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_declaration_in_instructionScalar3702( FOLLOW_declaration_in_instructionScalar3702_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_assignment_in_instructionScalar3715_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_assignment_in_instructionScalar3715( FOLLOW_assignment_in_instructionScalar3715_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RETURN_in_returnInst3747_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RETURN_in_returnInst3747( FOLLOW_RETURN_in_returnInst3747_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_returnInst3749_bits[]    = { ANTLR_UINT64_LIT(0x0000000800000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_returnInst3749( FOLLOW_expression_in_returnInst3749_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_SEMICOLON_in_returnInst3753_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_returnInst3753( FOLLOW_SEMICOLON_in_returnInst3753_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RETURN_in_returnInst3767_bits[]    = { ANTLR_UINT64_LIT(0x0000000800000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RETURN_in_returnInst3767( FOLLOW_RETURN_in_returnInst3767_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_SEMICOLON_in_returnInst3771_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_returnInst3771( FOLLOW_SEMICOLON_in_returnInst3771_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RETURN_OWN_in_returnInst3785_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RETURN_OWN_in_returnInst3785( FOLLOW_RETURN_OWN_in_returnInst3785_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_returnInst3787_bits[]    = { ANTLR_UINT64_LIT(0x0000000800000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_returnInst3787( FOLLOW_expression_in_returnInst3787_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_SEMICOLON_in_returnInst3791_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_returnInst3791( FOLLOW_SEMICOLON_in_returnInst3791_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_WHILE_in_whileInst3841_bits[]    = { ANTLR_UINT64_LIT(0x0000000002000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_WHILE_in_whileInst3841( FOLLOW_WHILE_in_whileInst3841_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACKET_in_whileInst3843_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACKET_in_whileInst3843( FOLLOW_LBRACKET_in_whileInst3843_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_whileInst3845_bits[]    = { ANTLR_UINT64_LIT(0x0000000080000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_whileInst3845( FOLLOW_expression_in_whileInst3845_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACKET_in_whileInst3847_bits[]    = { ANTLR_UINT64_LIT(0x0000000001000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACKET_in_whileInst3847( FOLLOW_RBRACKET_in_whileInst3847_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_body_in_whileInst3849_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_body_in_whileInst3849( FOLLOW_body_in_whileInst3849_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_DO_in_doInst3885_bits[]    = { ANTLR_UINT64_LIT(0x0000000001000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_DO_in_doInst3885( FOLLOW_DO_in_doInst3885_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_body_in_doInst3887_bits[]    = { ANTLR_UINT64_LIT(0x0000020000000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_body_in_doInst3887( FOLLOW_body_in_doInst3887_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_WHILE_in_doInst3889_bits[]    = { ANTLR_UINT64_LIT(0x0000000002000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_WHILE_in_doInst3889( FOLLOW_WHILE_in_doInst3889_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACKET_in_doInst3891_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACKET_in_doInst3891( FOLLOW_LBRACKET_in_doInst3891_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_doInst3893_bits[]    = { ANTLR_UINT64_LIT(0x0000000080000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_doInst3893( FOLLOW_expression_in_doInst3893_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACKET_in_doInst3895_bits[]    = { ANTLR_UINT64_LIT(0x0000000800000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACKET_in_doInst3895( FOLLOW_RBRACKET_in_doInst3895_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_SEMICOLON_in_doInst3897_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_doInst3897( FOLLOW_SEMICOLON_in_doInst3897_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_FOR_in_forInst3929_bits[]    = { ANTLR_UINT64_LIT(0x0000000002000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_FOR_in_forInst3929( FOLLOW_FOR_in_forInst3929_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACKET_in_forInst3931_bits[]    = { ANTLR_UINT64_LIT(0x000800580A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACKET_in_forInst3931( FOLLOW_LBRACKET_in_forInst3931_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_instructionScalar_in_forInst3959_bits[]    = { ANTLR_UINT64_LIT(0x0000000800000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_instructionScalar_in_forInst3959( FOLLOW_instructionScalar_in_forInst3959_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_SEMICOLON_in_forInst3965_bits[]    = { ANTLR_UINT64_LIT(0x000800580A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_forInst3965( FOLLOW_SEMICOLON_in_forInst3965_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_forInst3990_bits[]    = { ANTLR_UINT64_LIT(0x0000000800000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_forInst3990( FOLLOW_expression_in_forInst3990_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_SEMICOLON_in_forInst4004_bits[]    = { ANTLR_UINT64_LIT(0x000800508A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_forInst4004( FOLLOW_SEMICOLON_in_forInst4004_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_instructionScalar_in_forInst4030_bits[]    = { ANTLR_UINT64_LIT(0x0000000080000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_instructionScalar_in_forInst4030( FOLLOW_instructionScalar_in_forInst4030_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACKET_in_forInst4036_bits[]    = { ANTLR_UINT64_LIT(0x0000000001000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACKET_in_forInst4036( FOLLOW_RBRACKET_in_forInst4036_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_body_in_forInst4062_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_body_in_forInst4062( FOLLOW_body_in_forInst4062_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_ELSE_in_elsemiddle4119_bits[]    = { ANTLR_UINT64_LIT(0x0000000000200000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_ELSE_in_elsemiddle4119( FOLLOW_ELSE_in_elsemiddle4119_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_IF_in_elsemiddle4121_bits[]    = { ANTLR_UINT64_LIT(0x0000000002000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_IF_in_elsemiddle4121( FOLLOW_IF_in_elsemiddle4121_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACKET_in_elsemiddle4123_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACKET_in_elsemiddle4123( FOLLOW_LBRACKET_in_elsemiddle4123_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_elsemiddle4125_bits[]    = { ANTLR_UINT64_LIT(0x0000000080000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_elsemiddle4125( FOLLOW_expression_in_elsemiddle4125_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACKET_in_elsemiddle4127_bits[]    = { ANTLR_UINT64_LIT(0x0000000001000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACKET_in_elsemiddle4127( FOLLOW_RBRACKET_in_elsemiddle4127_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_body_in_elsemiddle4129_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_body_in_elsemiddle4129( FOLLOW_body_in_elsemiddle4129_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_ELSE_in_endif4168_bits[]    = { ANTLR_UINT64_LIT(0x0000000001000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_ELSE_in_endif4168( FOLLOW_ELSE_in_endif4168_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_body_in_endif4170_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_body_in_endif4170( FOLLOW_body_in_endif4170_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_IF_in_ifInst4204_bits[]    = { ANTLR_UINT64_LIT(0x0000000002000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_IF_in_ifInst4204( FOLLOW_IF_in_ifInst4204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACKET_in_ifInst4206_bits[]    = { ANTLR_UINT64_LIT(0x000800500A923030) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACKET_in_ifInst4206( FOLLOW_LBRACKET_in_ifInst4206_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_expression_in_ifInst4208_bits[]    = { ANTLR_UINT64_LIT(0x0000000080000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_expression_in_ifInst4208( FOLLOW_expression_in_ifInst4208_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACKET_in_ifInst4210_bits[]    = { ANTLR_UINT64_LIT(0x0000000001000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACKET_in_ifInst4210( FOLLOW_RBRACKET_in_ifInst4210_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_body_in_ifInst4212_bits[]    = { ANTLR_UINT64_LIT(0x0000000000004002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_body_in_ifInst4212( FOLLOW_body_in_ifInst4212_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_elsemiddle_in_ifInst4230_bits[]    = { ANTLR_UINT64_LIT(0x0000000000004002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_elsemiddle_in_ifInst4230( FOLLOW_elsemiddle_in_ifInst4230_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_endif_in_ifInst4251_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_endif_in_ifInst4251( FOLLOW_endif_in_ifInst4251_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_ifInst_in_instruction4285_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_ifInst_in_instruction4285( FOLLOW_ifInst_in_instruction4285_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_whileInst_in_instruction4306_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_whileInst_in_instruction4306( FOLLOW_whileInst_in_instruction4306_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_doInst_in_instruction4323_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_doInst_in_instruction4323( FOLLOW_doInst_in_instruction4323_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_forInst_in_instruction4343_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_forInst_in_instruction4343( FOLLOW_forInst_in_instruction4343_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_instructionScalar_in_instruction4363_bits[]    = { ANTLR_UINT64_LIT(0x0000000800000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_instructionScalar_in_instruction4363( FOLLOW_instructionScalar_in_instruction4363_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_SEMICOLON_in_instruction4365_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_instruction4365( FOLLOW_SEMICOLON_in_instruction4365_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_returnInst_in_instruction4378_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_returnInst_in_instruction4378( FOLLOW_returnInst_in_instruction4378_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_instruction_in_instructionList4414_bits[]    = { ANTLR_UINT64_LIT(0x000802530AB63832) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_instruction_in_instructionList4414( FOLLOW_instruction_in_instructionList4414_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_instruction_in_instructionList4430_bits[]    = { ANTLR_UINT64_LIT(0x000802530AB63832) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_instruction_in_instructionList4430( FOLLOW_instruction_in_instructionList4430_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACE_in_body4464_bits[]    = { ANTLR_UINT64_LIT(0x0000000040000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACE_in_body4464( FOLLOW_LBRACE_in_body4464_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACE_in_body4468_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACE_in_body4468( FOLLOW_RBRACE_in_body4468_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACE_in_body4483_bits[]    = { ANTLR_UINT64_LIT(0x000802530AB63830) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACE_in_body4483( FOLLOW_LBRACE_in_body4483_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_instructionList_in_body4485_bits[]    = { ANTLR_UINT64_LIT(0x0000000040000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_instructionList_in_body4485( FOLLOW_instructionList_in_body4485_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACE_in_body4489_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACE_in_body4489( FOLLOW_RBRACE_in_body4489_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_decl_in_function4519_bits[]    = { ANTLR_UINT64_LIT(0x0000000002000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_decl_in_function4519( FOLLOW_decl_in_function4519_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_parameterList_in_function4521_bits[]    = { ANTLR_UINT64_LIT(0x0000000001000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_parameterList_in_function4521( FOLLOW_parameterList_in_function4521_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_body_in_function4523_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_body_in_function4523( FOLLOW_body_in_function4523_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_STRUCT_in_structDecl4552_bits[]    = { ANTLR_UINT64_LIT(0x0000004000000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_STRUCT_in_structDecl4552( FOLLOW_STRUCT_in_structDecl4552_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_TYPE_in_structDecl4554_bits[]    = { ANTLR_UINT64_LIT(0x0000000001000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_TYPE_in_structDecl4554( FOLLOW_TYPE_in_structDecl4554_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACE_in_structDecl4570_bits[]    = { ANTLR_UINT64_LIT(0x0000004040000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACE_in_structDecl4570( FOLLOW_LBRACE_in_structDecl4570_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_declaration_in_structDecl4575_bits[]    = { ANTLR_UINT64_LIT(0x0000000800000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_declaration_in_structDecl4575( FOLLOW_declaration_in_structDecl4575_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_SEMICOLON_in_structDecl4579_bits[]    = { ANTLR_UINT64_LIT(0x0000004040000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_structDecl4579( FOLLOW_SEMICOLON_in_structDecl4579_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACE_in_structDecl4584_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACE_in_structDecl4584( FOLLOW_RBRACE_in_structDecl4584_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_CLASS_in_classDecl4637_bits[]    = { ANTLR_UINT64_LIT(0x0000004000000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_CLASS_in_classDecl4637( FOLLOW_CLASS_in_classDecl4637_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_TYPE_in_classDecl4641_bits[]    = { ANTLR_UINT64_LIT(0x0000000001000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_TYPE_in_classDecl4641( FOLLOW_TYPE_in_classDecl4641_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_CLASS_in_classDecl4661_bits[]    = { ANTLR_UINT64_LIT(0x0000004000000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_CLASS_in_classDecl4661( FOLLOW_CLASS_in_classDecl4661_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_TYPE_in_classDecl4665_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000100) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_TYPE_in_classDecl4665( FOLLOW_TYPE_in_classDecl4665_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_COLON_in_classDecl4667_bits[]    = { ANTLR_UINT64_LIT(0x0000004000000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_COLON_in_classDecl4667( FOLLOW_COLON_in_classDecl4667_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_TYPE_in_classDecl4671_bits[]    = { ANTLR_UINT64_LIT(0x0000000001000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_TYPE_in_classDecl4671( FOLLOW_TYPE_in_classDecl4671_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_LBRACE_in_classDecl4698_bits[]    = { ANTLR_UINT64_LIT(0x0000014060000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_LBRACE_in_classDecl4698( FOLLOW_LBRACE_in_classDecl4698_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_declaration_in_classDecl4742_bits[]    = { ANTLR_UINT64_LIT(0x0000000800000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_declaration_in_classDecl4742( FOLLOW_declaration_in_classDecl4742_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_SEMICOLON_in_classDecl4746_bits[]    = { ANTLR_UINT64_LIT(0x0000014060000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_classDecl4746( FOLLOW_SEMICOLON_in_classDecl4746_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_function_in_classDecl4772_bits[]    = { ANTLR_UINT64_LIT(0x0000014060000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_function_in_classDecl4772( FOLLOW_function_in_classDecl4772_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_VIRTUAL_in_classDecl4801_bits[]    = { ANTLR_UINT64_LIT(0x0000004000000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_VIRTUAL_in_classDecl4801( FOLLOW_VIRTUAL_in_classDecl4801_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_function_in_classDecl4805_bits[]    = { ANTLR_UINT64_LIT(0x0000014060000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_function_in_classDecl4805( FOLLOW_function_in_classDecl4805_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_OVERRIDE_in_classDecl4831_bits[]    = { ANTLR_UINT64_LIT(0x0000004000000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_OVERRIDE_in_classDecl4831( FOLLOW_OVERRIDE_in_classDecl4831_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_function_in_classDecl4835_bits[]    = { ANTLR_UINT64_LIT(0x0000014060000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_function_in_classDecl4835( FOLLOW_function_in_classDecl4835_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_RBRACE_in_classDecl4872_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_RBRACE_in_classDecl4872( FOLLOW_RBRACE_in_classDecl4872_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_INCLUDE_in_inc4897_bits[]    = { ANTLR_UINT64_LIT(0x0000001000000000) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_INCLUDE_in_inc4897( FOLLOW_INCLUDE_in_inc4897_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_STRING_in_inc4899_bits[]    = { ANTLR_UINT64_LIT(0x0000000000000002) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_STRING_in_inc4899( FOLLOW_STRING_in_inc4899_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_function_in_program4945_bits[]    = { ANTLR_UINT64_LIT(0x0000006000400082) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_function_in_program4945( FOLLOW_function_in_program4945_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_structDecl_in_program4967_bits[]    = { ANTLR_UINT64_LIT(0x0000006000400082) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_structDecl_in_program4967( FOLLOW_structDecl_in_program4967_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_classDecl_in_program4987_bits[]    = { ANTLR_UINT64_LIT(0x0000006000400082) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_classDecl_in_program4987( FOLLOW_classDecl_in_program4987_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: WNScriptASTParser  */
static    ANTLR_BITWORD FOLLOW_inc_in_program5008_bits[]    = { ANTLR_UINT64_LIT(0x0000006000400082) };
static  WNScriptASTParserImplTraits::BitsetListType FOLLOW_inc_in_program5008( FOLLOW_inc_in_program5008_bits, 1 );



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    498:1: instructionScalar returns [WNInstruction* node] : ( declaration | assignment );
 */
static const ANTLR_INT32 dfa29_eot[7] =
    {
    -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa29_eof[7] =
    {
    -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa29_min[7] =
    {
    4, 20, -1, 4, -1, 20, 34
    };
static const ANTLR_INT32 dfa29_max[7] =
    {
    51, 26, -1, 51, -1, 26, 34
    };
static const ANTLR_INT32 dfa29_accept[7] =
    {
    -1, -1, 2, -1, 1, -1, -1
    };
static const ANTLR_INT32 dfa29_special[7] =
    {
    -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa29_T_empty     =   NULL;

static const ANTLR_INT32 dfa29_T0[] =
    {
    2, 2, -1, -1, -1, -1, -1, -1, 2, 2, -1, -1, -1, 2, -1, -1, 2, -1, -1, 2,
    -1, 2, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa29_T1[] =
    {
    4, -1, -1, -1, -1, 2, 3
    };

static const ANTLR_INT32 dfa29_T2[] =
    {
    4, -1, -1, -1, -1, 2, 6
    };

static const ANTLR_INT32 dfa29_T3[] =
    {
    2, 2, -1, -1, -1, -1, -1, -1, 2, 2, -1, -1, -1, 2, -1, -1, 2, -1, -1, 2,
    -1, 2, -1, 2, -1, -1, -1, -1, -1, -1, 5, -1, 2, -1, 2, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa29_T4[] =
    {
    5
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa29_transitions[] =
{
    dfa29_T0, dfa29_T1, NULL, dfa29_T3, NULL, dfa29_T2, dfa29_T4
};


/* Declare tracking structure for Cyclic DFA 29
 */
class WNScriptASTParserCyclicDFA29 : public CyclicDFA< WNScriptASTParserImplTraits, WNScriptASTParser >, public WNScriptASTParserTokens
{
public:
    typedef CyclicDFA< WNScriptASTParserImplTraits, WNScriptASTParser >  BaseType;
    typedef BaseType::ContextType CtxType;

private:


public:
    WNScriptASTParserCyclicDFA29( ANTLR_INT32    decisionNumber
                    , const ANTLR_UCHAR*    description
                    , const ANTLR_INT32* const    eot
                    , const ANTLR_INT32* const    eof
                    , const ANTLR_INT32* const    min
                    , const ANTLR_INT32* const    max
                    , const ANTLR_INT32* const    accept
                    , const ANTLR_INT32* const    special
                    , const ANTLR_INT32* const *const    transition)
                    :BaseType( decisionNumber, description, eot, eof, min, max, accept,
                                special, transition )
    {

    }

};

static WNScriptASTParserCyclicDFA29  cdfa29(
        29,            /* Decision number of this dfa        */
        /* Which decision this represents:   */
        (const ANTLR_UCHAR*)"498:1: instructionScalar returns [WNInstruction* node] : ( declaration | assignment );",
        dfa29_eot,        /* EOT table                */
        dfa29_eof,        /* EOF table                */
        dfa29_min,        /* Minimum tokens for each state    */
        dfa29_max,        /* Maximum tokens for each state    */
        dfa29_accept,    /* Accept table                */
        dfa29_special,    /* Special transition states        */
        dfa29_transitions    /* Table of transition tables        */

    );


/* End of Cyclic DFA 29
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 608:17: ( (a= declaration SEMICOLON ) | (b= function ) | ( VIRTUAL h= function ) | ( OVERRIDE i= function ) )*
 */
static const ANTLR_INT32 dfa41_eot[10] =
    {
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa41_eof[10] =
    {
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa41_min[10] =
    {
    29, -1, 20, -1, -1, 34, 6, 20, -1, -1
    };
static const ANTLR_INT32 dfa41_max[10] =
    {
    40, -1, 26, -1, -1, 34, 58, 26, -1, -1
    };
static const ANTLR_INT32 dfa41_accept[10] =
    {
    -1, 5, -1, 3, 4, -1, -1, -1, 1, 2
    };
static const ANTLR_INT32 dfa41_special[10] =
    {
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa41_T_empty     =   NULL;

static const ANTLR_INT32 dfa41_T0[] =
    {
    7
    };

static const ANTLR_INT32 dfa41_T1[] =
    {
    6, -1, -1, -1, -1, -1, 5
    };

static const ANTLR_INT32 dfa41_T2[] =
    {
    8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8
    };

static const ANTLR_INT32 dfa41_T3[] =
    {
    4, 1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 3
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa41_transitions[] =
{
    dfa41_T3, NULL, dfa41_T1, NULL, NULL, dfa41_T0, dfa41_T2, dfa41_T1,
    NULL, NULL
};


/* Declare tracking structure for Cyclic DFA 41
 */
class WNScriptASTParserCyclicDFA41 : public CyclicDFA< WNScriptASTParserImplTraits, WNScriptASTParser >, public WNScriptASTParserTokens
{
public:
    typedef CyclicDFA< WNScriptASTParserImplTraits, WNScriptASTParser >  BaseType;
    typedef BaseType::ContextType CtxType;

private:


public:
    WNScriptASTParserCyclicDFA41( ANTLR_INT32    decisionNumber
                    , const ANTLR_UCHAR*    description
                    , const ANTLR_INT32* const    eot
                    , const ANTLR_INT32* const    eof
                    , const ANTLR_INT32* const    min
                    , const ANTLR_INT32* const    max
                    , const ANTLR_INT32* const    accept
                    , const ANTLR_INT32* const    special
                    , const ANTLR_INT32* const *const    transition)
                    :BaseType( decisionNumber, description, eot, eof, min, max, accept,
                                special, transition )
    {

    }

};

static WNScriptASTParserCyclicDFA41  cdfa41(
        41,            /* Decision number of this dfa        */
        /* Which decision this represents:   */
        (const ANTLR_UCHAR*)"()* loopback of 608:17: ( (a= declaration SEMICOLON ) | (b= function ) | ( VIRTUAL h= function ) | ( OVERRIDE i= function ) )*",
        dfa41_eot,        /* EOT table                */
        dfa41_eof,        /* EOF table                */
        dfa41_min,        /* Minimum tokens for each state    */
        dfa41_max,        /* Maximum tokens for each state    */
        dfa41_accept,    /* Accept table                */
        dfa41_special,    /* Special transition states        */
        dfa41_transitions    /* Table of transition tables        */

    );


/* End of Cyclic DFA 41
 * ---------------------
 */
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start scalarType
 * WNScriptAST.g:247:1: scalarType returns [WNTypeNode* node] : TYPE ;
 */
WNTypeNode*
WNScriptASTParser::scalarType()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNTypeNode* node;


    const CommonTokenType*    TYPE1;

    /* Initialize rule variables
     */


        node = wn_nullptr;

    TYPE1       = NULL;



    {
        // WNScriptAST.g:251:5: ( TYPE )
        // WNScriptAST.g:251:9: TYPE
        {
            TYPE1 =  this->matchToken(TYPE, &FOLLOW_TYPE_in_scalarType1128);
            if  (this->hasException())
            {
                goto rulescalarTypeEx;
            }


            {
                 node = WN_SCRIPTNODE_NEW(WNTypeNode((TYPE1->getText()).c_str())); SetLocation(node, TYPE1);
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulescalarTypeEx; /* Prevent compiler warnings */
    rulescalarTypeEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end scalarType */

/**
 * $ANTLR start type
 * WNScriptAST.g:254:1: type returns [WNTypeNode* node] : scalarType ( LSQBRACKET RSQBRACKET )* ;
 */
WNTypeNode*
WNScriptASTParser::type()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNTypeNode* node;


    const CommonTokenType*    RSQBRACKET3;
    WNTypeNode* scalarType2;
    typedef    WNTypeNode* RETURN_TYPE_scalarType2;

    /* Initialize rule variables
     */


        node = wn_nullptr;

    RSQBRACKET3       = NULL;



    {
        // WNScriptAST.g:258:5: ( scalarType ( LSQBRACKET RSQBRACKET )* )
        // WNScriptAST.g:258:10: scalarType ( LSQBRACKET RSQBRACKET )*
        {
            this->followPush(FOLLOW_scalarType_in_type1167);
            scalarType2=scalarType();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletypeEx;
            }


            {
                 node = scalarType2
                ; SetLocationFromNode(node, scalarType2
                );
            }


            // WNScriptAST.g:259:17: ( LSQBRACKET RSQBRACKET )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case LSQBRACKET:
                    {
                        alt1=1;
                    }
                    break;

                }

                switch (alt1)
                {
                case 1:
                    // WNScriptAST.g:259:18: LSQBRACKET RSQBRACKET
                    {
                         this->matchToken(LSQBRACKET, &FOLLOW_LSQBRACKET_in_type1188);
                        if  (this->hasException())
                        {
                            goto ruletypeEx;
                        }


                        RSQBRACKET3 =  this->matchToken(RSQBRACKET, &FOLLOW_RSQBRACKET_in_type1190);
                        if  (this->hasException())
                        {
                            goto ruletypeEx;
                        }


                        {
                             node->AddArrayLevel(); SetEndLocation(node, RSQBRACKET3);
                        }


                    }
                    break;

                default:
                    goto loop1;    /* break out of the loop */
                    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletypeEx; /* Prevent compiler warnings */
    ruletypeEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end type */

/**
 * $ANTLR start decl
 * WNScriptAST.g:262:1: decl returns [WNDeclaration* node] : type ID ;
 */
WNDeclaration*
WNScriptASTParser::decl()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNDeclaration* node;


    const CommonTokenType*    ID5;
    WNTypeNode* type4;
    typedef    WNTypeNode* RETURN_TYPE_type4;

    /* Initialize rule variables
     */


        node = wn_nullptr;

    ID5       = NULL;



    {
        // WNScriptAST.g:266:5: ( type ID )
        // WNScriptAST.g:266:10: type ID
        {
            this->followPush(FOLLOW_type_in_decl1222);
            type4=type();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledeclEx;
            }


            ID5 =  this->matchToken(ID, &FOLLOW_ID_in_decl1224);
            if  (this->hasException())
            {
                goto ruledeclEx;
            }


            {
                node = WN_SCRIPTNODE_NEW(WNDeclaration(type4
                , (ID5->getText()).c_str())); SetLocationFromNode(node,
                type4
                ); SetEndLocation(node, ID5);
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledeclEx; /* Prevent compiler warnings */
    ruledeclEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end decl */

/**
 * $ANTLR start declList
 * WNScriptAST.g:269:1: declList returns [WNDeclList* node] : a= decl ( COMMA b= decl )* ;
 */
WNDeclList*
WNScriptASTParser::declList()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNDeclList* node;


    WNDeclaration* a;
    typedef    WNDeclaration* RETURN_TYPE_a;

    WNDeclaration* b;
    typedef    WNDeclaration* RETURN_TYPE_b;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        // WNScriptAST.g:273:5: (a= decl ( COMMA b= decl )* )
        // WNScriptAST.g:273:10: a= decl ( COMMA b= decl )*
        {
            this->followPush(FOLLOW_decl_in_declList1256);
            a=decl();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledeclListEx;
            }


            {
                 node = WN_SCRIPTNODE_NEW(WNDeclList(a
                )); SetLocationFromNode(node, a
                );
            }


            // WNScriptAST.g:274:9: ( COMMA b= decl )*

            for (;;)
            {
                int alt2=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                    {
                        alt2=1;
                    }
                    break;

                }

                switch (alt2)
                {
                case 1:
                    // WNScriptAST.g:274:10: COMMA b= decl
                    {
                         this->matchToken(COMMA, &FOLLOW_COMMA_in_declList1269);
                        if  (this->hasException())
                        {
                            goto ruledeclListEx;
                        }


                        this->followPush(FOLLOW_decl_in_declList1273);
                        b=decl();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruledeclListEx;
                        }


                        {
                             node
                            ->AddDeclaration(b
                            ); SetEndLocationFromNode(node, b
                            );
                        }


                    }
                    break;

                default:
                    goto loop2;    /* break out of the loop */
                    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledeclListEx; /* Prevent compiler warnings */
    ruledeclListEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end declList */

/**
 * $ANTLR start parameterList
 * WNScriptAST.g:277:1: parameterList returns [WNDeclList* node] : ( LBRACKET declList RBRACKET | LBRACKET RBRACKET );
 */
WNDeclList*
WNScriptASTParser::parameterList()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNDeclList* node;


    const CommonTokenType*    LBRACKET7;
    const CommonTokenType*    RBRACKET8;
    WNDeclList* declList6;
    typedef    WNDeclList* RETURN_TYPE_declList6;

    /* Initialize rule variables
     */


        node = wn_nullptr;

    LBRACKET7       = NULL;
    RBRACKET8       = NULL;



    {
        {
            //  WNScriptAST.g:281:5: ( LBRACKET declList RBRACKET | LBRACKET RBRACKET )

            ANTLR_UINT32 alt3;

            alt3=2;

            switch ( this->LA(1) )
            {
            case LBRACKET:
                {
                    switch ( this->LA(2) )
                    {
                    case RBRACKET:
                        {
                            alt3=2;
                        }
                        break;
                    case TYPE:
                        {
                            alt3=1;
                        }
                        break;

                    default:
                        ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 3 );
                        ex->set_state( 1 );


                        goto ruleparameterListEx;

                    }

                }
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 3 );
                ex->set_state( 0 );


                goto ruleparameterListEx;

            }

            switch (alt3)
            {
            case 1:
                // WNScriptAST.g:281:10: LBRACKET declList RBRACKET
                {
                    LBRACKET7 =  this->matchToken(LBRACKET, &FOLLOW_LBRACKET_in_parameterList1305);
                    if  (this->hasException())
                    {
                        goto ruleparameterListEx;
                    }


                    this->followPush(FOLLOW_declList_in_parameterList1307);
                    declList6=declList();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleparameterListEx;
                    }


                    RBRACKET8 =  this->matchToken(RBRACKET, &FOLLOW_RBRACKET_in_parameterList1309);
                    if  (this->hasException())
                    {
                        goto ruleparameterListEx;
                    }


                    {
                         node = declList6
                        ; SetLocation(node, LBRACKET7); SetEndLocation(node, RBRACKET8);
                    }


                }
                break;
            case 2:
                // WNScriptAST.g:282:14: LBRACKET RBRACKET
                {
                     this->matchToken(LBRACKET, &FOLLOW_LBRACKET_in_parameterList1326);
                    if  (this->hasException())
                    {
                        goto ruleparameterListEx;
                    }


                     this->matchToken(RBRACKET, &FOLLOW_RBRACKET_in_parameterList1328);
                    if  (this->hasException())
                    {
                        goto ruleparameterListEx;
                    }


                    {
                         node = wn_nullptr;
                    }


                }
                break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleparameterListEx; /* Prevent compiler warnings */
    ruleparameterListEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end parameterList */

/**
 * $ANTLR start assign_op
 * WNScriptAST.g:286:1: assign_op returns [WNAssignType node] : ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<==' );
 */
WNAssignType
WNScriptASTParser::assign_op()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNAssignType node;


    /* Initialize rule variables
     */


        node = AT_EQ;



    {
        {
            //  WNScriptAST.g:290:5: ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<==' )

            ANTLR_UINT32 alt4;

            alt4=7;

            switch ( this->LA(1) )
            {
            case 58:
                {
                    alt4=1;
                }
                break;
            case 50:
                {
                    alt4=2;
                }
                break;
            case 52:
                {
                    alt4=3;
                }
                break;
            case 48:
                {
                    alt4=4;
                }
                break;
            case 55:
                {
                    alt4=5;
                }
                break;
            case 45:
                {
                    alt4=6;
                }
                break;
            case CHOWN:
                {
                    alt4=7;
                }
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 4 );
                ex->set_state( 0 );


                goto ruleassign_opEx;

            }

            switch (alt4)
            {
            case 1:
                // WNScriptAST.g:290:10: '='
                {
                     this->matchToken(58, &FOLLOW_58_in_assign_op1364);
                    if  (this->hasException())
                    {
                        goto ruleassign_opEx;
                    }


                    {
                         node = AT_EQ;
                    }


                }
                break;
            case 2:
                // WNScriptAST.g:291:10: '+='
                {
                     this->matchToken(50, &FOLLOW_50_in_assign_op1378);
                    if  (this->hasException())
                    {
                        goto ruleassign_opEx;
                    }


                    {
                         node = AT_ADD_EQ;
                    }


                }
                break;
            case 3:
                // WNScriptAST.g:292:10: '-='
                {
                     this->matchToken(52, &FOLLOW_52_in_assign_op1391);
                    if  (this->hasException())
                    {
                        goto ruleassign_opEx;
                    }


                    {
                         node = AT_SUB_EQ;
                    }


                }
                break;
            case 4:
                // WNScriptAST.g:293:10: '*='
                {
                     this->matchToken(48, &FOLLOW_48_in_assign_op1404);
                    if  (this->hasException())
                    {
                        goto ruleassign_opEx;
                    }


                    {
                         node = AT_MULT_EQ;
                    }


                }
                break;
            case 5:
                // WNScriptAST.g:294:10: '/='
                {
                     this->matchToken(55, &FOLLOW_55_in_assign_op1417);
                    if  (this->hasException())
                    {
                        goto ruleassign_opEx;
                    }


                    {
                         node = AT_DIV_EQ;
                    }


                }
                break;
            case 6:
                // WNScriptAST.g:295:10: '%='
                {
                     this->matchToken(45, &FOLLOW_45_in_assign_op1430);
                    if  (this->hasException())
                    {
                        goto ruleassign_opEx;
                    }


                    {
                         node = AT_MOD_EQ;
                    }


                }
                break;
            case 7:
                // WNScriptAST.g:296:10: '<=='
                {
                     this->matchToken(CHOWN, &FOLLOW_CHOWN_in_assign_op1443);
                    if  (this->hasException())
                    {
                        goto ruleassign_opEx;
                    }


                    {
                         node = AT_CHOWN;
                    }


                }
                break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleassign_opEx; /* Prevent compiler warnings */
    ruleassign_opEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end assign_op */

/**
 * $ANTLR start lvalue
 * WNScriptAST.g:299:1: lvalue returns [WNLValue* node] : unary_ex ;
 */
WNLValue*
WNScriptASTParser::lvalue()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNLValue* node;


    WNExpression* unary_ex9;
    typedef    WNExpression* RETURN_TYPE_unary_ex9;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        // WNScriptAST.g:303:5: ( unary_ex )
        // WNScriptAST.g:303:10: unary_ex
        {
            this->followPush(FOLLOW_unary_ex_in_lvalue1481);
            unary_ex9=unary_ex();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelvalueEx;
            }


            {
                 node = WN_SCRIPTNODE_NEW(WNLValue(unary_ex9
                )); SetLocationFromNode(node, unary_ex9
                );
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelvalueEx; /* Prevent compiler warnings */
    rulelvalueEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end lvalue */

/**
 * $ANTLR start arglist
 * WNScriptAST.g:306:1: arglist returns [WNArgList* node] : ( (a= expression ) | ( '<==' b= expression ) ) ( ',' ( ( '<==' c= expression ) | (d= expression ) |) )* ;
 */
WNArgList*
WNScriptASTParser::arglist()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNArgList* node;


    WNExpression* a;
    typedef    WNExpression* RETURN_TYPE_a;

    WNExpression* b;
    typedef    WNExpression* RETURN_TYPE_b;

    WNExpression* c;
    typedef    WNExpression* RETURN_TYPE_c;

    WNExpression* d;
    typedef    WNExpression* RETURN_TYPE_d;

    /* Initialize rule variables
     */


        node = WN_SCRIPTNODE_NEW(WNArgList());



    {
        // WNScriptAST.g:310:9: ( ( (a= expression ) | ( '<==' b= expression ) ) ( ',' ( ( '<==' c= expression ) | (d= expression ) |) )* )
        // WNScriptAST.g:310:13: ( (a= expression ) | ( '<==' b= expression ) ) ( ',' ( ( '<==' c= expression ) | (d= expression ) |) )*
        {
            // WNScriptAST.g:310:13: ( (a= expression ) | ( '<==' b= expression ) )
            {
                int alt5=2;
                switch ( this->LA(1) )
                {
                case BOOL:
                case CHAR:
                case DOUBDEC:
                case DOUBINC:
                case FLOAT:
                case ID:
                case INT:
                case LBRACKET:
                case NULLTOK:
                case STRING:
                case TYPE:
                case 51:
                    {
                        alt5=1;
                    }
                    break;
                case CHOWN:
                    {
                        alt5=2;
                    }
                    break;

                default:
                    ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 5 );
                    ex->set_state( 0 );


                    goto rulearglistEx;

                }

                switch (alt5)
                {
                case 1:
                    // WNScriptAST.g:311:21: (a= expression )
                    {
                        // WNScriptAST.g:311:21: (a= expression )
                        // WNScriptAST.g:311:22: a= expression
                        {
                            this->followPush(FOLLOW_expression_in_arglist1540);
                            a=expression();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto rulearglistEx;
                            }


                            {
                                 node->AddExpression(a
                                ); SetLocationFromNode(node, a
                                );
                            }


                        }


                    }
                    break;
                case 2:
                    // WNScriptAST.g:312:21: ( '<==' b= expression )
                    {
                        // WNScriptAST.g:312:21: ( '<==' b= expression )
                        // WNScriptAST.g:312:22: '<==' b= expression
                        {
                             this->matchToken(CHOWN, &FOLLOW_CHOWN_in_arglist1567);
                            if  (this->hasException())
                            {
                                goto rulearglistEx;
                            }


                            this->followPush(FOLLOW_expression_in_arglist1571);
                            b=expression();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto rulearglistEx;
                            }


                            {
                                node->AddExpression(b
                                , wn_true); SetLocationFromNode(node, b
                                );
                            }


                        }


                    }
                    break;

                }
            }

            // WNScriptAST.g:315:13: ( ',' ( ( '<==' c= expression ) | (d= expression ) |) )*

            for (;;)
            {
                int alt7=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                    {
                        alt7=1;
                    }
                    break;

                }

                switch (alt7)
                {
                case 1:
                    // WNScriptAST.g:315:14: ',' ( ( '<==' c= expression ) | (d= expression ) |)
                    {
                         this->matchToken(COMMA, &FOLLOW_COMMA_in_arglist1604);
                        if  (this->hasException())
                        {
                            goto rulearglistEx;
                        }


                        // WNScriptAST.g:316:17: ( ( '<==' c= expression ) | (d= expression ) |)
                        {
                            int alt6=3;
                            switch ( this->LA(1) )
                            {
                            case CHOWN:
                                {
                                    alt6=1;
                                }
                                break;
                            case BOOL:
                            case CHAR:
                            case DOUBDEC:
                            case DOUBINC:
                            case FLOAT:
                            case ID:
                            case INT:
                            case LBRACKET:
                            case NULLTOK:
                            case STRING:
                            case TYPE:
                            case 51:
                                {
                                    alt6=2;
                                }
                                break;
                            case COMMA:
                            case RBRACKET:
                                {
                                    alt6=3;
                                }
                                break;

                            default:
                                ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 6 );
                                ex->set_state( 0 );


                                goto rulearglistEx;

                            }

                            switch (alt6)
                            {
                            case 1:
                                // WNScriptAST.g:317:21: ( '<==' c= expression )
                                {
                                    // WNScriptAST.g:317:21: ( '<==' c= expression )
                                    // WNScriptAST.g:317:23: '<==' c= expression
                                    {
                                         this->matchToken(CHOWN, &FOLLOW_CHOWN_in_arglist1647);
                                        if  (this->hasException())
                                        {
                                            goto rulearglistEx;
                                        }


                                        this->followPush(FOLLOW_expression_in_arglist1651);
                                        c=expression();

                                        this->followPop();
                                        if  (this->hasException())
                                        {
                                            goto rulearglistEx;
                                        }


                                        {
                                             node->AddExpression(c
                                            ); SetEndLocationFromNode(node, c
                                            );
                                        }


                                    }


                                }
                                break;
                            case 2:
                                // WNScriptAST.g:318:21: (d= expression )
                                {
                                    // WNScriptAST.g:318:21: (d= expression )
                                    // WNScriptAST.g:318:23: d= expression
                                    {
                                        this->followPush(FOLLOW_expression_in_arglist1683);
                                        d=expression();

                                        this->followPop();
                                        if  (this->hasException())
                                        {
                                            goto rulearglistEx;
                                        }


                                        {
                                             node->AddExpression(d
                                            , wn_true); SetEndLocationFromNode(node, d
                                            );
                                        }


                                    }


                                }
                                break;
                            case 3:
                                // WNScriptAST.g:319:17:
                                {
                                }
                                break;

                            }
                        }

                    }
                    break;

                default:
                    goto loop7;    /* break out of the loop */
                    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulearglistEx; /* Prevent compiler warnings */
    rulearglistEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end arglist */

/**
 * $ANTLR start expression
 * WNScriptAST.g:323:1: expression returns [WNExpression* node] : cond_ex ;
 */
WNExpression*
WNScriptASTParser::expression()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNExpression* node;


    WNExpression* cond_ex10;
    typedef    WNExpression* RETURN_TYPE_cond_ex10;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        // WNScriptAST.g:327:9: ( cond_ex )
        // WNScriptAST.g:327:14: cond_ex
        {
            this->followPush(FOLLOW_cond_ex_in_expression1767);
            cond_ex10=cond_ex();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexpressionEx;
            }


            {
                 node = cond_ex10
                ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end expression */

/**
 * $ANTLR start cond_ex
 * WNScriptAST.g:330:1: cond_ex returns [WNExpression* node] : or_ex ( '?' b= expression ':' c= cond_ex )? ;
 */
WNExpression*
WNScriptASTParser::cond_ex()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNExpression* node;


    WNExpression* b;
    typedef    WNExpression* RETURN_TYPE_b;

    WNExpression* c;
    typedef    WNExpression* RETURN_TYPE_c;

    WNExpression* or_ex11;
    typedef    WNExpression* RETURN_TYPE_or_ex11;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        // WNScriptAST.g:334:9: ( or_ex ( '?' b= expression ':' c= cond_ex )? )
        // WNScriptAST.g:334:14: or_ex ( '?' b= expression ':' c= cond_ex )?
        {
            this->followPush(FOLLOW_or_ex_in_cond_ex1813);
            or_ex11=or_ex();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecond_exEx;
            }


            {
                 node = or_ex11
                ;
            }


            // WNScriptAST.g:336:17: ( '?' b= expression ':' c= cond_ex )?
            {
                int alt8=2;
                switch ( this->LA(1) )
                {
                    case 62:
                        {
                            alt8=1;
                        }
                        break;
                }

                switch (alt8)
                {
                case 1:
                    // WNScriptAST.g:336:18: '?' b= expression ':' c= cond_ex
                    {
                         this->matchToken(62, &FOLLOW_62_in_cond_ex1836);
                        if  (this->hasException())
                        {
                            goto rulecond_exEx;
                        }


                        this->followPush(FOLLOW_expression_in_cond_ex1840);
                        b=expression();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto rulecond_exEx;
                        }


                         this->matchToken(COLON, &FOLLOW_COLON_in_cond_ex1842);
                        if  (this->hasException())
                        {
                            goto rulecond_exEx;
                        }


                        this->followPush(FOLLOW_cond_ex_in_cond_ex1846);
                        c=cond_ex();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto rulecond_exEx;
                        }


                        {
                             node = WN_SCRIPTNODE_NEW(WNCondExpression(node, b
                            , c
                            ));  SetLocationFromNode(node, or_ex11
                            ); SetEndLocationFromNode(node, c
                            );
                        }


                    }
                    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulecond_exEx; /* Prevent compiler warnings */
    rulecond_exEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end cond_ex */

/**
 * $ANTLR start or_ex
 * WNScriptAST.g:339:1: or_ex returns [WNExpression* node] : a= and_ex ( '||' b= and_ex )* ;
 */
WNExpression*
WNScriptASTParser::or_ex()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNExpression* node;


    WNExpression* a;
    typedef    WNExpression* RETURN_TYPE_a;

    WNExpression* b;
    typedef    WNExpression* RETURN_TYPE_b;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        // WNScriptAST.g:343:9: (a= and_ex ( '||' b= and_ex )* )
        // WNScriptAST.g:343:14: a= and_ex ( '||' b= and_ex )*
        {
            this->followPush(FOLLOW_and_ex_in_or_ex1901);
            a=and_ex();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleor_exEx;
            }


            {
                 node = a
                ;
            }


            // WNScriptAST.g:344:13: ( '||' b= and_ex )*

            for (;;)
            {
                int alt9=2;
                switch ( this->LA(1) )
                {
                case 63:
                    {
                        alt9=1;
                    }
                    break;

                }

                switch (alt9)
                {
                case 1:
                    // WNScriptAST.g:344:14: '||' b= and_ex
                    {
                         this->matchToken(63, &FOLLOW_63_in_or_ex1918);
                        if  (this->hasException())
                        {
                            goto ruleor_exEx;
                        }


                        this->followPush(FOLLOW_and_ex_in_or_ex1922);
                        b=and_ex();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleor_exEx;
                        }


                        {
                             node = WN_SCRIPTNODE_NEW(WNSSExpression(ST_OR, node, b
                            )); SetLocationFromNode(node, a
                            ); SetEndLocationFromNode(node, b
                            );
                        }


                    }
                    break;

                default:
                    goto loop9;    /* break out of the loop */
                    break;
                }
            }
            loop9: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleor_exEx; /* Prevent compiler warnings */
    ruleor_exEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end or_ex */

/**
 * $ANTLR start and_ex
 * WNScriptAST.g:347:1: and_ex returns [WNExpression* node] : a= eq_ex ( '&&' b= eq_ex )* ;
 */
WNExpression*
WNScriptASTParser::and_ex()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNExpression* node;


    WNExpression* a;
    typedef    WNExpression* RETURN_TYPE_a;

    WNExpression* b;
    typedef    WNExpression* RETURN_TYPE_b;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        // WNScriptAST.g:351:9: (a= eq_ex ( '&&' b= eq_ex )* )
        // WNScriptAST.g:351:14: a= eq_ex ( '&&' b= eq_ex )*
        {
            this->followPush(FOLLOW_eq_ex_in_and_ex1973);
            a=eq_ex();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleand_exEx;
            }


            {
                 node = a
                ;
            }


            // WNScriptAST.g:352:13: ( '&&' b= eq_ex )*

            for (;;)
            {
                int alt10=2;
                switch ( this->LA(1) )
                {
                case 46:
                    {
                        alt10=1;
                    }
                    break;

                }

                switch (alt10)
                {
                case 1:
                    // WNScriptAST.g:352:14: '&&' b= eq_ex
                    {
                         this->matchToken(46, &FOLLOW_46_in_and_ex1990);
                        if  (this->hasException())
                        {
                            goto ruleand_exEx;
                        }


                        this->followPush(FOLLOW_eq_ex_in_and_ex1994);
                        b=eq_ex();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleand_exEx;
                        }


                        {
                            node = WN_SCRIPTNODE_NEW(WNSSExpression(ST_AND, node, b
                            )); SetLocationFromNode(node, a
                            ); SetEndLocationFromNode(node, b
                            );
                        }


                    }
                    break;

                default:
                    goto loop10;    /* break out of the loop */
                    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleand_exEx; /* Prevent compiler warnings */
    ruleand_exEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end and_ex */

/**
 * $ANTLR start eq_ex
 * WNScriptAST.g:353:1: eq_ex returns [WNExpression* node] : a= rel_ex ( ( '==' b= rel_ex ) | ( '!=' c= rel_ex ) )* ;
 */
WNExpression*
WNScriptASTParser::eq_ex()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNExpression* node;


    WNExpression* a;
    typedef    WNExpression* RETURN_TYPE_a;

    WNExpression* b;
    typedef    WNExpression* RETURN_TYPE_b;

    WNExpression* c;
    typedef    WNExpression* RETURN_TYPE_c;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        // WNScriptAST.g:357:9: (a= rel_ex ( ( '==' b= rel_ex ) | ( '!=' c= rel_ex ) )* )
        // WNScriptAST.g:357:14: a= rel_ex ( ( '==' b= rel_ex ) | ( '!=' c= rel_ex ) )*
        {
            this->followPush(FOLLOW_rel_ex_in_eq_ex2029);
            a=rel_ex();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleeq_exEx;
            }


            {
                 node = a
                ;
            }


            // WNScriptAST.g:358:13: ( ( '==' b= rel_ex ) | ( '!=' c= rel_ex ) )*

            for (;;)
            {
                int alt11=3;
                switch ( this->LA(1) )
                {
                case 59:
                    {
                        alt11=1;
                    }
                    break;
                case 43:
                    {
                        alt11=2;
                    }
                    break;

                }

                switch (alt11)
                {
                case 1:
                    // WNScriptAST.g:359:17: ( '==' b= rel_ex )
                    {
                        // WNScriptAST.g:359:17: ( '==' b= rel_ex )
                        // WNScriptAST.g:359:18: '==' b= rel_ex
                        {
                             this->matchToken(59, &FOLLOW_59_in_eq_ex2068);
                            if  (this->hasException())
                            {
                                goto ruleeq_exEx;
                            }


                            this->followPush(FOLLOW_rel_ex_in_eq_ex2072);
                            b=rel_ex();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto ruleeq_exEx;
                            }


                            {
                                node = WN_SCRIPTNODE_NEW(WNBinExpression(AR_EQ, node, b
                                ));  SetLocationFromNode(node, a
                                ); SetEndLocationFromNode(node, b
                                );
                            }


                        }


                    }
                    break;
                case 2:
                    // WNScriptAST.g:360:17: ( '!=' c= rel_ex )
                    {
                        // WNScriptAST.g:360:17: ( '!=' c= rel_ex )
                        // WNScriptAST.g:360:18: '!=' c= rel_ex
                        {
                             this->matchToken(43, &FOLLOW_43_in_eq_ex2095);
                            if  (this->hasException())
                            {
                                goto ruleeq_exEx;
                            }


                            this->followPush(FOLLOW_rel_ex_in_eq_ex2099);
                            c=rel_ex();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto ruleeq_exEx;
                            }


                            {
                                node = WN_SCRIPTNODE_NEW(WNBinExpression(AR_NEQ, node, c
                                )); SetLocationFromNode(node, a
                                ); SetEndLocationFromNode(node, c
                                );
                            }


                        }


                    }
                    break;

                default:
                    goto loop11;    /* break out of the loop */
                    break;
                }
            }
            loop11: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleeq_exEx; /* Prevent compiler warnings */
    ruleeq_exEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end eq_ex */

/**
 * $ANTLR start rel_ex
 * WNScriptAST.g:364:1: rel_ex returns [WNExpression* node] : a= add_ex ( ( '<' b= add_ex ) | ( '>' c= add_ex ) | ( '<=' d= add_ex ) | ( '>=' e= add_ex ) )* ;
 */
WNExpression*
WNScriptASTParser::rel_ex()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNExpression* node;


    WNExpression* a;
    typedef    WNExpression* RETURN_TYPE_a;

    WNExpression* b;
    typedef    WNExpression* RETURN_TYPE_b;

    WNExpression* c;
    typedef    WNExpression* RETURN_TYPE_c;

    WNExpression* d;
    typedef    WNExpression* RETURN_TYPE_d;

    WNExpression* e;
    typedef    WNExpression* RETURN_TYPE_e;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        // WNScriptAST.g:368:9: (a= add_ex ( ( '<' b= add_ex ) | ( '>' c= add_ex ) | ( '<=' d= add_ex ) | ( '>=' e= add_ex ) )* )
        // WNScriptAST.g:368:14: a= add_ex ( ( '<' b= add_ex ) | ( '>' c= add_ex ) | ( '<=' d= add_ex ) | ( '>=' e= add_ex ) )*
        {
            this->followPush(FOLLOW_add_ex_in_rel_ex2169);
            a=add_ex();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerel_exEx;
            }


            {
                 node=a
                ;
            }


            // WNScriptAST.g:369:13: ( ( '<' b= add_ex ) | ( '>' c= add_ex ) | ( '<=' d= add_ex ) | ( '>=' e= add_ex ) )*

            for (;;)
            {
                int alt12=5;
                switch ( this->LA(1) )
                {
                case 56:
                    {
                        alt12=1;
                    }
                    break;
                case 60:
                    {
                        alt12=2;
                    }
                    break;
                case 57:
                    {
                        alt12=3;
                    }
                    break;
                case 61:
                    {
                        alt12=4;
                    }
                    break;

                }

                switch (alt12)
                {
                case 1:
                    // WNScriptAST.g:370:17: ( '<' b= add_ex )
                    {
                        // WNScriptAST.g:370:17: ( '<' b= add_ex )
                        // WNScriptAST.g:370:19: '<' b= add_ex
                        {
                             this->matchToken(56, &FOLLOW_56_in_rel_ex2205);
                            if  (this->hasException())
                            {
                                goto rulerel_exEx;
                            }


                            this->followPush(FOLLOW_add_ex_in_rel_ex2209);
                            b=add_ex();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto rulerel_exEx;
                            }


                            {
                                node = WN_SCRIPTNODE_NEW(WNBinExpression(AR_LT, node, b
                                ));   SetLocationFromNode(node, a
                                ); SetEndLocationFromNode(node, b
                                );
                            }


                        }


                    }
                    break;
                case 2:
                    // WNScriptAST.g:371:17: ( '>' c= add_ex )
                    {
                        // WNScriptAST.g:371:17: ( '>' c= add_ex )
                        // WNScriptAST.g:371:19: '>' c= add_ex
                        {
                             this->matchToken(60, &FOLLOW_60_in_rel_ex2233);
                            if  (this->hasException())
                            {
                                goto rulerel_exEx;
                            }


                            this->followPush(FOLLOW_add_ex_in_rel_ex2237);
                            c=add_ex();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto rulerel_exEx;
                            }


                            {
                                node = WN_SCRIPTNODE_NEW(WNBinExpression(AR_GT, node, c
                                ));   SetLocationFromNode(node, a
                                ); SetEndLocationFromNode(node, c
                                );
                            }


                        }


                    }
                    break;
                case 3:
                    // WNScriptAST.g:372:17: ( '<=' d= add_ex )
                    {
                        // WNScriptAST.g:372:17: ( '<=' d= add_ex )
                        // WNScriptAST.g:372:19: '<=' d= add_ex
                        {
                             this->matchToken(57, &FOLLOW_57_in_rel_ex2261);
                            if  (this->hasException())
                            {
                                goto rulerel_exEx;
                            }


                            this->followPush(FOLLOW_add_ex_in_rel_ex2265);
                            d=add_ex();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto rulerel_exEx;
                            }


                            {
                                node = WN_SCRIPTNODE_NEW(WNBinExpression(AR_LEQ, node, d
                                ));   SetLocationFromNode(node, a
                                ); SetEndLocationFromNode(node, d
                                );
                            }


                        }


                    }
                    break;
                case 4:
                    // WNScriptAST.g:373:17: ( '>=' e= add_ex )
                    {
                        // WNScriptAST.g:373:17: ( '>=' e= add_ex )
                        // WNScriptAST.g:373:19: '>=' e= add_ex
                        {
                             this->matchToken(61, &FOLLOW_61_in_rel_ex2289);
                            if  (this->hasException())
                            {
                                goto rulerel_exEx;
                            }


                            this->followPush(FOLLOW_add_ex_in_rel_ex2293);
                            e=add_ex();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto rulerel_exEx;
                            }


                            {
                                node = WN_SCRIPTNODE_NEW(WNBinExpression(AR_GEQ, node, e
                                ));   SetLocationFromNode(node, a
                                ); SetEndLocationFromNode(node, e
                                );
                            }


                        }


                    }
                    break;

                default:
                    goto loop12;    /* break out of the loop */
                    break;
                }
            }
            loop12: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerel_exEx; /* Prevent compiler warnings */
    rulerel_exEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end rel_ex */

/**
 * $ANTLR start add_ex
 * WNScriptAST.g:377:1: add_ex returns [WNExpression* node] : a= mult_ex ( ( '+' b= mult_ex ) | ( '-' c= mult_ex ) )* ;
 */
WNExpression*
WNScriptASTParser::add_ex()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNExpression* node;


    WNExpression* a;
    typedef    WNExpression* RETURN_TYPE_a;

    WNExpression* b;
    typedef    WNExpression* RETURN_TYPE_b;

    WNExpression* c;
    typedef    WNExpression* RETURN_TYPE_c;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        // WNScriptAST.g:381:9: (a= mult_ex ( ( '+' b= mult_ex ) | ( '-' c= mult_ex ) )* )
        // WNScriptAST.g:381:14: a= mult_ex ( ( '+' b= mult_ex ) | ( '-' c= mult_ex ) )*
        {
            this->followPush(FOLLOW_mult_ex_in_add_ex2354);
            a=mult_ex();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleadd_exEx;
            }


            {
                node = a
                ;
            }


            // WNScriptAST.g:382:13: ( ( '+' b= mult_ex ) | ( '-' c= mult_ex ) )*

            for (;;)
            {
                int alt13=3;
                switch ( this->LA(1) )
                {
                case 49:
                    {
                        alt13=1;
                    }
                    break;
                case 51:
                    {
                        alt13=2;
                    }
                    break;

                }

                switch (alt13)
                {
                case 1:
                    // WNScriptAST.g:383:17: ( '+' b= mult_ex )
                    {
                        // WNScriptAST.g:383:17: ( '+' b= mult_ex )
                        // WNScriptAST.g:383:18: '+' b= mult_ex
                        {
                             this->matchToken(49, &FOLLOW_49_in_add_ex2390);
                            if  (this->hasException())
                            {
                                goto ruleadd_exEx;
                            }


                            this->followPush(FOLLOW_mult_ex_in_add_ex2394);
                            b=mult_ex();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto ruleadd_exEx;
                            }


                            {
                                node = WN_SCRIPTNODE_NEW(WNBinExpression(AR_ADD, node, b
                                ));   SetLocationFromNode(node, a
                                ); SetEndLocationFromNode(node, b
                                );
                            }


                        }


                    }
                    break;
                case 2:
                    // WNScriptAST.g:384:17: ( '-' c= mult_ex )
                    {
                        // WNScriptAST.g:384:17: ( '-' c= mult_ex )
                        // WNScriptAST.g:384:18: '-' c= mult_ex
                        {
                             this->matchToken(51, &FOLLOW_51_in_add_ex2416);
                            if  (this->hasException())
                            {
                                goto ruleadd_exEx;
                            }


                            this->followPush(FOLLOW_mult_ex_in_add_ex2420);
                            c=mult_ex();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto ruleadd_exEx;
                            }


                            {
                                node = WN_SCRIPTNODE_NEW(WNBinExpression(AR_SUB, node, c
                                ));   SetLocationFromNode(node, a
                                ); SetEndLocationFromNode(node, c
                                );
                            }


                        }


                    }
                    break;

                default:
                    goto loop13;    /* break out of the loop */
                    break;
                }
            }
            loop13: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleadd_exEx; /* Prevent compiler warnings */
    ruleadd_exEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end add_ex */

/**
 * $ANTLR start mult_ex
 * WNScriptAST.g:388:1: mult_ex returns [WNExpression* node] : a= unary_ex ( ( '*' b= unary_ex ) | ( '/' c= unary_ex ) | ( '%' d= unary_ex ) )* ;
 */
WNExpression*
WNScriptASTParser::mult_ex()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNExpression* node;


    WNExpression* a;
    typedef    WNExpression* RETURN_TYPE_a;

    WNExpression* b;
    typedef    WNExpression* RETURN_TYPE_b;

    WNExpression* c;
    typedef    WNExpression* RETURN_TYPE_c;

    WNExpression* d;
    typedef    WNExpression* RETURN_TYPE_d;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        // WNScriptAST.g:392:9: (a= unary_ex ( ( '*' b= unary_ex ) | ( '/' c= unary_ex ) | ( '%' d= unary_ex ) )* )
        // WNScriptAST.g:392:14: a= unary_ex ( ( '*' b= unary_ex ) | ( '/' c= unary_ex ) | ( '%' d= unary_ex ) )*
        {
            this->followPush(FOLLOW_unary_ex_in_mult_ex2479);
            a=unary_ex();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemult_exEx;
            }


            {
                 node = a
                ;
            }


            // WNScriptAST.g:393:13: ( ( '*' b= unary_ex ) | ( '/' c= unary_ex ) | ( '%' d= unary_ex ) )*

            for (;;)
            {
                int alt14=4;
                switch ( this->LA(1) )
                {
                case 47:
                    {
                        alt14=1;
                    }
                    break;
                case 54:
                    {
                        alt14=2;
                    }
                    break;
                case 44:
                    {
                        alt14=3;
                    }
                    break;

                }

                switch (alt14)
                {
                case 1:
                    // WNScriptAST.g:394:21: ( '*' b= unary_ex )
                    {
                        // WNScriptAST.g:394:21: ( '*' b= unary_ex )
                        // WNScriptAST.g:394:22: '*' b= unary_ex
                        {
                             this->matchToken(47, &FOLLOW_47_in_mult_ex2518);
                            if  (this->hasException())
                            {
                                goto rulemult_exEx;
                            }


                            this->followPush(FOLLOW_unary_ex_in_mult_ex2522);
                            b=unary_ex();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto rulemult_exEx;
                            }


                            {
                                node = WN_SCRIPTNODE_NEW(WNBinExpression(AR_MULT, node, b
                                ));   SetLocationFromNode(node, a
                                ); SetEndLocationFromNode(node, b
                                );
                            }


                        }


                    }
                    break;
                case 2:
                    // WNScriptAST.g:395:21: ( '/' c= unary_ex )
                    {
                        // WNScriptAST.g:395:21: ( '/' c= unary_ex )
                        // WNScriptAST.g:395:22: '/' c= unary_ex
                        {
                             this->matchToken(54, &FOLLOW_54_in_mult_ex2548);
                            if  (this->hasException())
                            {
                                goto rulemult_exEx;
                            }


                            this->followPush(FOLLOW_unary_ex_in_mult_ex2552);
                            c=unary_ex();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto rulemult_exEx;
                            }


                            {
                                node = WN_SCRIPTNODE_NEW(WNBinExpression(AR_DIV, node, c
                                ));   SetLocationFromNode(node, a
                                ); SetEndLocationFromNode(node, c
                                );
                            }


                        }


                    }
                    break;
                case 3:
                    // WNScriptAST.g:396:21: ( '%' d= unary_ex )
                    {
                        // WNScriptAST.g:396:21: ( '%' d= unary_ex )
                        // WNScriptAST.g:396:22: '%' d= unary_ex
                        {
                             this->matchToken(44, &FOLLOW_44_in_mult_ex2578);
                            if  (this->hasException())
                            {
                                goto rulemult_exEx;
                            }


                            this->followPush(FOLLOW_unary_ex_in_mult_ex2582);
                            d=unary_ex();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto rulemult_exEx;
                            }


                            {
                                node = WN_SCRIPTNODE_NEW(WNBinExpression(AR_MOD, node, d
                                ));   SetLocationFromNode(node, a
                                ); SetEndLocationFromNode(node, d
                                );
                            }


                        }


                    }
                    break;

                default:
                    goto loop14;    /* break out of the loop */
                    break;
                }
            }
            loop14: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemult_exEx; /* Prevent compiler warnings */
    rulemult_exEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end mult_ex */

/**
 * $ANTLR start unary_ex
 * WNScriptAST.g:400:1: unary_ex returns [WNExpression* node] : (a= post_ex | '++' b= unary_ex | '--' c= unary_ex | '-' d= unary_ex );
 */
WNExpression*
WNScriptASTParser::unary_ex()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNExpression* node;


    WNExpression* a;
    typedef    WNExpression* RETURN_TYPE_a;

    WNExpression* b;
    typedef    WNExpression* RETURN_TYPE_b;

    WNExpression* c;
    typedef    WNExpression* RETURN_TYPE_c;

    WNExpression* d;
    typedef    WNExpression* RETURN_TYPE_d;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        {
            //  WNScriptAST.g:404:5: (a= post_ex | '++' b= unary_ex | '--' c= unary_ex | '-' d= unary_ex )

            ANTLR_UINT32 alt15;

            alt15=4;

            switch ( this->LA(1) )
            {
            case BOOL:
            case CHAR:
            case FLOAT:
            case ID:
            case INT:
            case LBRACKET:
            case NULLTOK:
            case STRING:
            case TYPE:
                {
                    alt15=1;
                }
                break;
            case DOUBINC:
                {
                    alt15=2;
                }
                break;
            case DOUBDEC:
                {
                    alt15=3;
                }
                break;
            case 51:
                {
                    alt15=4;
                }
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 15 );
                ex->set_state( 0 );


                goto ruleunary_exEx;

            }

            switch (alt15)
            {
            case 1:
                // WNScriptAST.g:404:10: a= post_ex
                {
                    this->followPush(FOLLOW_post_ex_in_unary_ex2643);
                    a=post_ex();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleunary_exEx;
                    }


                    {
                         node = a
                        ;
                    }


                }
                break;
            case 2:
                // WNScriptAST.g:405:10: '++' b= unary_ex
                {
                     this->matchToken(DOUBINC, &FOLLOW_DOUBINC_in_unary_ex2656);
                    if  (this->hasException())
                    {
                        goto ruleunary_exEx;
                    }


                    this->followPush(FOLLOW_unary_ex_in_unary_ex2660);
                    b=unary_ex();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleunary_exEx;
                    }


                    {
                         WNNode* t = node; node = WN_SCRIPTNODE_NEW(WNUNExpression(UN_PREINC, b
                        ));   SetLocationFromNode(node, t); SetEndLocationFromNode(node, b
                        );
                    }


                }
                break;
            case 3:
                // WNScriptAST.g:406:10: '--' c= unary_ex
                {
                     this->matchToken(DOUBDEC, &FOLLOW_DOUBDEC_in_unary_ex2673);
                    if  (this->hasException())
                    {
                        goto ruleunary_exEx;
                    }


                    this->followPush(FOLLOW_unary_ex_in_unary_ex2677);
                    c=unary_ex();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleunary_exEx;
                    }


                    {
                         WNNode* t = node; node = WN_SCRIPTNODE_NEW(WNUNExpression(UN_PREDEC, c
                        ));   SetLocationFromNode(node, t); SetEndLocationFromNode(node, c
                        );
                    }


                }
                break;
            case 4:
                // WNScriptAST.g:407:10: '-' d= unary_ex
                {
                     this->matchToken(51, &FOLLOW_51_in_unary_ex2690);
                    if  (this->hasException())
                    {
                        goto ruleunary_exEx;
                    }


                    this->followPush(FOLLOW_unary_ex_in_unary_ex2694);
                    d=unary_ex();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleunary_exEx;
                    }


                    {
                         WNNode* t = node; node = WN_SCRIPTNODE_NEW(WNUNExpression(UN_NEG, d
                        ));   SetLocationFromNode(node, t); SetEndLocationFromNode(node, d
                        );
                    }


                }
                break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleunary_exEx; /* Prevent compiler warnings */
    ruleunary_exEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end unary_ex */

/**
 * $ANTLR start post_ex_proper
 * WNScriptAST.g:411:1: post_ex_proper returns [WNPostExpression* node] : (d= LSQBRACKET a= expression e= RSQBRACKET |f= LBRACKET g= RBRACKET |h= LBRACKET b= arglist i= RBRACKET | '.' c= ID | DOUBINC | DOUBDEC );
 */
WNPostExpression*
WNScriptASTParser::post_ex_proper()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNPostExpression* node;


    const CommonTokenType*    d;
    const CommonTokenType*    e;
    const CommonTokenType*    f;
    const CommonTokenType*    g;
    const CommonTokenType*    h;
    const CommonTokenType*    i;
    const CommonTokenType*    c;
    const CommonTokenType*    DOUBINC12;
    const CommonTokenType*    DOUBDEC13;
    WNExpression* a;
    typedef    WNExpression* RETURN_TYPE_a;

    WNArgList* b;
    typedef    WNArgList* RETURN_TYPE_b;

    /* Initialize rule variables
     */


        node = wn_nullptr;

    d       = NULL;
    e       = NULL;
    f       = NULL;
    g       = NULL;
    h       = NULL;
    i       = NULL;
    c       = NULL;
    DOUBINC12       = NULL;
    DOUBDEC13       = NULL;



    {
        {
            //  WNScriptAST.g:415:5: (d= LSQBRACKET a= expression e= RSQBRACKET |f= LBRACKET g= RBRACKET |h= LBRACKET b= arglist i= RBRACKET | '.' c= ID | DOUBINC | DOUBDEC )

            ANTLR_UINT32 alt16;

            alt16=6;

            switch ( this->LA(1) )
            {
            case LSQBRACKET:
                {
                    alt16=1;
                }
                break;
            case LBRACKET:
                {
                    switch ( this->LA(2) )
                    {
                    case RBRACKET:
                        {
                            alt16=2;
                        }
                        break;
                    case BOOL:
                    case CHAR:
                    case CHOWN:
                    case DOUBDEC:
                    case DOUBINC:
                    case FLOAT:
                    case ID:
                    case INT:
                    case LBRACKET:
                    case NULLTOK:
                    case STRING:
                    case TYPE:
                    case 51:
                        {
                            alt16=3;
                        }
                        break;

                    default:
                        ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 16 );
                        ex->set_state( 2 );


                        goto rulepost_ex_properEx;

                    }

                }
                break;
            case 53:
                {
                    alt16=4;
                }
                break;
            case DOUBINC:
                {
                    alt16=5;
                }
                break;
            case DOUBDEC:
                {
                    alt16=6;
                }
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 16 );
                ex->set_state( 0 );


                goto rulepost_ex_properEx;

            }

            switch (alt16)
            {
            case 1:
                // WNScriptAST.g:415:10: d= LSQBRACKET a= expression e= RSQBRACKET
                {
                    d =  this->matchToken(LSQBRACKET, &FOLLOW_LSQBRACKET_in_post_ex_proper2740);
                    if  (this->hasException())
                    {
                        goto rulepost_ex_properEx;
                    }


                    this->followPush(FOLLOW_expression_in_post_ex_proper2744);
                    a=expression();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto rulepost_ex_properEx;
                    }


                    e =  this->matchToken(RSQBRACKET, &FOLLOW_RSQBRACKET_in_post_ex_proper2748);
                    if  (this->hasException())
                    {
                        goto rulepost_ex_properEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNArrayAccessExpr(a
                        )); SetLocation(node, d); SetEndLocation(node, e);
                    }


                }
                break;
            case 2:
                // WNScriptAST.g:416:10: f= LBRACKET g= RBRACKET
                {
                    f =  this->matchToken(LBRACKET, &FOLLOW_LBRACKET_in_post_ex_proper2763);
                    if  (this->hasException())
                    {
                        goto rulepost_ex_properEx;
                    }


                    g =  this->matchToken(RBRACKET, &FOLLOW_RBRACKET_in_post_ex_proper2767);
                    if  (this->hasException())
                    {
                        goto rulepost_ex_properEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNFunctionCallExpr()); SetLocation(node, f); SetEndLocation(node, g);
                    }


                }
                break;
            case 3:
                // WNScriptAST.g:417:10: h= LBRACKET b= arglist i= RBRACKET
                {
                    h =  this->matchToken(LBRACKET, &FOLLOW_LBRACKET_in_post_ex_proper2795);
                    if  (this->hasException())
                    {
                        goto rulepost_ex_properEx;
                    }


                    this->followPush(FOLLOW_arglist_in_post_ex_proper2801);
                    b=arglist();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto rulepost_ex_properEx;
                    }


                    i =  this->matchToken(RBRACKET, &FOLLOW_RBRACKET_in_post_ex_proper2805);
                    if  (this->hasException())
                    {
                        goto rulepost_ex_properEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNFunctionCallExpr(b
                        )); SetLocation(node, h); SetEndLocation(node, i);
                    }


                }
                break;
            case 4:
                // WNScriptAST.g:418:9: '.' c= ID
                {
                     this->matchToken(53, &FOLLOW_53_in_post_ex_proper2818);
                    if  (this->hasException())
                    {
                        goto rulepost_ex_properEx;
                    }


                    c =  this->matchToken(ID, &FOLLOW_ID_in_post_ex_proper2822);
                    if  (this->hasException())
                    {
                        goto rulepost_ex_properEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNMemberAccessExpr((c->getText()).c_str())); SetLocation(node, c);
                    }


                }
                break;
            case 5:
                // WNScriptAST.g:419:11: DOUBINC
                {
                    DOUBINC12 =  this->matchToken(DOUBINC, &FOLLOW_DOUBINC_in_post_ex_proper2849);
                    if  (this->hasException())
                    {
                        goto rulepost_ex_properEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNPostUNExpression(UN_POSTINC)); SetLocation(node, DOUBINC12);
                    }


                }
                break;
            case 6:
                // WNScriptAST.g:420:9: DOUBDEC
                {
                    DOUBDEC13 =  this->matchToken(DOUBDEC, &FOLLOW_DOUBDEC_in_post_ex_proper2878);
                    if  (this->hasException())
                    {
                        goto rulepost_ex_properEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNPostUNExpression(UN_POSTDEC)); SetLocation(node, DOUBDEC13);
                    }


                }
                break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulepost_ex_properEx; /* Prevent compiler warnings */
    rulepost_ex_properEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end post_ex_proper */

/**
 * $ANTLR start post_ex
 * WNScriptAST.g:423:1: post_ex returns [WNExpression* node] : prim_ex (a= post_ex_proper )* ;
 */
WNExpression*
WNScriptASTParser::post_ex()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNExpression* node;


    WNPostExpression* a;
    typedef    WNPostExpression* RETURN_TYPE_a;

    WNExpression * prim_ex14;
    typedef    WNExpression * RETURN_TYPE_prim_ex14;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        // WNScriptAST.g:427:9: ( prim_ex (a= post_ex_proper )* )
        // WNScriptAST.g:427:13: prim_ex (a= post_ex_proper )*
        {
            this->followPush(FOLLOW_prim_ex_in_post_ex2935);
            prim_ex14=prim_ex();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepost_exEx;
            }


            {
                 node = prim_ex14
                ;
            }


            // WNScriptAST.g:428:13: (a= post_ex_proper )*

            for (;;)
            {
                int alt17=2;
                switch ( this->LA(1) )
                {
                case DOUBDEC:
                case DOUBINC:
                case LBRACKET:
                case LSQBRACKET:
                case 53:
                    {
                        alt17=1;
                    }
                    break;

                }

                switch (alt17)
                {
                case 1:
                    // WNScriptAST.g:428:14: a= post_ex_proper
                    {
                        this->followPush(FOLLOW_post_ex_proper_in_post_ex2954);
                        a=post_ex_proper();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto rulepost_exEx;
                        }


                        {
                            a
                            ->AddBaseExpr(node); SetEndLocationFromNode(a
                            , node); node = a
                            ;
                        }


                    }
                    break;

                default:
                    goto loop17;    /* break out of the loop */
                    break;
                }
            }
            loop17: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepost_exEx; /* Prevent compiler warnings */
    rulepost_exEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end post_ex */

/**
 * $ANTLR start assignment
 * WNScriptAST.g:430:1: assignment returns [WNAssignment* node] : lvalue ( assign_op expression )? ;
 */
WNAssignment*
WNScriptASTParser::assignment()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNAssignment* node;


    WNLValue* lvalue15;
    typedef    WNLValue* RETURN_TYPE_lvalue15;

    WNAssignType assign_op16;
    typedef    WNAssignType RETURN_TYPE_assign_op16;

    WNExpression* expression17;
    typedef    WNExpression* RETURN_TYPE_expression17;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        // WNScriptAST.g:434:5: ( lvalue ( assign_op expression )? )
        // WNScriptAST.g:434:10: lvalue ( assign_op expression )?
        {
            this->followPush(FOLLOW_lvalue_in_assignment2983);
            lvalue15=lvalue();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleassignmentEx;
            }


            {
                 node = WN_SCRIPTNODE_NEW(WNAssignment(lvalue15
                )); SetLocationFromNode(node, lvalue15
                );
            }


            // WNScriptAST.g:435:9: ( assign_op expression )?
            {
                int alt18=2;
                switch ( this->LA(1) )
                {
                    case CHOWN:
                    case 45:
                    case 48:
                    case 50:
                    case 52:
                    case 55:
                    case 58:
                        {
                            alt18=1;
                        }
                        break;
                }

                switch (alt18)
                {
                case 1:
                    // WNScriptAST.g:435:10: assign_op expression
                    {
                        this->followPush(FOLLOW_assign_op_in_assignment2996);
                        assign_op16=assign_op();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleassignmentEx;
                        }


                        this->followPush(FOLLOW_expression_in_assignment2998);
                        expression17=expression();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleassignmentEx;
                        }


                        {
                             node->AddValue(assign_op16
                            , expression17
                            ); SetEndLocationFromNode(node, expression17
                            );
                        }


                    }
                    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleassignmentEx; /* Prevent compiler warnings */
    ruleassignmentEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end assignment */

/**
 * $ANTLR start constant
 * WNScriptAST.g:437:1: constant returns [WNConstantExpression* node] : ( INT | FLOAT | CHAR | STRING | BOOL );
 */
WNConstantExpression*
WNScriptASTParser::constant()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNConstantExpression* node;


    const CommonTokenType*    INT18;
    const CommonTokenType*    FLOAT19;
    const CommonTokenType*    CHAR20;
    const CommonTokenType*    STRING21;
    const CommonTokenType*    BOOL22;

    /* Initialize rule variables
     */


        node = wn_nullptr;

    INT18       = NULL;
    FLOAT19       = NULL;
    CHAR20       = NULL;
    STRING21       = NULL;
    BOOL22       = NULL;



    {
        {
            //  WNScriptAST.g:441:5: ( INT | FLOAT | CHAR | STRING | BOOL )

            ANTLR_UINT32 alt19;

            alt19=5;

            switch ( this->LA(1) )
            {
            case INT:
                {
                    alt19=1;
                }
                break;
            case FLOAT:
                {
                    alt19=2;
                }
                break;
            case CHAR:
                {
                    alt19=3;
                }
                break;
            case STRING:
                {
                    alt19=4;
                }
                break;
            case BOOL:
                {
                    alt19=5;
                }
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 19 );
                ex->set_state( 0 );


                goto ruleconstantEx;

            }

            switch (alt19)
            {
            case 1:
                // WNScriptAST.g:441:10: INT
                {
                    INT18 =  this->matchToken(INT, &FOLLOW_INT_in_constant3031);
                    if  (this->hasException())
                    {
                        goto ruleconstantEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNConstantExpression(SC_INT, (INT18->getText()).c_str())); SetLocation(node, INT18);
                    }


                }
                break;
            case 2:
                // WNScriptAST.g:442:10: FLOAT
                {
                    FLOAT19 =  this->matchToken(FLOAT, &FOLLOW_FLOAT_in_constant3047);
                    if  (this->hasException())
                    {
                        goto ruleconstantEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNConstantExpression(SC_FLOAT, (FLOAT19->getText()).c_str())); SetLocation(node, FLOAT19);
                    }


                }
                break;
            case 3:
                // WNScriptAST.g:443:10: CHAR
                {
                    CHAR20 =  this->matchToken(CHAR, &FOLLOW_CHAR_in_constant3061);
                    if  (this->hasException())
                    {
                        goto ruleconstantEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNConstantExpression(SC_CHAR, (CHAR20->getText()).c_str())); SetLocation(node, CHAR20);
                    }


                }
                break;
            case 4:
                // WNScriptAST.g:444:10: STRING
                {
                    STRING21 =  this->matchToken(STRING, &FOLLOW_STRING_in_constant3076);
                    if  (this->hasException())
                    {
                        goto ruleconstantEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNConstantExpression(SC_STRING, (STRING21->getText()).c_str())); SetLocation(node, STRING21);
                    }


                }
                break;
            case 5:
                // WNScriptAST.g:445:9: BOOL
                {
                    BOOL22 =  this->matchToken(BOOL, &FOLLOW_BOOL_in_constant3088);
                    if  (this->hasException())
                    {
                        goto ruleconstantEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNConstantExpression(SC_BOOL, (BOOL22->getText()).c_str())); SetLocation(node, BOOL22);
                    }


                }
                break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleconstantEx; /* Prevent compiler warnings */
    ruleconstantEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end constant */

/**
 * $ANTLR start prim_ex
 * WNScriptAST.g:448:1: prim_ex returns [WNExpression * node] : ( ID |ba= LBRACKET a= expression bb= RBRACKET |b= constant |c= scalarType ( (e= structInit ) | (f= arrayInit ) ) |d= NULLTOK );
 */
WNExpression *
WNScriptASTParser::prim_ex()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNExpression * node;


    const CommonTokenType*    ba;
    const CommonTokenType*    bb;
    const CommonTokenType*    d;
    const CommonTokenType*    ID23;
    WNExpression* a;
    typedef    WNExpression* RETURN_TYPE_a;

    WNConstantExpression* b;
    typedef    WNConstantExpression* RETURN_TYPE_b;

    WNTypeNode* c;
    typedef    WNTypeNode* RETURN_TYPE_c;

    WNStructAllocation* e;
    typedef    WNStructAllocation* RETURN_TYPE_e;

    WNArrayAllocation* f;
    typedef    WNArrayAllocation* RETURN_TYPE_f;

    /* Initialize rule variables
     */


        node = wn_nullptr;

    ba       = NULL;
    bb       = NULL;
    d       = NULL;
    ID23       = NULL;



    {
        {
            //  WNScriptAST.g:452:5: ( ID |ba= LBRACKET a= expression bb= RBRACKET |b= constant |c= scalarType ( (e= structInit ) | (f= arrayInit ) ) |d= NULLTOK )

            ANTLR_UINT32 alt21;

            alt21=5;

            switch ( this->LA(1) )
            {
            case ID:
                {
                    alt21=1;
                }
                break;
            case LBRACKET:
                {
                    alt21=2;
                }
                break;
            case BOOL:
            case CHAR:
            case FLOAT:
            case INT:
            case STRING:
                {
                    alt21=3;
                }
                break;
            case TYPE:
                {
                    alt21=4;
                }
                break;
            case NULLTOK:
                {
                    alt21=5;
                }
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 21 );
                ex->set_state( 0 );


                goto ruleprim_exEx;

            }

            switch (alt21)
            {
            case 1:
                // WNScriptAST.g:452:10: ID
                {
                    ID23 =  this->matchToken(ID, &FOLLOW_ID_in_prim_ex3120);
                    if  (this->hasException())
                    {
                        goto ruleprim_exEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNIDExpression((ID23->getText()).c_str())); SetLocation(node, ID23);
                    }


                }
                break;
            case 2:
                // WNScriptAST.g:453:10: ba= LBRACKET a= expression bb= RBRACKET
                {
                    ba =  this->matchToken(LBRACKET, &FOLLOW_LBRACKET_in_prim_ex3135);
                    if  (this->hasException())
                    {
                        goto ruleprim_exEx;
                    }


                    this->followPush(FOLLOW_expression_in_prim_ex3139);
                    a=expression();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleprim_exEx;
                    }


                    bb =  this->matchToken(RBRACKET, &FOLLOW_RBRACKET_in_prim_ex3143);
                    if  (this->hasException())
                    {
                        goto ruleprim_exEx;
                    }


                    {
                        node = a
                        ; SetLocation(node, ba); SetEndLocation(node, bb);
                    }


                }
                break;
            case 3:
                // WNScriptAST.g:454:10: b= constant
                {
                    this->followPush(FOLLOW_constant_in_prim_ex3158);
                    b=constant();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleprim_exEx;
                    }


                    {
                        node = b
                        ;
                    }


                }
                break;
            case 4:
                // WNScriptAST.g:455:9: c= scalarType ( (e= structInit ) | (f= arrayInit ) )
                {
                    this->followPush(FOLLOW_scalarType_in_prim_ex3173);
                    c=scalarType();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleprim_exEx;
                    }


                    // WNScriptAST.g:456:11: ( (e= structInit ) | (f= arrayInit ) )
                    {
                        int alt20=2;
                        switch ( this->LA(1) )
                        {
                        case LBRACKET:
                            {
                                alt20=1;
                            }
                            break;
                        case LSQBRACKET:
                            {
                                alt20=2;
                            }
                            break;

                        default:
                            ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 20 );
                            ex->set_state( 0 );


                            goto ruleprim_exEx;

                        }

                        switch (alt20)
                        {
                        case 1:
                            // WNScriptAST.g:457:15: (e= structInit )
                            {
                                // WNScriptAST.g:457:15: (e= structInit )
                                // WNScriptAST.g:457:17: e= structInit
                                {
                                    this->followPush(FOLLOW_structInit_in_prim_ex3206);
                                    e=structInit();

                                    this->followPop();
                                    if  (this->hasException())
                                    {
                                        goto ruleprim_exEx;
                                    }


                                }


                                {
                                     e
                                    ->SetType(c
                                    ); node=e
                                    ; SetStartLocationFromNode(node, c
                                    );
                                }


                            }
                            break;
                        case 2:
                            // WNScriptAST.g:458:15: (f= arrayInit )
                            {
                                // WNScriptAST.g:458:15: (f= arrayInit )
                                // WNScriptAST.g:458:17: f= arrayInit
                                {
                                    this->followPush(FOLLOW_arrayInit_in_prim_ex3230);
                                    f=arrayInit();

                                    this->followPop();
                                    if  (this->hasException())
                                    {
                                        goto ruleprim_exEx;
                                    }


                                }


                                {
                                     f
                                    ->SetType(c
                                    ); node=f
                                    ; SetStartLocationFromNode(node, c
                                    );
                                }


                            }
                            break;

                        }
                    }

                }
                break;
            case 5:
                // WNScriptAST.g:460:9: d= NULLTOK
                {
                    d =  this->matchToken(NULLTOK, &FOLLOW_NULLTOK_in_prim_ex3259);
                    if  (this->hasException())
                    {
                        goto ruleprim_exEx;
                    }


                    {
                         node= WN_SCRIPTNODE_NEW(WNNullAllocation()); SetLocation(node, d);
                    }


                }
                break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleprim_exEx; /* Prevent compiler warnings */
    ruleprim_exEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end prim_ex */

/**
 * $ANTLR start structInit
 * WNScriptAST.g:463:1: structInit returns [WNStructAllocation* node] : (a= LBRACKET b= RBRACKET |c= LBRACKET d= expression e= RBRACKET );
 */
WNStructAllocation*
WNScriptASTParser::structInit()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNStructAllocation* node;


    const CommonTokenType*    a;
    const CommonTokenType*    b;
    const CommonTokenType*    c;
    const CommonTokenType*    e;
    WNExpression* d;
    typedef    WNExpression* RETURN_TYPE_d;

    /* Initialize rule variables
     */

    a       = NULL;
    b       = NULL;
    c       = NULL;
    e       = NULL;



    {
        {
            //  WNScriptAST.g:464:5: (a= LBRACKET b= RBRACKET |c= LBRACKET d= expression e= RBRACKET )

            ANTLR_UINT32 alt22;

            alt22=2;

            switch ( this->LA(1) )
            {
            case LBRACKET:
                {
                    switch ( this->LA(2) )
                    {
                    case RBRACKET:
                        {
                            alt22=1;
                        }
                        break;
                    case BOOL:
                    case CHAR:
                    case DOUBDEC:
                    case DOUBINC:
                    case FLOAT:
                    case ID:
                    case INT:
                    case LBRACKET:
                    case NULLTOK:
                    case STRING:
                    case TYPE:
                    case 51:
                        {
                            alt22=2;
                        }
                        break;

                    default:
                        ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 22 );
                        ex->set_state( 1 );


                        goto rulestructInitEx;

                    }

                }
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 22 );
                ex->set_state( 0 );


                goto rulestructInitEx;

            }

            switch (alt22)
            {
            case 1:
                // WNScriptAST.g:464:7: a= LBRACKET b= RBRACKET
                {
                    a =  this->matchToken(LBRACKET, &FOLLOW_LBRACKET_in_structInit3284);
                    if  (this->hasException())
                    {
                        goto rulestructInitEx;
                    }


                    b =  this->matchToken(RBRACKET, &FOLLOW_RBRACKET_in_structInit3288);
                    if  (this->hasException())
                    {
                        goto rulestructInitEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNStructAllocation()); SetLocation(node, a); SetEndLocation(node, b);
                    }


                }
                break;
            case 2:
                // WNScriptAST.g:465:7: c= LBRACKET d= expression e= RBRACKET
                {
                    c =  this->matchToken(LBRACKET, &FOLLOW_LBRACKET_in_structInit3300);
                    if  (this->hasException())
                    {
                        goto rulestructInitEx;
                    }


                    this->followPush(FOLLOW_expression_in_structInit3304);
                    d=expression();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto rulestructInitEx;
                    }


                    e =  this->matchToken(RBRACKET, &FOLLOW_RBRACKET_in_structInit3308);
                    if  (this->hasException())
                    {
                        goto rulestructInitEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNStructAllocation()); node->SetCopyInitializer(d); SetLocation(node, c); SetEndLocation(node, e);
                    }


                }
                break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulestructInitEx; /* Prevent compiler warnings */
    rulestructInitEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end structInit */

/**
 * $ANTLR start arrayInit
 * WNScriptAST.g:468:1: arrayInit returns [WNArrayAllocation* node] : ( ( ( LSQBRACKET e= expression RSQBRACKET )+ ( LSQBRACKET RSQBRACKET )* ) | ( LSQBRACKET RSQBRACKET )+ ) ( ( LBRACKET a= RBRACKET ) | ( LBRACKET b= expression c= RBRACKET ) ) ;
 */
WNArrayAllocation*
WNScriptASTParser::arrayInit()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNArrayAllocation* node;


    const CommonTokenType*    a;
    const CommonTokenType*    c;
    WNExpression* e;
    typedef    WNExpression* RETURN_TYPE_e;

    WNExpression* b;
    typedef    WNExpression* RETURN_TYPE_b;

    /* Initialize rule variables
     */


        node = WN_SCRIPTNODE_NEW(WNArrayAllocation());

    a       = NULL;
    c       = NULL;



    {
        // WNScriptAST.g:472:5: ( ( ( ( LSQBRACKET e= expression RSQBRACKET )+ ( LSQBRACKET RSQBRACKET )* ) | ( LSQBRACKET RSQBRACKET )+ ) ( ( LBRACKET a= RBRACKET ) | ( LBRACKET b= expression c= RBRACKET ) ) )
        // WNScriptAST.g:472:9: ( ( ( LSQBRACKET e= expression RSQBRACKET )+ ( LSQBRACKET RSQBRACKET )* ) | ( LSQBRACKET RSQBRACKET )+ ) ( ( LBRACKET a= RBRACKET ) | ( LBRACKET b= expression c= RBRACKET ) )
        {
            // WNScriptAST.g:472:9: ( ( ( LSQBRACKET e= expression RSQBRACKET )+ ( LSQBRACKET RSQBRACKET )* ) | ( LSQBRACKET RSQBRACKET )+ )
            {
                int alt26=2;
                switch ( this->LA(1) )
                {
                case LSQBRACKET:
                    {
                        switch ( this->LA(2) )
                        {
                        case RSQBRACKET:
                            {
                                alt26=2;
                            }
                            break;
                        case BOOL:
                        case CHAR:
                        case DOUBDEC:
                        case DOUBINC:
                        case FLOAT:
                        case ID:
                        case INT:
                        case LBRACKET:
                        case NULLTOK:
                        case STRING:
                        case TYPE:
                        case 51:
                            {
                                alt26=1;
                            }
                            break;

                        default:
                            ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 26 );
                            ex->set_state( 1 );


                            goto rulearrayInitEx;

                        }

                    }
                    break;

                default:
                    ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 26 );
                    ex->set_state( 0 );


                    goto rulearrayInitEx;

                }

                switch (alt26)
                {
                case 1:
                    // WNScriptAST.g:473:13: ( ( LSQBRACKET e= expression RSQBRACKET )+ ( LSQBRACKET RSQBRACKET )* )
                    {
                        // WNScriptAST.g:473:13: ( ( LSQBRACKET e= expression RSQBRACKET )+ ( LSQBRACKET RSQBRACKET )* )
                        // WNScriptAST.g:474:17: ( LSQBRACKET e= expression RSQBRACKET )+ ( LSQBRACKET RSQBRACKET )*
                        {
                            // WNScriptAST.g:474:17: ( LSQBRACKET e= expression RSQBRACKET )+
                            {
                                int cnt23=0;

                                for (;;)
                                {
                                    int alt23=2;
                                switch ( this->LA(1) )
                                {
                                case LSQBRACKET:
                                    {
                                        switch ( this->LA(2) )
                                        {
                                        case BOOL:
                                        case CHAR:
                                        case DOUBDEC:
                                        case DOUBINC:
                                        case FLOAT:
                                        case ID:
                                        case INT:
                                        case LBRACKET:
                                        case NULLTOK:
                                        case STRING:
                                        case TYPE:
                                        case 51:
                                            {
                                                alt23=1;
                                            }
                                            break;

                                        }

                                    }
                                    break;

                                }

                                switch (alt23)
                                {
                                    case 1:
                                        // WNScriptAST.g:474:18: LSQBRACKET e= expression RSQBRACKET
                                        {
                                             this->matchToken(LSQBRACKET, &FOLLOW_LSQBRACKET_in_arrayInit3370);
                                            if  (this->hasException())
                                            {
                                                goto rulearrayInitEx;
                                            }


                                            this->followPush(FOLLOW_expression_in_arrayInit3374);
                                            e=expression();

                                            this->followPop();
                                            if  (this->hasException())
                                            {
                                                goto rulearrayInitEx;
                                            }


                                             this->matchToken(RSQBRACKET, &FOLLOW_RSQBRACKET_in_arrayInit3376);
                                            if  (this->hasException())
                                            {
                                                goto rulearrayInitEx;
                                            }


                                            {
                                                 node->AddExpression(e
                                                );
                                            }


                                        }
                                        break;

                                    default:

                                    if ( cnt23 >= 1 )
                                    {
                                        goto loop23;
                                    }
                                    /* mismatchedSetEx()
                                     */
                                    new ANTLR_Exception< WNScriptASTParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


                                    goto rulearrayInitEx;
                                }
                                cnt23++;
                                }
                                loop23: ;    /* Jump to here if this rule does not match */
                            }

                            // WNScriptAST.g:475:17: ( LSQBRACKET RSQBRACKET )*

                            for (;;)
                            {
                                int alt24=2;
                                switch ( this->LA(1) )
                                {
                                case LSQBRACKET:
                                    {
                                        alt24=1;
                                    }
                                    break;

                                }

                                switch (alt24)
                                {
                                case 1:
                                    // WNScriptAST.g:475:18: LSQBRACKET RSQBRACKET
                                    {
                                         this->matchToken(LSQBRACKET, &FOLLOW_LSQBRACKET_in_arrayInit3400);
                                        if  (this->hasException())
                                        {
                                            goto rulearrayInitEx;
                                        }


                                         this->matchToken(RSQBRACKET, &FOLLOW_RSQBRACKET_in_arrayInit3402);
                                        if  (this->hasException())
                                        {
                                            goto rulearrayInitEx;
                                        }


                                        {
                                             node->AddLevel();
                                        }


                                    }
                                    break;

                                default:
                                    goto loop24;    /* break out of the loop */
                                    break;
                                }
                            }
                            loop24: ; /* Jump out to here if this rule does not match */


                        }


                    }
                    break;
                case 2:
                    // WNScriptAST.g:477:17: ( LSQBRACKET RSQBRACKET )+
                    {
                        // WNScriptAST.g:477:17: ( LSQBRACKET RSQBRACKET )+
                        {
                            int cnt25=0;

                            for (;;)
                            {
                                int alt25=2;
                            switch ( this->LA(1) )
                            {
                            case LSQBRACKET:
                                {
                                    alt25=1;
                                }
                                break;

                            }

                            switch (alt25)
                            {
                                case 1:
                                    // WNScriptAST.g:477:18: LSQBRACKET RSQBRACKET
                                    {
                                         this->matchToken(LSQBRACKET, &FOLLOW_LSQBRACKET_in_arrayInit3440);
                                        if  (this->hasException())
                                        {
                                            goto rulearrayInitEx;
                                        }


                                         this->matchToken(RSQBRACKET, &FOLLOW_RSQBRACKET_in_arrayInit3442);
                                        if  (this->hasException())
                                        {
                                            goto rulearrayInitEx;
                                        }


                                        {
                                             node->AddLevel();
                                        }


                                    }
                                    break;

                                default:

                                if ( cnt25 >= 1 )
                                {
                                    goto loop25;
                                }
                                /* mismatchedSetEx()
                                 */
                                new ANTLR_Exception< WNScriptASTParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


                                goto rulearrayInitEx;
                            }
                            cnt25++;
                            }
                            loop25: ;    /* Jump to here if this rule does not match */
                        }

                    }
                    break;

                }
            }

            // WNScriptAST.g:479:9: ( ( LBRACKET a= RBRACKET ) | ( LBRACKET b= expression c= RBRACKET ) )
            {
                int alt27=2;
                switch ( this->LA(1) )
                {
                case LBRACKET:
                    {
                        switch ( this->LA(2) )
                        {
                        case RBRACKET:
                            {
                                alt27=1;
                            }
                            break;
                        case BOOL:
                        case CHAR:
                        case DOUBDEC:
                        case DOUBINC:
                        case FLOAT:
                        case ID:
                        case INT:
                        case LBRACKET:
                        case NULLTOK:
                        case STRING:
                        case TYPE:
                        case 51:
                            {
                                alt27=2;
                            }
                            break;

                        default:
                            ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 27 );
                            ex->set_state( 1 );


                            goto rulearrayInitEx;

                        }

                    }
                    break;

                default:
                    ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 27 );
                    ex->set_state( 0 );


                    goto rulearrayInitEx;

                }

                switch (alt27)
                {
                case 1:
                    // WNScriptAST.g:480:13: ( LBRACKET a= RBRACKET )
                    {
                        // WNScriptAST.g:480:13: ( LBRACKET a= RBRACKET )
                        // WNScriptAST.g:480:15: LBRACKET a= RBRACKET
                        {
                             this->matchToken(LBRACKET, &FOLLOW_LBRACKET_in_arrayInit3486);
                            if  (this->hasException())
                            {
                                goto rulearrayInitEx;
                            }


                            a =  this->matchToken(RBRACKET, &FOLLOW_RBRACKET_in_arrayInit3490);
                            if  (this->hasException())
                            {
                                goto rulearrayInitEx;
                            }


                            {
                                 SetLocation(node, a);
                            }


                        }


                    }
                    break;
                case 2:
                    // WNScriptAST.g:482:13: ( LBRACKET b= expression c= RBRACKET )
                    {
                        // WNScriptAST.g:482:13: ( LBRACKET b= expression c= RBRACKET )
                        // WNScriptAST.g:482:15: LBRACKET b= expression c= RBRACKET
                        {
                             this->matchToken(LBRACKET, &FOLLOW_LBRACKET_in_arrayInit3524);
                            if  (this->hasException())
                            {
                                goto rulearrayInitEx;
                            }


                            this->followPush(FOLLOW_expression_in_arrayInit3528);
                            b=expression();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto rulearrayInitEx;
                            }


                            c =  this->matchToken(RBRACKET, &FOLLOW_RBRACKET_in_arrayInit3532);
                            if  (this->hasException())
                            {
                                goto rulearrayInitEx;
                            }


                            {
                                 node->SetCopyInitializer(b); SetLocation(node, c);
                            }


                        }


                    }
                    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulearrayInitEx; /* Prevent compiler warnings */
    rulearrayInitEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end arrayInit */

/**
 * $ANTLR start declaration
 * WNScriptAST.g:487:1: declaration returns [WNDeclaration* node] : a= decl ( ( '=' ( (c= expression ) ) ) | ( '<==' ( (d= expression ) ) ) ) ;
 */
WNDeclaration*
WNScriptASTParser::declaration()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNDeclaration* node;


    WNDeclaration* a;
    typedef    WNDeclaration* RETURN_TYPE_a;

    WNExpression* c;
    typedef    WNExpression* RETURN_TYPE_c;

    WNExpression* d;
    typedef    WNExpression* RETURN_TYPE_d;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        // WNScriptAST.g:491:5: (a= decl ( ( '=' ( (c= expression ) ) ) | ( '<==' ( (d= expression ) ) ) ) )
        // WNScriptAST.g:491:10: a= decl ( ( '=' ( (c= expression ) ) ) | ( '<==' ( (d= expression ) ) ) )
        {
            this->followPush(FOLLOW_decl_in_declaration3577);
            a=decl();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledeclarationEx;
            }


            {
                 node = a
                ;
            }


            // WNScriptAST.g:492:13: ( ( '=' ( (c= expression ) ) ) | ( '<==' ( (d= expression ) ) ) )
            {
                int alt28=2;
                switch ( this->LA(1) )
                {
                case 58:
                    {
                        alt28=1;
                    }
                    break;
                case CHOWN:
                    {
                        alt28=2;
                    }
                    break;

                default:
                    ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 28 );
                    ex->set_state( 0 );


                    goto ruledeclarationEx;

                }

                switch (alt28)
                {
                case 1:
                    // WNScriptAST.g:493:17: ( '=' ( (c= expression ) ) )
                    {
                        // WNScriptAST.g:493:17: ( '=' ( (c= expression ) ) )
                        // WNScriptAST.g:493:18: '=' ( (c= expression ) )
                        {
                             this->matchToken(58, &FOLLOW_58_in_declaration3612);
                            if  (this->hasException())
                            {
                                goto ruledeclarationEx;
                            }


                            // WNScriptAST.g:493:22: ( (c= expression ) )
                            // WNScriptAST.g:493:24: (c= expression )
                            {
                                // WNScriptAST.g:493:24: (c= expression )
                                // WNScriptAST.g:493:25: c= expression
                                {
                                    this->followPush(FOLLOW_expression_in_declaration3619);
                                    c=expression();

                                    this->followPop();
                                    if  (this->hasException())
                                    {
                                        goto ruledeclarationEx;
                                    }


                                }


                                {
                                     node->AddExpressionInitializer(c
                                    ); SetEndLocationFromNode(node, c
                                    );
                                }


                            }


                        }


                    }
                    break;
                case 2:
                    // WNScriptAST.g:494:17: ( '<==' ( (d= expression ) ) )
                    {
                        // WNScriptAST.g:494:17: ( '<==' ( (d= expression ) ) )
                        // WNScriptAST.g:494:18: '<==' ( (d= expression ) )
                        {
                             this->matchToken(CHOWN, &FOLLOW_CHOWN_in_declaration3645);
                            if  (this->hasException())
                            {
                                goto ruledeclarationEx;
                            }


                            // WNScriptAST.g:494:24: ( (d= expression ) )
                            // WNScriptAST.g:494:26: (d= expression )
                            {
                                // WNScriptAST.g:494:26: (d= expression )
                                // WNScriptAST.g:494:27: d= expression
                                {
                                    this->followPush(FOLLOW_expression_in_declaration3652);
                                    d=expression();

                                    this->followPop();
                                    if  (this->hasException())
                                    {
                                        goto ruledeclarationEx;
                                    }


                                }


                                {
                                     node->AddExpressionInitializer(d
                                    , true); SetEndLocationFromNode(node, d
                                    );
                                }


                            }


                        }


                    }
                    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruledeclarationEx; /* Prevent compiler warnings */
    ruledeclarationEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end declaration */

/**
 * $ANTLR start instructionScalar
 * WNScriptAST.g:498:1: instructionScalar returns [WNInstruction* node] : ( declaration | assignment );
 */
WNInstruction*
WNScriptASTParser::instructionScalar()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNInstruction* node;


    WNDeclaration* declaration24;
    typedef    WNDeclaration* RETURN_TYPE_declaration24;

    WNAssignment* assignment25;
    typedef    WNAssignment* RETURN_TYPE_assignment25;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        {
            //  WNScriptAST.g:502:5: ( declaration | assignment )

            ANTLR_UINT32 alt29;

            alt29=2;

            alt29 = cdfa29.predict(this, this->get_rec(), this->get_istream(), cdfa29 );
            if  (this->hasException())
            {
                goto ruleinstructionScalarEx;
            }

            switch (alt29)
            {
            case 1:
                // WNScriptAST.g:502:10: declaration
                {
                    this->followPush(FOLLOW_declaration_in_instructionScalar3702);
                    declaration24=declaration();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleinstructionScalarEx;
                    }


                    {
                        node = declaration24
                        ;
                    }


                }
                break;
            case 2:
                // WNScriptAST.g:503:10: assignment
                {
                    this->followPush(FOLLOW_assignment_in_instructionScalar3715);
                    assignment25=assignment();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleinstructionScalarEx;
                    }


                    {
                        node = assignment25
                        ;
                    }


                }
                break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleinstructionScalarEx; /* Prevent compiler warnings */
    ruleinstructionScalarEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end instructionScalar */

/**
 * $ANTLR start returnInst
 * WNScriptAST.g:506:1: returnInst returns [WNReturn* node] : (a= RETURN expression b= SEMICOLON |c= RETURN d= SEMICOLON |e= RETURN_OWN expression f= SEMICOLON );
 */
WNReturn*
WNScriptASTParser::returnInst()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNReturn* node;


    const CommonTokenType*    a;
    const CommonTokenType*    b;
    const CommonTokenType*    c;
    const CommonTokenType*    d;
    const CommonTokenType*    e;
    const CommonTokenType*    f;
    WNExpression* expression26;
    typedef    WNExpression* RETURN_TYPE_expression26;

    WNExpression* expression27;
    typedef    WNExpression* RETURN_TYPE_expression27;

    /* Initialize rule variables
     */


        node = wn_nullptr;

    a       = NULL;
    b       = NULL;
    c       = NULL;
    d       = NULL;
    e       = NULL;
    f       = NULL;



    {
        {
            //  WNScriptAST.g:510:5: (a= RETURN expression b= SEMICOLON |c= RETURN d= SEMICOLON |e= RETURN_OWN expression f= SEMICOLON )

            ANTLR_UINT32 alt30;

            alt30=3;

            switch ( this->LA(1) )
            {
            case RETURN:
                {
                    switch ( this->LA(2) )
                    {
                    case SEMICOLON:
                        {
                            alt30=2;
                        }
                        break;
                    case BOOL:
                    case CHAR:
                    case DOUBDEC:
                    case DOUBINC:
                    case FLOAT:
                    case ID:
                    case INT:
                    case LBRACKET:
                    case NULLTOK:
                    case STRING:
                    case TYPE:
                    case 51:
                        {
                            alt30=1;
                        }
                        break;

                    default:
                        ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 30 );
                        ex->set_state( 1 );


                        goto rulereturnInstEx;

                    }

                }
                break;
            case RETURN_OWN:
                {
                    alt30=3;
                }
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 30 );
                ex->set_state( 0 );


                goto rulereturnInstEx;

            }

            switch (alt30)
            {
            case 1:
                // WNScriptAST.g:510:9: a= RETURN expression b= SEMICOLON
                {
                    a =  this->matchToken(RETURN, &FOLLOW_RETURN_in_returnInst3747);
                    if  (this->hasException())
                    {
                        goto rulereturnInstEx;
                    }


                    this->followPush(FOLLOW_expression_in_returnInst3749);
                    expression26=expression();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto rulereturnInstEx;
                    }


                    b =  this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_returnInst3753);
                    if  (this->hasException())
                    {
                        goto rulereturnInstEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNReturn(expression26
                        )); SetLocation(node, a); SetEndLocation(node, b);
                    }


                }
                break;
            case 2:
                // WNScriptAST.g:511:9: c= RETURN d= SEMICOLON
                {
                    c =  this->matchToken(RETURN, &FOLLOW_RETURN_in_returnInst3767);
                    if  (this->hasException())
                    {
                        goto rulereturnInstEx;
                    }


                    d =  this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_returnInst3771);
                    if  (this->hasException())
                    {
                        goto rulereturnInstEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNReturn()); SetLocation(node, c); SetEndLocation(node, d);
                    }


                }
                break;
            case 3:
                // WNScriptAST.g:512:9: e= RETURN_OWN expression f= SEMICOLON
                {
                    e =  this->matchToken(RETURN_OWN, &FOLLOW_RETURN_OWN_in_returnInst3785);
                    if  (this->hasException())
                    {
                        goto rulereturnInstEx;
                    }


                    this->followPush(FOLLOW_expression_in_returnInst3787);
                    expression27=expression();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto rulereturnInstEx;
                    }


                    f =  this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_returnInst3791);
                    if  (this->hasException())
                    {
                        goto rulereturnInstEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNReturn(expression27
                        , true)); SetLocation(node, e); SetEndLocation(node, f);
                    }


                }
                break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulereturnInstEx; /* Prevent compiler warnings */
    rulereturnInstEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end returnInst */

/**
 * $ANTLR start whileInst
 * WNScriptAST.g:515:1: whileInst returns [WNInstruction* node] : WHILE LBRACKET expression RBRACKET body ;
 */
WNInstruction*
WNScriptASTParser::whileInst()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNInstruction* node;


    const CommonTokenType*    WHILE30;
    WNExpression* expression28;
    typedef    WNExpression* RETURN_TYPE_expression28;

    WNInstructionList* body29;
    typedef    WNInstructionList* RETURN_TYPE_body29;

    /* Initialize rule variables
     */


        node = wn_nullptr;

    WHILE30       = NULL;



    {
        // WNScriptAST.g:519:9: ( WHILE LBRACKET expression RBRACKET body )
        // WNScriptAST.g:519:14: WHILE LBRACKET expression RBRACKET body
        {
            WHILE30 =  this->matchToken(WHILE, &FOLLOW_WHILE_in_whileInst3841);
            if  (this->hasException())
            {
                goto rulewhileInstEx;
            }


             this->matchToken(LBRACKET, &FOLLOW_LBRACKET_in_whileInst3843);
            if  (this->hasException())
            {
                goto rulewhileInstEx;
            }


            this->followPush(FOLLOW_expression_in_whileInst3845);
            expression28=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulewhileInstEx;
            }


             this->matchToken(RBRACKET, &FOLLOW_RBRACKET_in_whileInst3847);
            if  (this->hasException())
            {
                goto rulewhileInstEx;
            }


            this->followPush(FOLLOW_body_in_whileInst3849);
            body29=body();

            this->followPop();
            if  (this->hasException())
            {
                goto rulewhileInstEx;
            }


            {
                 node = WN_SCRIPTNODE_NEW(WNWhileInstruction(expression28
                , body29
                )); SetLocation(node, WHILE30); SetEndLocationFromNode(node,
                body29
                );
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewhileInstEx; /* Prevent compiler warnings */
    rulewhileInstEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end whileInst */

/**
 * $ANTLR start doInst
 * WNScriptAST.g:521:1: doInst returns [WNInstruction* node] : DO body WHILE LBRACKET expression RBRACKET SEMICOLON ;
 */
WNInstruction*
WNScriptASTParser::doInst()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNInstruction* node;


    const CommonTokenType*    DO33;
    const CommonTokenType*    SEMICOLON34;
    WNExpression* expression31;
    typedef    WNExpression* RETURN_TYPE_expression31;

    WNInstructionList* body32;
    typedef    WNInstructionList* RETURN_TYPE_body32;

    /* Initialize rule variables
     */


        node = wn_nullptr;

    DO33       = NULL;
    SEMICOLON34       = NULL;



    {
        // WNScriptAST.g:525:5: ( DO body WHILE LBRACKET expression RBRACKET SEMICOLON )
        // WNScriptAST.g:525:10: DO body WHILE LBRACKET expression RBRACKET SEMICOLON
        {
            DO33 =  this->matchToken(DO, &FOLLOW_DO_in_doInst3885);
            if  (this->hasException())
            {
                goto ruledoInstEx;
            }


            this->followPush(FOLLOW_body_in_doInst3887);
            body32=body();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledoInstEx;
            }


             this->matchToken(WHILE, &FOLLOW_WHILE_in_doInst3889);
            if  (this->hasException())
            {
                goto ruledoInstEx;
            }


             this->matchToken(LBRACKET, &FOLLOW_LBRACKET_in_doInst3891);
            if  (this->hasException())
            {
                goto ruledoInstEx;
            }


            this->followPush(FOLLOW_expression_in_doInst3893);
            expression31=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledoInstEx;
            }


             this->matchToken(RBRACKET, &FOLLOW_RBRACKET_in_doInst3895);
            if  (this->hasException())
            {
                goto ruledoInstEx;
            }


            SEMICOLON34 =  this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_doInst3897);
            if  (this->hasException())
            {
                goto ruledoInstEx;
            }


            {
                node = WN_SCRIPTNODE_NEW(WNDoInstruction(expression31
                , body32
                )); SetLocation(node, DO33); SetEndLocation(node, SEMICOLON34);
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledoInstEx; /* Prevent compiler warnings */
    ruledoInstEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end doInst */

/**
 * $ANTLR start forInst
 * WNScriptAST.g:528:1: forInst returns [WNInstruction* node] : FOR LBRACKET (a= instructionScalar )? SEMICOLON (b= expression )? SEMICOLON (c= instructionScalar )? RBRACKET (d= body ) ;
 */
WNInstruction*
WNScriptASTParser::forInst()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNInstruction* node;


    const CommonTokenType*    FOR35;
    WNInstruction* a;
    typedef    WNInstruction* RETURN_TYPE_a;

    WNExpression* b;
    typedef    WNExpression* RETURN_TYPE_b;

    WNInstruction* c;
    typedef    WNInstruction* RETURN_TYPE_c;

    WNInstructionList* d;
    typedef    WNInstructionList* RETURN_TYPE_d;

    /* Initialize rule variables
     */


        WNForInstruction* forNode = WN_SCRIPTNODE_NEW(WNForInstruction());
        node = forNode;

    FOR35       = NULL;



    {
        // WNScriptAST.g:533:5: ( FOR LBRACKET (a= instructionScalar )? SEMICOLON (b= expression )? SEMICOLON (c= instructionScalar )? RBRACKET (d= body ) )
        // WNScriptAST.g:533:10: FOR LBRACKET (a= instructionScalar )? SEMICOLON (b= expression )? SEMICOLON (c= instructionScalar )? RBRACKET (d= body )
        {
            FOR35 =  this->matchToken(FOR, &FOLLOW_FOR_in_forInst3929);
            if  (this->hasException())
            {
                goto ruleforInstEx;
            }


             this->matchToken(LBRACKET, &FOLLOW_LBRACKET_in_forInst3931);
            if  (this->hasException())
            {
                goto ruleforInstEx;
            }


            {
                 SetLocation(forNode, FOR35);
            }


            // WNScriptAST.g:534:21: (a= instructionScalar )?
            {
                int alt31=2;
                switch ( this->LA(1) )
                {
                    case BOOL:
                    case CHAR:
                    case DOUBDEC:
                    case DOUBINC:
                    case FLOAT:
                    case ID:
                    case INT:
                    case LBRACKET:
                    case NULLTOK:
                    case STRING:
                    case TYPE:
                    case 51:
                        {
                            alt31=1;
                        }
                        break;
                }

                switch (alt31)
                {
                case 1:
                    // WNScriptAST.g:534:22: a= instructionScalar
                    {
                        this->followPush(FOLLOW_instructionScalar_in_forInst3959);
                        a=instructionScalar();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleforInstEx;
                        }


                        {
                            forNode->AddInitializer(a
                            );
                        }


                    }
                    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_forInst3965);
            if  (this->hasException())
            {
                goto ruleforInstEx;
            }


            // WNScriptAST.g:535:21: (b= expression )?
            {
                int alt32=2;
                switch ( this->LA(1) )
                {
                    case BOOL:
                    case CHAR:
                    case DOUBDEC:
                    case DOUBINC:
                    case FLOAT:
                    case ID:
                    case INT:
                    case LBRACKET:
                    case NULLTOK:
                    case STRING:
                    case TYPE:
                    case 51:
                        {
                            alt32=1;
                        }
                        break;
                }

                switch (alt32)
                {
                case 1:
                    // WNScriptAST.g:535:22: b= expression
                    {
                        this->followPush(FOLLOW_expression_in_forInst3990);
                        b=expression();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleforInstEx;
                        }


                        {
                            forNode->AddCondition(b
                            );
                        }


                    }
                    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_forInst4004);
            if  (this->hasException())
            {
                goto ruleforInstEx;
            }


            // WNScriptAST.g:536:21: (c= instructionScalar )?
            {
                int alt33=2;
                switch ( this->LA(1) )
                {
                    case BOOL:
                    case CHAR:
                    case DOUBDEC:
                    case DOUBINC:
                    case FLOAT:
                    case ID:
                    case INT:
                    case LBRACKET:
                    case NULLTOK:
                    case STRING:
                    case TYPE:
                    case 51:
                        {
                            alt33=1;
                        }
                        break;
                }

                switch (alt33)
                {
                case 1:
                    // WNScriptAST.g:536:22: c= instructionScalar
                    {
                        this->followPush(FOLLOW_instructionScalar_in_forInst4030);
                        c=instructionScalar();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleforInstEx;
                        }


                        {
                            forNode->AddPostOp(c
                            );
                        }


                    }
                    break;

                }
            }

             this->matchToken(RBRACKET, &FOLLOW_RBRACKET_in_forInst4036);
            if  (this->hasException())
            {
                goto ruleforInstEx;
            }


            // WNScriptAST.g:537:21: (d= body )
            // WNScriptAST.g:537:22: d= body
            {
                this->followPush(FOLLOW_body_in_forInst4062);
                d=body();

                this->followPop();
                if  (this->hasException())
                {
                    goto ruleforInstEx;
                }


                {
                    forNode->AddBody(d
                    ); SetEndLocationFromNode(forNode, d
                    );
                }


            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleforInstEx; /* Prevent compiler warnings */
    ruleforInstEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end forInst */

/**
 * $ANTLR start elsemiddle
 * WNScriptAST.g:541:1: elsemiddle returns [WNElseIf* node] : ELSE IF LBRACKET expression RBRACKET body ;
 */
WNElseIf*
WNScriptASTParser::elsemiddle()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNElseIf* node;


    const CommonTokenType*    ELSE38;
    WNExpression* expression36;
    typedef    WNExpression* RETURN_TYPE_expression36;

    WNInstructionList* body37;
    typedef    WNInstructionList* RETURN_TYPE_body37;

    /* Initialize rule variables
     */


        node = wn_nullptr;

    ELSE38       = NULL;



    {
        // WNScriptAST.g:545:5: ( ELSE IF LBRACKET expression RBRACKET body )
        // WNScriptAST.g:545:10: ELSE IF LBRACKET expression RBRACKET body
        {
            ELSE38 =  this->matchToken(ELSE, &FOLLOW_ELSE_in_elsemiddle4119);
            if  (this->hasException())
            {
                goto ruleelsemiddleEx;
            }


             this->matchToken(IF, &FOLLOW_IF_in_elsemiddle4121);
            if  (this->hasException())
            {
                goto ruleelsemiddleEx;
            }


             this->matchToken(LBRACKET, &FOLLOW_LBRACKET_in_elsemiddle4123);
            if  (this->hasException())
            {
                goto ruleelsemiddleEx;
            }


            this->followPush(FOLLOW_expression_in_elsemiddle4125);
            expression36=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleelsemiddleEx;
            }


             this->matchToken(RBRACKET, &FOLLOW_RBRACKET_in_elsemiddle4127);
            if  (this->hasException())
            {
                goto ruleelsemiddleEx;
            }


            this->followPush(FOLLOW_body_in_elsemiddle4129);
            body37=body();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleelsemiddleEx;
            }


            {
                 node = WN_SCRIPTNODE_NEW(WNElseIf(expression36
                , body37
                )); SetLocation(node, ELSE38); SetEndLocationFromNode(node,
                body37
                );
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleelsemiddleEx; /* Prevent compiler warnings */
    ruleelsemiddleEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end elsemiddle */

/**
 * $ANTLR start endif
 * WNScriptAST.g:548:1: endif returns [WNInstructionList* node] : 'else' body ;
 */
WNInstructionList*
WNScriptASTParser::endif()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNInstructionList* node;


    WNInstructionList* body39;
    typedef    WNInstructionList* RETURN_TYPE_body39;

    /* Initialize rule variables
     */


        node = wn_nullptr;



    {
        // WNScriptAST.g:552:5: ( 'else' body )
        // WNScriptAST.g:552:10: 'else' body
        {
             this->matchToken(ELSE, &FOLLOW_ELSE_in_endif4168);
            if  (this->hasException())
            {
                goto ruleendifEx;
            }


            this->followPush(FOLLOW_body_in_endif4170);
            body39=body();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleendifEx;
            }


            {
                node = body39
                ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleendifEx; /* Prevent compiler warnings */
    ruleendifEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end endif */

/**
 * $ANTLR start ifInst
 * WNScriptAST.g:555:1: ifInst returns [WNInstruction* node] : IF LBRACKET expression RBRACKET body ( elsemiddle )* ( endif )? ;
 */
WNInstruction*
WNScriptASTParser::ifInst()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNInstruction* node;


    const CommonTokenType*    IF42;
    WNExpression* expression40;
    typedef    WNExpression* RETURN_TYPE_expression40;

    WNInstructionList* body41;
    typedef    WNInstructionList* RETURN_TYPE_body41;

    WNElseIf* elsemiddle43;
    typedef    WNElseIf* RETURN_TYPE_elsemiddle43;

    WNInstructionList* endif44;
    typedef    WNInstructionList* RETURN_TYPE_endif44;

    /* Initialize rule variables
     */


        WNIFInstruction* inst;
        node = wn_nullptr;

    IF42       = NULL;



    {
        // WNScriptAST.g:560:5: ( IF LBRACKET expression RBRACKET body ( elsemiddle )* ( endif )? )
        // WNScriptAST.g:560:10: IF LBRACKET expression RBRACKET body ( elsemiddle )* ( endif )?
        {
            IF42 =  this->matchToken(IF, &FOLLOW_IF_in_ifInst4204);
            if  (this->hasException())
            {
                goto ruleifInstEx;
            }


             this->matchToken(LBRACKET, &FOLLOW_LBRACKET_in_ifInst4206);
            if  (this->hasException())
            {
                goto ruleifInstEx;
            }


            this->followPush(FOLLOW_expression_in_ifInst4208);
            expression40=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleifInstEx;
            }


             this->matchToken(RBRACKET, &FOLLOW_RBRACKET_in_ifInst4210);
            if  (this->hasException())
            {
                goto ruleifInstEx;
            }


            this->followPush(FOLLOW_body_in_ifInst4212);
            body41=body();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleifInstEx;
            }


            {
                inst = WN_SCRIPTNODE_NEW(WNIFInstruction(expression40
                , body41
                )); node = inst; SetLocation(node, IF42); SetEndLocationFromNode(node,
                body41
                );
            }


            // WNScriptAST.g:561:13: ( elsemiddle )*

            for (;;)
            {
                int alt34=2;
                switch ( this->LA(1) )
                {
                case ELSE:
                    {
                        switch ( this->LA(2) )
                        {
                        case IF:
                            {
                                alt34=1;
                            }
                            break;

                        }

                    }
                    break;

                }

                switch (alt34)
                {
                case 1:
                    // WNScriptAST.g:561:14: elsemiddle
                    {
                        this->followPush(FOLLOW_elsemiddle_in_ifInst4230);
                        elsemiddle43=elsemiddle();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleifInstEx;
                        }


                        {
                            inst->AddElseIf(elsemiddle43
                            ); SetEndLocationFromNode(node, elsemiddle43
                            );
                        }


                    }
                    break;

                default:
                    goto loop34;    /* break out of the loop */
                    break;
                }
            }
            loop34: ; /* Jump out to here if this rule does not match */


            // WNScriptAST.g:562:13: ( endif )?
            {
                int alt35=2;
                switch ( this->LA(1) )
                {
                    case ELSE:
                        {
                            alt35=1;
                        }
                        break;
                }

                switch (alt35)
                {
                case 1:
                    // WNScriptAST.g:562:14: endif
                    {
                        this->followPush(FOLLOW_endif_in_ifInst4251);
                        endif44=endif();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleifInstEx;
                        }


                        {
                            inst->AddElse(endif44
                            ); SetLocation(node, IF42); SetEndLocationFromNode(node,
                            endif44
                            );
                        }


                    }
                    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleifInstEx; /* Prevent compiler warnings */
    ruleifInstEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end ifInst */

/**
 * $ANTLR start instruction
 * WNScriptAST.g:565:1: instruction returns [WNInstruction* node] : ( ifInst | whileInst | doInst | forInst | instructionScalar ';' | returnInst );
 */
WNInstruction*
WNScriptASTParser::instruction()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNInstruction* node;


    WNInstruction* ifInst45;
    typedef    WNInstruction* RETURN_TYPE_ifInst45;

    WNInstruction* whileInst46;
    typedef    WNInstruction* RETURN_TYPE_whileInst46;

    WNInstruction* doInst47;
    typedef    WNInstruction* RETURN_TYPE_doInst47;

    WNInstruction* forInst48;
    typedef    WNInstruction* RETURN_TYPE_forInst48;

    WNInstruction* instructionScalar49;
    typedef    WNInstruction* RETURN_TYPE_instructionScalar49;

    WNReturn* returnInst50;
    typedef    WNReturn* RETURN_TYPE_returnInst50;

    /* Initialize rule variables
     */





    {
        {
            //  WNScriptAST.g:568:5: ( ifInst | whileInst | doInst | forInst | instructionScalar ';' | returnInst )

            ANTLR_UINT32 alt36;

            alt36=6;

            switch ( this->LA(1) )
            {
            case IF:
                {
                    alt36=1;
                }
                break;
            case WHILE:
                {
                    alt36=2;
                }
                break;
            case DO:
                {
                    alt36=3;
                }
                break;
            case FOR:
                {
                    alt36=4;
                }
                break;
            case BOOL:
            case CHAR:
            case DOUBDEC:
            case DOUBINC:
            case FLOAT:
            case ID:
            case INT:
            case LBRACKET:
            case NULLTOK:
            case STRING:
            case TYPE:
            case 51:
                {
                    alt36=5;
                }
                break;
            case RETURN:
            case RETURN_OWN:
                {
                    alt36=6;
                }
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 36 );
                ex->set_state( 0 );


                goto ruleinstructionEx;

            }

            switch (alt36)
            {
            case 1:
                // WNScriptAST.g:568:10: ifInst
                {
                    this->followPush(FOLLOW_ifInst_in_instruction4285);
                    ifInst45=ifInst();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleinstructionEx;
                    }


                    {
                         node = ifInst45
                        ;
                    }


                }
                break;
            case 2:
                // WNScriptAST.g:569:10: whileInst
                {
                    this->followPush(FOLLOW_whileInst_in_instruction4306);
                    whileInst46=whileInst();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleinstructionEx;
                    }


                    {
                        node = whileInst46
                        ;
                    }


                }
                break;
            case 3:
                // WNScriptAST.g:570:10: doInst
                {
                    this->followPush(FOLLOW_doInst_in_instruction4323);
                    doInst47=doInst();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleinstructionEx;
                    }


                    {
                        node = doInst47
                        ;
                    }


                }
                break;
            case 4:
                // WNScriptAST.g:571:10: forInst
                {
                    this->followPush(FOLLOW_forInst_in_instruction4343);
                    forInst48=forInst();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleinstructionEx;
                    }


                    {
                        node = forInst48
                        ;
                    }


                }
                break;
            case 5:
                // WNScriptAST.g:572:10: instructionScalar ';'
                {
                    this->followPush(FOLLOW_instructionScalar_in_instruction4363);
                    instructionScalar49=instructionScalar();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleinstructionEx;
                    }


                     this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_instruction4365);
                    if  (this->hasException())
                    {
                        goto ruleinstructionEx;
                    }


                    {
                        node = instructionScalar49
                        ;
                    }


                }
                break;
            case 6:
                // WNScriptAST.g:573:10: returnInst
                {
                    this->followPush(FOLLOW_returnInst_in_instruction4378);
                    returnInst50=returnInst();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleinstructionEx;
                    }


                    {
                        node = returnInst50
                        ;
                    }


                }
                break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleinstructionEx; /* Prevent compiler warnings */
    ruleinstructionEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end instruction */

/**
 * $ANTLR start instructionList
 * WNScriptAST.g:576:1: instructionList returns [WNInstructionList* node] : a= instruction (b= instruction )* ;
 */
WNInstructionList*
WNScriptASTParser::instructionList()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNInstructionList* node;


    WNInstruction* a;
    typedef    WNInstruction* RETURN_TYPE_a;

    WNInstruction* b;
    typedef    WNInstruction* RETURN_TYPE_b;

    /* Initialize rule variables
     */





    {
        // WNScriptAST.g:579:5: (a= instruction (b= instruction )* )
        // WNScriptAST.g:579:10: a= instruction (b= instruction )*
        {
            this->followPush(FOLLOW_instruction_in_instructionList4414);
            a=instruction();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinstructionListEx;
            }


            {
                node = WN_SCRIPTNODE_NEW(WNInstructionList(a
                )); SetLocationFromNode(node, a
                );
            }


            // WNScriptAST.g:580:9: (b= instruction )*

            for (;;)
            {
                int alt37=2;
                switch ( this->LA(1) )
                {
                case BOOL:
                case CHAR:
                case DO:
                case DOUBDEC:
                case DOUBINC:
                case FLOAT:
                case FOR:
                case ID:
                case IF:
                case INT:
                case LBRACKET:
                case NULLTOK:
                case RETURN:
                case RETURN_OWN:
                case STRING:
                case TYPE:
                case WHILE:
                case 51:
                    {
                        alt37=1;
                    }
                    break;

                }

                switch (alt37)
                {
                case 1:
                    // WNScriptAST.g:580:10: b= instruction
                    {
                        this->followPush(FOLLOW_instruction_in_instructionList4430);
                        b=instruction();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleinstructionListEx;
                        }


                        {
                            node->AddInstruction(b
                            ); SetEndLocationFromNode(node, b
                            );
                        }


                    }
                    break;

                default:
                    goto loop37;    /* break out of the loop */
                    break;
                }
            }
            loop37: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinstructionListEx; /* Prevent compiler warnings */
    ruleinstructionListEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end instructionList */

/**
 * $ANTLR start body
 * WNScriptAST.g:583:1: body returns [WNInstructionList* node] : (a= LBRACE b= RBRACE |d= LBRACE instructionList e= RBRACE );
 */
WNInstructionList*
WNScriptASTParser::body()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNInstructionList* node;


    const CommonTokenType*    a;
    const CommonTokenType*    b;
    const CommonTokenType*    d;
    const CommonTokenType*    e;
    WNInstructionList* instructionList51;
    typedef    WNInstructionList* RETURN_TYPE_instructionList51;

    /* Initialize rule variables
     */



    a       = NULL;
    b       = NULL;
    d       = NULL;
    e       = NULL;



    {
        {
            //  WNScriptAST.g:586:5: (a= LBRACE b= RBRACE |d= LBRACE instructionList e= RBRACE )

            ANTLR_UINT32 alt38;

            alt38=2;

            switch ( this->LA(1) )
            {
            case LBRACE:
                {
                    switch ( this->LA(2) )
                    {
                    case RBRACE:
                        {
                            alt38=1;
                        }
                        break;
                    case BOOL:
                    case CHAR:
                    case DO:
                    case DOUBDEC:
                    case DOUBINC:
                    case FLOAT:
                    case FOR:
                    case ID:
                    case IF:
                    case INT:
                    case LBRACKET:
                    case NULLTOK:
                    case RETURN:
                    case RETURN_OWN:
                    case STRING:
                    case TYPE:
                    case WHILE:
                    case 51:
                        {
                            alt38=2;
                        }
                        break;

                    default:
                        ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 38 );
                        ex->set_state( 1 );


                        goto rulebodyEx;

                    }

                }
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 38 );
                ex->set_state( 0 );


                goto rulebodyEx;

            }

            switch (alt38)
            {
            case 1:
                // WNScriptAST.g:586:10: a= LBRACE b= RBRACE
                {
                    a =  this->matchToken(LBRACE, &FOLLOW_LBRACE_in_body4464);
                    if  (this->hasException())
                    {
                        goto rulebodyEx;
                    }


                    b =  this->matchToken(RBRACE, &FOLLOW_RBRACE_in_body4468);
                    if  (this->hasException())
                    {
                        goto rulebodyEx;
                    }


                    {
                         node = WN_SCRIPTNODE_NEW(WNInstructionList()); SetLocation(node, a); SetEndLocation(node, b);
                    }


                }
                break;
            case 2:
                // WNScriptAST.g:587:10: d= LBRACE instructionList e= RBRACE
                {
                    d =  this->matchToken(LBRACE, &FOLLOW_LBRACE_in_body4483);
                    if  (this->hasException())
                    {
                        goto rulebodyEx;
                    }


                    this->followPush(FOLLOW_instructionList_in_body4485);
                    instructionList51=instructionList();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto rulebodyEx;
                    }


                    e =  this->matchToken(RBRACE, &FOLLOW_RBRACE_in_body4489);
                    if  (this->hasException())
                    {
                        goto rulebodyEx;
                    }


                    {
                        node = instructionList51
                        ; SetLocation(node, d); SetEndLocation(node, e);
                    }


                }
                break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulebodyEx; /* Prevent compiler warnings */
    rulebodyEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end body */

/**
 * $ANTLR start function
 * WNScriptAST.g:590:1: function returns [WNFunction* node] : decl parameterList body ;
 */
WNFunction*
WNScriptASTParser::function()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNFunction* node;


    WNDeclaration* decl52;
    typedef    WNDeclaration* RETURN_TYPE_decl52;

    WNDeclList* parameterList53;
    typedef    WNDeclList* RETURN_TYPE_parameterList53;

    WNInstructionList* body54;
    typedef    WNInstructionList* RETURN_TYPE_body54;

    /* Initialize rule variables
     */





    {
        // WNScriptAST.g:593:5: ( decl parameterList body )
        // WNScriptAST.g:593:10: decl parameterList body
        {
            this->followPush(FOLLOW_decl_in_function4519);
            decl52=decl();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }


            this->followPush(FOLLOW_parameterList_in_function4521);
            parameterList53=parameterList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }


            this->followPush(FOLLOW_body_in_function4523);
            body54=body();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }


            {
                 node = WN_SCRIPTNODE_NEW(WNFunction(decl52
                , parameterList53
                , body54
                )); SetLocationFromNode(node, decl52
                ); SetEndLocationFromNode(node, body54
                );
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunctionEx; /* Prevent compiler warnings */
    rulefunctionEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end function */

/**
 * $ANTLR start structDecl
 * WNScriptAST.g:596:1: structDecl returns [WNStruct* node] : STRUCT TYPE LBRACE (a= declaration SEMICOLON )* RBRACE ;
 */
WNStruct*
WNScriptASTParser::structDecl()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNStruct* node;


    const CommonTokenType*    TYPE55;
    const CommonTokenType*    STRUCT56;
    const CommonTokenType*    RBRACE57;
    WNDeclaration* a;
    typedef    WNDeclaration* RETURN_TYPE_a;

    /* Initialize rule variables
     */

    TYPE55       = NULL;
    STRUCT56       = NULL;
    RBRACE57       = NULL;



    {
        // WNScriptAST.g:597:5: ( STRUCT TYPE LBRACE (a= declaration SEMICOLON )* RBRACE )
        // WNScriptAST.g:597:10: STRUCT TYPE LBRACE (a= declaration SEMICOLON )* RBRACE
        {
            STRUCT56 =  this->matchToken(STRUCT, &FOLLOW_STRUCT_in_structDecl4552);
            if  (this->hasException())
            {
                goto rulestructDeclEx;
            }


            TYPE55 =  this->matchToken(TYPE, &FOLLOW_TYPE_in_structDecl4554);
            if  (this->hasException())
            {
                goto rulestructDeclEx;
            }


            {
                node= WN_SCRIPTNODE_NEW(WNStruct((TYPE55->getText()).c_str())); SetLocation(node, STRUCT56);
            }


             this->matchToken(LBRACE, &FOLLOW_LBRACE_in_structDecl4570);
            if  (this->hasException())
            {
                goto rulestructDeclEx;
            }


            // WNScriptAST.g:598:20: (a= declaration SEMICOLON )*

            for (;;)
            {
                int alt39=2;
                switch ( this->LA(1) )
                {
                case TYPE:
                    {
                        alt39=1;
                    }
                    break;

                }

                switch (alt39)
                {
                case 1:
                    // WNScriptAST.g:598:21: a= declaration SEMICOLON
                    {
                        this->followPush(FOLLOW_declaration_in_structDecl4575);
                        a=declaration();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto rulestructDeclEx;
                        }


                        {
                             node->AddStructElem(a
                            );
                        }


                         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_structDecl4579);
                        if  (this->hasException())
                        {
                            goto rulestructDeclEx;
                        }


                    }
                    break;

                default:
                    goto loop39;    /* break out of the loop */
                    break;
                }
            }
            loop39: ; /* Jump out to here if this rule does not match */


            RBRACE57 =  this->matchToken(RBRACE, &FOLLOW_RBRACE_in_structDecl4584);
            if  (this->hasException())
            {
                goto rulestructDeclEx;
            }


            {
                 SetEndLocation(node, RBRACE57);
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestructDeclEx; /* Prevent compiler warnings */
    rulestructDeclEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end structDecl */

/**
 * $ANTLR start classDecl
 * WNScriptAST.g:601:1: classDecl returns [WNStruct* node] : ( (f= CLASS c= TYPE ) | (g= CLASS d= TYPE COLON e= TYPE ) ) LBRACE ( (a= declaration SEMICOLON ) | (b= function ) | ( VIRTUAL h= function ) | ( OVERRIDE i= function ) )* RBRACE ;
 */
WNStruct*
WNScriptASTParser::classDecl()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNStruct* node;


    const CommonTokenType*    f;
    const CommonTokenType*    c;
    const CommonTokenType*    g;
    const CommonTokenType*    d;
    const CommonTokenType*    e;
    const CommonTokenType*    RBRACE58;
    WNDeclaration* a;
    typedef    WNDeclaration* RETURN_TYPE_a;

    WNFunction* b;
    typedef    WNFunction* RETURN_TYPE_b;

    WNFunction* h;
    typedef    WNFunction* RETURN_TYPE_h;

    WNFunction* i;
    typedef    WNFunction* RETURN_TYPE_i;

    /* Initialize rule variables
     */

    f       = NULL;
    c       = NULL;
    g       = NULL;
    d       = NULL;
    e       = NULL;
    RBRACE58       = NULL;



    {
        // WNScriptAST.g:602:5: ( ( (f= CLASS c= TYPE ) | (g= CLASS d= TYPE COLON e= TYPE ) ) LBRACE ( (a= declaration SEMICOLON ) | (b= function ) | ( VIRTUAL h= function ) | ( OVERRIDE i= function ) )* RBRACE )
        // WNScriptAST.g:603:9: ( (f= CLASS c= TYPE ) | (g= CLASS d= TYPE COLON e= TYPE ) ) LBRACE ( (a= declaration SEMICOLON ) | (b= function ) | ( VIRTUAL h= function ) | ( OVERRIDE i= function ) )* RBRACE
        {
            // WNScriptAST.g:603:9: ( (f= CLASS c= TYPE ) | (g= CLASS d= TYPE COLON e= TYPE ) )
            {
                int alt40=2;
                switch ( this->LA(1) )
                {
                case CLASS:
                    {
                        switch ( this->LA(2) )
                        {
                        case TYPE:
                            {
                                switch ( this->LA(3) )
                                {
                                case COLON:
                                    {
                                        alt40=2;
                                    }
                                    break;
                                case LBRACE:
                                    {
                                        alt40=1;
                                    }
                                    break;

                                default:
                                    ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                    ex->set_decisionNum( 40 );
                                    ex->set_state( 2 );


                                    goto ruleclassDeclEx;

                                }

                            }
                            break;

                        default:
                            ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 40 );
                            ex->set_state( 1 );


                            goto ruleclassDeclEx;

                        }

                    }
                    break;

                default:
                    ExceptionBaseType* ex = new ANTLR_Exception< WNScriptASTParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 40 );
                    ex->set_state( 0 );


                    goto ruleclassDeclEx;

                }

                switch (alt40)
                {
                case 1:
                    // WNScriptAST.g:604:13: (f= CLASS c= TYPE )
                    {
                        // WNScriptAST.g:604:13: (f= CLASS c= TYPE )
                        // WNScriptAST.g:604:14: f= CLASS c= TYPE
                        {
                            f =  this->matchToken(CLASS, &FOLLOW_CLASS_in_classDecl4637);
                            if  (this->hasException())
                            {
                                goto ruleclassDeclEx;
                            }


                            c =  this->matchToken(TYPE, &FOLLOW_TYPE_in_classDecl4641);
                            if  (this->hasException())
                            {
                                goto ruleclassDeclEx;
                            }


                            {
                                node= WN_SCRIPTNODE_NEW(WNStruct((c->getText()).c_str(), true)); SetLocation(node, f);
                            }


                        }


                    }
                    break;
                case 2:
                    // WNScriptAST.g:605:13: (g= CLASS d= TYPE COLON e= TYPE )
                    {
                        // WNScriptAST.g:605:13: (g= CLASS d= TYPE COLON e= TYPE )
                        // WNScriptAST.g:605:14: g= CLASS d= TYPE COLON e= TYPE
                        {
                            g =  this->matchToken(CLASS, &FOLLOW_CLASS_in_classDecl4661);
                            if  (this->hasException())
                            {
                                goto ruleclassDeclEx;
                            }


                            d =  this->matchToken(TYPE, &FOLLOW_TYPE_in_classDecl4665);
                            if  (this->hasException())
                            {
                                goto ruleclassDeclEx;
                            }


                             this->matchToken(COLON, &FOLLOW_COLON_in_classDecl4667);
                            if  (this->hasException())
                            {
                                goto ruleclassDeclEx;
                            }


                            e =  this->matchToken(TYPE, &FOLLOW_TYPE_in_classDecl4671);
                            if  (this->hasException())
                            {
                                goto ruleclassDeclEx;
                            }


                            {
                                node= WN_SCRIPTNODE_NEW(WNStruct((d->getText()).c_str(), true, (e->getText()).c_str())); SetLocation(node, g);
                            }


                        }


                    }
                    break;

                }
            }

             this->matchToken(LBRACE, &FOLLOW_LBRACE_in_classDecl4698);
            if  (this->hasException())
            {
                goto ruleclassDeclEx;
            }


            // WNScriptAST.g:608:17: ( (a= declaration SEMICOLON ) | (b= function ) | ( VIRTUAL h= function ) | ( OVERRIDE i= function ) )*

            for (;;)
            {
                int alt41=5;
                alt41 = cdfa41.predict(this, this->get_rec(), this->get_istream(), cdfa41 );
                if  (this->hasException())
                {
                    goto ruleclassDeclEx;
                }

                switch (alt41)
                {
                case 1:
                    // WNScriptAST.g:609:21: (a= declaration SEMICOLON )
                    {
                        // WNScriptAST.g:609:21: (a= declaration SEMICOLON )
                        // WNScriptAST.g:609:22: a= declaration SEMICOLON
                        {
                            this->followPush(FOLLOW_declaration_in_classDecl4742);
                            a=declaration();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto ruleclassDeclEx;
                            }


                            {
                                 node->AddStructElem(a
                                );
                            }


                             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_classDecl4746);
                            if  (this->hasException())
                            {
                                goto ruleclassDeclEx;
                            }


                        }


                    }
                    break;
                case 2:
                    // WNScriptAST.g:610:21: (b= function )
                    {
                        // WNScriptAST.g:610:21: (b= function )
                        // WNScriptAST.g:610:22: b= function
                        {
                            this->followPush(FOLLOW_function_in_classDecl4772);
                            b=function();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto ruleclassDeclEx;
                            }


                            {
                                 node->AddFunction(b
                                );
                            }


                        }


                    }
                    break;
                case 3:
                    // WNScriptAST.g:611:21: ( VIRTUAL h= function )
                    {
                        // WNScriptAST.g:611:21: ( VIRTUAL h= function )
                        // WNScriptAST.g:611:22: VIRTUAL h= function
                        {
                             this->matchToken(VIRTUAL, &FOLLOW_VIRTUAL_in_classDecl4801);
                            if  (this->hasException())
                            {
                                goto ruleclassDeclEx;
                            }


                            this->followPush(FOLLOW_function_in_classDecl4805);
                            h=function();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto ruleclassDeclEx;
                            }


                            {
                                 node->AddFunction(h
                                ); h
                                ->SetVirtual();
                            }


                        }


                    }
                    break;
                case 4:
                    // WNScriptAST.g:612:21: ( OVERRIDE i= function )
                    {
                        // WNScriptAST.g:612:21: ( OVERRIDE i= function )
                        // WNScriptAST.g:612:22: OVERRIDE i= function
                        {
                             this->matchToken(OVERRIDE, &FOLLOW_OVERRIDE_in_classDecl4831);
                            if  (this->hasException())
                            {
                                goto ruleclassDeclEx;
                            }


                            this->followPush(FOLLOW_function_in_classDecl4835);
                            i=function();

                            this->followPop();
                            if  (this->hasException())
                            {
                                goto ruleclassDeclEx;
                            }


                            {
                                 node->AddFunction(i
                                ); i
                                ->SetOverride();
                            }


                        }


                    }
                    break;

                default:
                    goto loop41;    /* break out of the loop */
                    break;
                }
            }
            loop41: ; /* Jump out to here if this rule does not match */


            RBRACE58 =  this->matchToken(RBRACE, &FOLLOW_RBRACE_in_classDecl4872);
            if  (this->hasException())
            {
                goto ruleclassDeclEx;
            }


            {
                 SetEndLocation(node, RBRACE58);
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleclassDeclEx; /* Prevent compiler warnings */
    ruleclassDeclEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end classDecl */

/**
 * $ANTLR start inc
 * WNScriptAST.g:617:1: inc returns [wn_char* file] : INCLUDE STRING ;
 */
wn_char*
WNScriptASTParser::inc()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    wn_char* file;


    const CommonTokenType*    STRING59;

    /* Initialize rule variables
     */

    STRING59       = NULL;



    {
        // WNScriptAST.g:618:5: ( INCLUDE STRING )
        // WNScriptAST.g:618:9: INCLUDE STRING
        {
             this->matchToken(INCLUDE, &FOLLOW_INCLUDE_in_inc4897);
            if  (this->hasException())
            {
                goto ruleincEx;
            }


            STRING59 =  this->matchToken(STRING, &FOLLOW_STRING_in_inc4899);
            if  (this->hasException())
            {
                goto ruleincEx;
            }


            {
                 COPY_STRING((STRING59->getText()).c_str(), file);
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleincEx; /* Prevent compiler warnings */
    ruleincEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return file;
}
/* $ANTLR end inc */

/**
 * $ANTLR start program
 * WNScriptAST.g:621:1: program returns [WNScriptFile* node] : ( function | structDecl | classDecl | inc )* ;
 */
WNScriptFile*
WNScriptASTParser::program()
{
        WNScriptASTParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);

    WNScriptFile* node;


    WNFunction* function60;
    typedef    WNFunction* RETURN_TYPE_function60;

    WNStruct* structDecl61;
    typedef    WNStruct* RETURN_TYPE_structDecl61;

    WNStruct* classDecl62;
    typedef    WNStruct* RETURN_TYPE_classDecl62;

    wn_char* inc63;
    typedef    wn_char* RETURN_TYPE_inc63;

    /* Initialize rule variables
     */


        node = WN_SCRIPTNODE_NEW(WNScriptFile());



    {
        // WNScriptAST.g:625:5: ( ( function | structDecl | classDecl | inc )* )
        // WNScriptAST.g:625:9: ( function | structDecl | classDecl | inc )*
        {
            // WNScriptAST.g:625:9: ( function | structDecl | classDecl | inc )*

            for (;;)
            {
                int alt42=5;
                switch ( this->LA(1) )
                {
                case TYPE:
                    {
                        alt42=1;
                    }
                    break;
                case STRUCT:
                    {
                        alt42=2;
                    }
                    break;
                case CLASS:
                    {
                        alt42=3;
                    }
                    break;
                case INCLUDE:
                    {
                        alt42=4;
                    }
                    break;

                }

                switch (alt42)
                {
                case 1:
                    // WNScriptAST.g:626:17: function
                    {
                        this->followPush(FOLLOW_function_in_program4945);
                        function60=function();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleprogramEx;
                        }


                        {
                             node->AddFunction(function60
                            );
                        }


                    }
                    break;
                case 2:
                    // WNScriptAST.g:627:17: structDecl
                    {
                        this->followPush(FOLLOW_structDecl_in_program4967);
                        structDecl61=structDecl();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleprogramEx;
                        }


                        {
                             node->AddStruct(structDecl61
                            );
                        }


                    }
                    break;
                case 3:
                    // WNScriptAST.g:628:17: classDecl
                    {
                        this->followPush(FOLLOW_classDecl_in_program4987);
                        classDecl62=classDecl();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleprogramEx;
                        }


                        {
                             node->AddStruct(classDecl62
                            );
                        }


                    }
                    break;
                case 4:
                    // WNScriptAST.g:629:17: inc
                    {
                        this->followPush(FOLLOW_inc_in_program5008);
                        inc63=inc();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleprogramEx;
                        }


                        {
                             node->AddInclude(inc63
                            );
                        }


                    }
                    break;

                default:
                    goto loop42;    /* break out of the loop */
                    break;
                }
            }
            loop42: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprogramEx; /* Prevent compiler warnings */
    ruleprogramEx: ;


        if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return node;
}
/* $ANTLR end program */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */



/* End of code
 * =============================================================================
 */
