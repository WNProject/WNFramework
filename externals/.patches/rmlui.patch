diff --git externals/rmlui/Include/RmlUi/Core/Context.h externals/rmlui/Include/RmlUi/Core/Context.h
index 4961eb83..43f0ed44 100644
--- externals/rmlui/Include/RmlUi/Core/Context.h
+++ externals/rmlui/Include/RmlUi/Core/Context.h
@@ -15,7 +15,7 @@
  *
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -30,10 +30,10 @@
 #define RMLUI_CORE_CONTEXT_H
 
 #include "Header.h"
-#include "Types.h"
-#include "Traits.h"
 #include "Input.h"
 #include "ScriptInterface.h"
+#include "Traits.h"
+#include "Types.h"
 
 namespace Rml {
 
@@ -48,13 +48,12 @@ class DataTypeRegister;
 enum class EventId : uint16_t;
 
 /**
-	A context for storing, rendering and processing RML documents. Multiple contexts can exist simultaneously.
+    A context for storing, rendering and processing RML documents. Multiple contexts can exist simultaneously.
 
-	@author Peter Curry
+    @author Peter Curry
  */
 
-class RMLUICORE_API Context : public ScriptInterface
-{
+class RMLUICORE_API Context : public ScriptInterface {
 public:
 	/// Constructs a new, uninitialised context. This should not be called directly, use CreateContext()
 	/// instead.
@@ -81,7 +80,7 @@ public:
 	/// @return The current density-independent pixel ratio of the context.
 	float GetDensityIndependentPixelRatio() const;
 
-	/// Updates all elements in the context's documents. 
+	/// Updates all elements in the context's documents.
 	/// This must be called before Context::Render, but after any elements have been changed, added or removed.
 	bool Update();
 	/// Renders all visible elements in the context's documents.
@@ -178,12 +177,14 @@ public:
 
 	/// Sends a key down event into this context.
 	/// @param[in] key_identifier The key pressed.
-	/// @param[in] key_modifier_state The state of key modifiers (shift, control, caps-lock, etc) keys; this should be generated by ORing together members of the Input::KeyModifier enumeration.
+	/// @param[in] key_modifier_state The state of key modifiers (shift, control, caps-lock, etc) keys; this should be generated by ORing together
+	/// members of the Input::KeyModifier enumeration.
 	/// @return True if the event was not consumed (ie, was prevented from propagating by an element), false if it was.
 	bool ProcessKeyDown(Input::KeyIdentifier key_identifier, int key_modifier_state);
 	/// Sends a key up event into this context.
 	/// @param[in] key_identifier The key released.
-	/// @param[in] key_modifier_state The state of key modifiers (shift, control, caps-lock, etc) keys; this should be generated by ORing together members of the Input::KeyModifier enumeration.
+	/// @param[in] key_modifier_state The state of key modifiers (shift, control, caps-lock, etc) keys; this should be generated by ORing together
+	/// members of the Input::KeyModifier enumeration.
 	/// @return True if the event was not consumed (ie, was prevented from propagating by an element), false if it was.
 	bool ProcessKeyUp(Input::KeyIdentifier key_identifier, int key_modifier_state);
 
@@ -201,31 +202,39 @@ public:
 	/// Sends a mouse movement event into this context.
 	/// @param[in] x The x-coordinate of the mouse cursor, in window-coordinates (ie, 0 should be the left of the client area).
 	/// @param[in] y The y-coordinate of the mouse cursor, in window-coordinates (ie, 0 should be the top of the client area).
-	/// @param[in] key_modifier_state The state of key modifiers (shift, control, caps-lock, etc) keys; this should be generated by ORing together members of the Input::KeyModifier enumeration.
+	/// @param[in] key_modifier_state The state of key modifiers (shift, control, caps-lock, etc) keys; this should be generated by ORing together
+	/// members of the Input::KeyModifier enumeration.
 	/// @return True if the mouse is not interacting with any elements in the context (see 'IsMouseInteracting'), otherwise false.
 	bool ProcessMouseMove(int x, int y, int key_modifier_state);
 	/// Sends a mouse-button down event into this context.
 	/// @param[in] button_index The index of the button that was pressed; 0 for the left button, 1 for right, and any others from 2 onwards.
-	/// @param[in] key_modifier_state The state of key modifiers (shift, control, caps-lock, etc) keys; this should be generated by ORing together members of the Input::KeyModifier enumeration.
+	/// @param[in] key_modifier_state The state of key modifiers (shift, control, caps-lock, etc) keys; this should be generated by ORing together
+	/// members of the Input::KeyModifier enumeration.
 	/// @return True if the mouse is not interacting with any elements in the context (see 'IsMouseInteracting'), otherwise false.
 	bool ProcessMouseButtonDown(int button_index, int key_modifier_state);
 	/// Sends a mouse-button up event into this context.
 	/// @param[in] button_index The index of the button that was release; 0 for the left button, 1 for right, and any others from 2 onwards.
-	/// @param[in] key_modifier_state The state of key modifiers (shift, control, caps-lock, etc) keys; this should be generated by ORing together members of the Input::KeyModifier enumeration.
+	/// @param[in] key_modifier_state The state of key modifiers (shift, control, caps-lock, etc) keys; this should be generated by ORing together
+	/// members of the Input::KeyModifier enumeration.
 	/// @return True if the mouse is not interacting with any elements in the context (see 'IsMouseInteracting'), otherwise false.
 	bool ProcessMouseButtonUp(int button_index, int key_modifier_state);
 	/// Sends a mouse-wheel movement event into this context.
-	/// @param[in] wheel_delta The mouse-wheel movement this frame. RmlUi treats a negative delta as up movement (away from the user), positive as down.
-	/// @param[in] key_modifier_state The state of key modifiers (shift, control, caps-lock, etc) keys; this should be generated by ORing together members of the Input::KeyModifier enumeration.
+	/// @param[in] wheel_delta The mouse-wheel movement this frame. RmlUi treats a negative delta as up movement (away from the user), positive as
+	/// down.
+	/// @param[in] key_modifier_state The state of key modifiers (shift, control, caps-lock, etc) keys; this should be generated by ORing together
+	/// members of the Input::KeyModifier enumeration.
 	/// @return True if the event was not consumed (ie, was prevented from propagating by an element), false if it was.
 	bool ProcessMouseWheel(float wheel_delta, int key_modifier_state);
-	/// Tells the context the mouse has left the window. This removes any hover state from all elements and prevents 'Update()' from setting the hover state for elements under the mouse.
+	/// Tells the context the mouse has left the window. This removes any hover state from all elements and prevents 'Update()' from setting the hover
+	/// state for elements under the mouse.
 	/// @return True if the mouse is not interacting with any elements in the context (see 'IsMouseInteracting'), otherwise false.
 	/// @note The mouse is considered activate again after the next call to 'ProcessMouseMove()'.
 	bool ProcessMouseLeave();
 
-	/// Returns a hint on whether the mouse is currently interacting with any elements in this context, based on previously submitted 'ProcessMouse...()' commands.
-	/// @note Interaction is determined irrespective of background and opacity. See the RCSS property 'pointer-events' to disable interaction for specific elements.
+	/// Returns a hint on whether the mouse is currently interacting with any elements in this context, based on previously submitted
+	/// 'ProcessMouse...()' commands.
+	/// @note Interaction is determined irrespective of background and opacity. See the RCSS property 'pointer-events' to disable interaction for
+	/// specific elements.
 	/// @return True if the mouse hovers over or has activated an element in this context, otherwise false.
 	bool IsMouseInteracting() const;
 
@@ -285,8 +294,8 @@ private:
 
 	ContextInstancer* instancer;
 
-	using ElementSet = SmallOrderedSet< Element* >;
-	using ElementList = Vector< Element* >;
+	using ElementSet = SmallOrderedSet<Element*>;
+	using ElementList = Vector<Element*>;
 	// Set of elements that are currently in hover state.
 	ElementSet hover_chain;
 	// List of elements that are currently in active state.
@@ -388,5 +397,67 @@ private:
 	friend RMLUICORE_API Context* CreateContext(const String&, Vector2i, RenderInterface*);
 };
 
+class GlobalContext {
+public:
+	static GlobalContext* GetGlobalContextForThread();
+	static void SetGlobalContextForThread(GlobalContext* context);
+
+	~GlobalContext()
+	{
+		for (auto& it : m_elements)
+		{
+			it.second.del(it.second.value);
+		}
+	}
+
+	template <typename T>
+	T& operator()(T*& _key)
+	{
+		void* v = m_elements[static_cast<void*>(&_key)].value;
+		return *reinterpret_cast<T*>(v);
+	}
+
+	template <typename T, typename... Args>
+	inline typename std::remove_volatile<T>::type& GetOrCreate(T** _key, Args... args)
+	{
+		auto it = m_elements.find(static_cast<void*>(_key));
+		if (it == m_elements.end())
+		{
+			void* v = static_cast<void*>(new typename std::remove_volatile<T>::type(args...));
+			it = m_elements
+					 .insert(std::make_pair(static_cast<void*>(_key),
+						 deleter{[](void* v) { delete reinterpret_cast<typename std::remove_volatile<T>::type*>(v); }, static_cast<void*>(v)}))
+					 .first;
+		}
+		return *reinterpret_cast<typename std::remove_volatile<T>::type*>(it->second.value);
+	}
+
+private:
+	struct deleter {
+		~deleter() {}
+		void (*del)(void*);
+		void* value;
+	};
+	std::unordered_map<void*, deleter> m_elements;
+};
+
+struct SetGlobalContextForBlock {
+	SetGlobalContextForBlock(GlobalContext* _context)
+	{
+		previous_context_for_thread = GlobalContext::GetGlobalContextForThread();
+		GlobalContext::SetGlobalContextForThread(_context);
+	}
+
+	~SetGlobalContextForBlock() { GlobalContext::SetGlobalContextForThread(previous_context_for_thread); }
+
+	GlobalContext* previous_context_for_thread;
+};
+
+#define REGISTER_GLOBAL(type, name) type volatile* g_##name
+#define REGISTER_INIT_GLOBAL(type, name) type volatile* G_##name
+#define REGISTER_EXTERN_GLOBAL(type, name) extern type volatile* g_##name
+#define GET_OR_MAKE_INIT_GLOBAL(name, ...) GlobalContext::GetGlobalContextForThread()->GetOrCreate(&G_##name, name##_params)
+#define GET_OR_MAKE_GLOBAL(name, ...) GlobalContext::GetGlobalContextForThread()->GetOrCreate(&g_##name)
+
 } // namespace Rml
 #endif
diff --git externals/rmlui/Source/Core/Context.cpp externals/rmlui/Source/Core/Context.cpp
index e12b907d..6f170a84 100644
--- externals/rmlui/Source/Core/Context.cpp
+++ externals/rmlui/Source/Core/Context.cpp
@@ -15,7 +15,7 @@
  *
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -27,8 +27,8 @@
  */
 
 #include "../../Include/RmlUi/Core/Context.h"
-#include "../../Include/RmlUi/Core/ContextInstancer.h"
 #include "../../Include/RmlUi/Core/ComputedValues.h"
+#include "../../Include/RmlUi/Core/ContextInstancer.h"
 #include "../../Include/RmlUi/Core/Core.h"
 #include "../../Include/RmlUi/Core/DataModelHandle.h"
 #include "../../Include/RmlUi/Core/ElementDocument.h"
@@ -38,7 +38,6 @@
 #include "../../Include/RmlUi/Core/RenderInterface.h"
 #include "../../Include/RmlUi/Core/StreamMemory.h"
 #include "../../Include/RmlUi/Core/SystemInterface.h"
-#include "../../Include/RmlUi/Core/StreamMemory.h"
 #include "DataModel.h"
 #include "EventDispatcher.h"
 #include "PluginRegistry.h"
@@ -46,13 +45,13 @@
 #include <algorithm>
 #include <iterator>
 
-
 namespace Rml {
 
-static constexpr float DOUBLE_CLICK_TIME = 0.5f;     // [s]
-static constexpr float DOUBLE_CLICK_MAX_DIST = 3.f;  // [dp]
+static constexpr float DOUBLE_CLICK_TIME = 0.5f;    // [s]
+static constexpr float DOUBLE_CLICK_MAX_DIST = 3.f; // [dp]
 
-Context::Context(const String& name) : name(name), dimensions(0, 0), density_independent_pixel_ratio(1.0f), mouse_position(0, 0), clip_origin(-1, -1), clip_dimensions(-1, -1)
+Context::Context(const String& name) :
+	name(name), dimensions(0, 0), density_independent_pixel_ratio(1.0f), mouse_position(0, 0), clip_origin(-1, -1), clip_dimensions(-1, -1)
 {
 	instancer = nullptr;
 
@@ -65,7 +64,7 @@ Context::Context(const String& name) : name(name), dimensions(0, 0), density_ind
 	root->SetProperty(PropertyId::ZIndex, Property(0, Property::NUMBER));
 
 	cursor_proxy = Factory::InstanceElement(nullptr, documents_base_tag, documents_base_tag, XMLAttributes());
-	ElementDocument* cursor_proxy_document = rmlui_dynamic_cast< ElementDocument* >(cursor_proxy.get());
+	ElementDocument* cursor_proxy_document = rmlui_dynamic_cast<ElementDocument*>(cursor_proxy.get());
 	RMLUI_ASSERT(cursor_proxy_document);
 	cursor_proxy_document->context = this;
 
@@ -80,7 +79,7 @@ Context::Context(const String& name) : name(name), dimensions(0, 0), density_ind
 	cursor_proxy_document->SetProperty(PropertyId::Decorator, Property());
 	cursor_proxy_document->SetProperty(PropertyId::OverflowX, Property(Style::Overflow::Visible));
 	cursor_proxy_document->SetProperty(PropertyId::OverflowY, Property(Style::Overflow::Visible));
-		
+
 	document_focus_history.push_back(root.get());
 	focus = root.get();
 	hover = nullptr;
@@ -144,7 +143,7 @@ void Context::SetDimensions(const Vector2i _dimensions)
 				document->DispatchEvent(EventId::Resize, Dictionary());
 			}
 		}
-		
+
 		clip_dimensions = dimensions;
 	}
 }
@@ -182,7 +181,7 @@ float Context::GetDensityIndependentPixelRatio() const
 bool Context::Update()
 {
 	RMLUI_ZoneScoped;
-	
+
 	// Update the hover chain to detect any new or moved elements under the mouse.
 	if (mouse_active)
 		UpdateHoverChain(mouse_position);
@@ -232,9 +231,8 @@ bool Context::Render()
 	if (drag_clone)
 	{
 		static_cast<ElementDocument&>(*cursor_proxy).UpdateDocument();
-		cursor_proxy->SetOffset(Vector2f((float)Math::Clamp(mouse_position.x, 0, dimensions.x),
-			(float)Math::Clamp(mouse_position.y, 0, dimensions.y)),
-			nullptr);
+		cursor_proxy->SetOffset(
+			Vector2f((float)Math::Clamp(mouse_position.x, 0, dimensions.x), (float)Math::Clamp(mouse_position.y, 0, dimensions.y)), nullptr);
 		cursor_proxy->Render();
 	}
 
@@ -243,7 +241,7 @@ bool Context::Render()
 	return true;
 }
 
-// Creates a new, empty document and places it into this context. 
+// Creates a new, empty document and places it into this context.
 ElementDocument* Context::CreateDocument(const String& instancer_name)
 {
 	ElementPtr element = Factory::InstanceElement(nullptr, instancer_name, documents_base_tag, XMLAttributes());
@@ -253,10 +251,12 @@ ElementDocument* Context::CreateDocument(const String& instancer_name)
 		return nullptr;
 	}
 
-	ElementDocument* document = rmlui_dynamic_cast< ElementDocument* >(element.get());
+	ElementDocument* document = rmlui_dynamic_cast<ElementDocument*>(element.get());
 	if (!document)
 	{
-		Log::Message(Log::LT_ERROR, "Failed to instance document on instancer_name '%s', Found type '%s', was expecting derivative of ElementDocument.", instancer_name.c_str(), rmlui_type_name(*element));
+		Log::Message(Log::LT_ERROR,
+			"Failed to instance document on instancer_name '%s', Found type '%s', was expecting derivative of ElementDocument.",
+			instancer_name.c_str(), rmlui_type_name(*element));
 		return nullptr;
 	}
 
@@ -270,7 +270,7 @@ ElementDocument* Context::CreateDocument(const String& instancer_name)
 
 // Load a document into the context.
 ElementDocument* Context::LoadDocument(const String& document_path)
-{	
+{
 	auto stream = MakeUnique<StreamFile>();
 
 	if (!stream->Open(document_path))
@@ -291,7 +291,7 @@ ElementDocument* Context::LoadDocument(Stream* stream)
 		return nullptr;
 
 	ElementDocument* document = static_cast<ElementDocument*>(element.get());
-	
+
 	root->AppendChild(std::move(element));
 
 	// The 'load' event is fired before updating the document, because the user might
@@ -318,7 +318,7 @@ ElementDocument* Context::LoadDocumentFromMemory(const String& string, const Str
 	// Open the stream based on the string contents.
 	auto stream = MakeUnique<StreamMemory>(reinterpret_cast<const byte*>(string.c_str()), string.size());
 
-	stream->SetSourceURL( source_url );
+	stream->SetSourceURL(source_url);
 
 	// Load the document from the stream.
 	ElementDocument* document = LoadDocument(stream.get());
@@ -345,7 +345,7 @@ void Context::UnloadDocument(ElementDocument* _document)
 		PluginRegistry::NotifyDocumentUnload(document);
 
 		// Move document to a temporary location to be released later.
-		unloaded_documents.push_back( root->RemoveChild(document) );
+		unloaded_documents.push_back(root->RemoveChild(document));
 	}
 
 	// Remove the item from the focus history.
@@ -630,12 +630,12 @@ static Element* FindFocusElement(Element* element)
 	ElementDocument* owner_document = element->GetOwnerDocument();
 	if (!owner_document || owner_document->GetComputedValues().focus() == Style::Focus::None)
 		return nullptr;
-	
+
 	while (element && element->GetComputedValues().focus() == Style::Focus::None)
 	{
 		element = element->GetParentNode();
 	}
-	
+
 	return element;
 }
 
@@ -649,7 +649,7 @@ bool Context::ProcessMouseButtonDown(int button_index, int key_modifier_state)
 	if (button_index == 0)
 	{
 		Element* new_focus = hover;
-		
+
 		// Set the currently hovered element to focus if it isn't already the focus.
 		if (hover)
 		{
@@ -665,7 +665,7 @@ bool Context::ProcessMouseButtonDown(int button_index, int key_modifier_state)
 		active = new_focus;
 
 		bool propagate = true;
-		
+
 		// Call 'onmousedown' on every item in the hover chain, and copy the hover chain to the active chain.
 		if (hover)
 			propagate = hover->DispatchEvent(EventId::Mousedown, parameters);
@@ -679,8 +679,7 @@ bool Context::ProcessMouseButtonDown(int button_index, int key_modifier_state)
 
 			double click_time = GetSystemInterface()->GetElapsedTime();
 
-			if (active == last_click_element &&
-				float(click_time - last_click_time) < DOUBLE_CLICK_TIME &&
+			if (active == last_click_element && float(click_time - last_click_time) < DOUBLE_CLICK_TIME &&
 				mouse_distance_squared < max_mouse_distance * max_mouse_distance)
 			{
 				if (hover)
@@ -710,8 +709,8 @@ bool Context::ProcessMouseButtonDown(int button_index, int key_modifier_state)
 				Style::Drag drag_style = drag->GetComputedValues().drag();
 				switch (drag_style)
 				{
-				case Style::Drag::None:		drag = drag->GetParentNode(); continue;
-				case Style::Drag::Block:	drag = nullptr; continue;
+				case Style::Drag::None: drag = drag->GetParentNode(); continue;
+				case Style::Drag::Block: drag = nullptr; continue;
 				default: drag_verbose = (drag_style == Style::Drag::DragDrop || drag_style == Style::Drag::Clone);
 				}
 
@@ -736,7 +735,8 @@ bool Context::ProcessMouseButtonUp(int button_index, int key_modifier_state)
 	GenerateMouseEventParameters(parameters, button_index);
 	GenerateKeyModifierEventParameters(parameters, key_modifier_state);
 
-	// We want to return the interaction state before handling the mouse up events, so that any active element that is released is considered to capture the event.
+	// We want to return the interaction state before handling the mouse up events, so that any active element that is released is considered to
+	// capture the event.
 	const bool result = !IsMouseInteracting();
 
 	// Process primary click.
@@ -775,12 +775,12 @@ bool Context::ProcessMouseButtonUp(int button_index, int key_modifier_state)
 					{
 						drag_hover->DispatchEvent(EventId::Dragdrop, drag_parameters);
 						// User may have removed the element, do an extra check.
-						if(drag_hover) 
+						if (drag_hover)
 							drag_hover->DispatchEvent(EventId::Dragout, drag_parameters);
 					}
 				}
 
-				if(drag)
+				if (drag)
 					drag->DispatchEvent(EventId::Dragend, drag_parameters);
 
 				ReleaseDragClone();
@@ -822,10 +822,10 @@ bool Context::ProcessMouseWheel(float wheel_delta, int key_modifier_state)
 bool Context::ProcessMouseLeave()
 {
 	mouse_active = false;
-	
+
 	// Update the hover chain. Now that 'mouse_active' is disabled this will remove the hover state from all elements.
 	UpdateHoverChain(mouse_position);
-	
+
 	return !IsMouseInteracting();
 }
 
@@ -839,19 +839,19 @@ RenderInterface* Context::GetRenderInterface() const
 {
 	return render_interface;
 }
-	
+
 // Gets the current clipping region for the render traversal
 bool Context::GetActiveClipRegion(Vector2i& origin, Vector2i& dimensions) const
 {
 	if (clip_dimensions.x < 0 || clip_dimensions.y < 0)
 		return false;
-	
+
 	origin = clip_origin;
 	dimensions = clip_dimensions;
-	
+
 	return true;
 }
-	
+
 // Sets the current clipping region for the render traversal
 void Context::SetActiveClipRegion(const Vector2i origin, const Vector2i dimensions)
 {
@@ -958,7 +958,7 @@ void Context::OnElementDetach(Element* element)
 	}
 
 	// Focus normally cleared and set by parent during Element::RemoveChild.
-	// However, there are some exceptions, such as when an there are multiple 
+	// However, there are some exceptions, such as when an there are multiple
 	// ElementDocuments in the hierarchy above the current element.
 	if (element == focus)
 		focus = nullptr;
@@ -1057,7 +1057,7 @@ void Context::UpdateHoverChain(Vector2i old_mouse_position, int key_modifier_sta
 	// Generate the parameters for the mouse events (there could be a few!).
 	GenerateMouseEventParameters(parameters);
 	GenerateKeyModifierEventParameters(parameters, key_modifier_state);
-	
+
 	GenerateMouseEventParameters(drag_parameters);
 	GenerateDragEventParameters(drag_parameters);
 	GenerateKeyModifierEventParameters(drag_parameters, key_modifier_state);
@@ -1088,16 +1088,16 @@ void Context::UpdateHoverChain(Vector2i old_mouse_position, int key_modifier_sta
 
 	hover = mouse_active ? GetElementAtPoint(position) : nullptr;
 
-	if(enable_cursor)
+	if (enable_cursor)
 	{
 		String new_cursor_name;
 
-		if(drag)
+		if (drag)
 			new_cursor_name = drag->GetComputedValues().cursor();
 		else if (hover)
 			new_cursor_name = hover->GetComputedValues().cursor();
 
-		if(new_cursor_name != cursor_name)
+		if (new_cursor_name != cursor_name)
 		{
 			GetSystemInterface()->SetMouseCursor(new_cursor_name);
 			cursor_name = new_cursor_name;
@@ -1130,8 +1130,7 @@ void Context::UpdateHoverChain(Vector2i old_mouse_position, int key_modifier_sta
 			element = element->GetParentNode();
 		}
 
-		if (drag_started &&
-			drag_verbose)
+		if (drag_started && drag_verbose)
 		{
 			// Send out ondragover and ondragout events as appropriate.
 			SendEvents(drag_hover_chain, new_drag_hover_chain, EventId::Dragout, drag_parameters);
@@ -1162,15 +1161,13 @@ Element* Context::GetElementAtPoint(Vector2f point, const Element* ignore_elemen
 		if (focus)
 		{
 			ElementDocument* focus_document = focus->GetOwnerDocument();
-			if (focus_document != nullptr &&
-				focus_document->IsModal())
+			if (focus_document != nullptr && focus_document->IsModal())
 			{
 				element = focus_document;
 			}
 		}
 	}
 
-
 	// Check any elements within our stacking context. We want to return the lowest-down element
 	// that is under the cursor.
 	if (element->local_stacking_context)
@@ -1178,7 +1175,7 @@ Element* Context::GetElementAtPoint(Vector2f point, const Element* ignore_elemen
 		if (element->stacking_context_dirty)
 			element->BuildLocalStackingContext();
 
-		for (int i = (int) element->stacking_context.size() - 1; i >= 0; --i)
+		for (int i = (int)element->stacking_context.size() - 1; i >= 0; --i)
 		{
 			if (ignore_element != nullptr)
 			{
@@ -1215,10 +1212,8 @@ Element* Context::GetElementAtPoint(Vector2f point, const Element* ignore_elemen
 		Vector2i clip_origin, clip_dimensions;
 		if (ElementUtilities::GetClippingRegion(clip_origin, clip_dimensions, element))
 		{
-			within_element = point.x >= clip_origin.x &&
-							 point.y >= clip_origin.y &&
-							 point.x <= (clip_origin.x + clip_dimensions.x) &&
-							 point.y <= (clip_origin.y + clip_dimensions.y);
+			within_element = point.x >= clip_origin.x && point.y >= clip_origin.y && point.x <= (clip_origin.x + clip_dimensions.x) &&
+				point.y <= (clip_origin.y + clip_dimensions.y);
 		}
 	}
 
@@ -1309,15 +1304,7 @@ void Context::GenerateMouseEventParameters(Dictionary& parameters, int button_in
 // Builds the parameters for the key modifier state.
 void Context::GenerateKeyModifierEventParameters(Dictionary& parameters, int key_modifier_state)
 {
-	static const String property_names[] = {
-		"ctrl_key",
-		"shift_key",
-		"alt_key",
-		"meta_key",
-		"caps_lock_key",
-		"num_lock_key",
-		"scroll_lock_key"
-	};
+	static const String property_names[] = {"ctrl_key", "shift_key", "alt_key", "meta_key", "caps_lock_key", "num_lock_key", "scroll_lock_key"};
 
 	for (int i = 0; i < 7; i++)
 		parameters[property_names[i]] = (int)((key_modifier_state & (1 << i)) > 0);
@@ -1325,7 +1312,7 @@ void Context::GenerateKeyModifierEventParameters(Dictionary& parameters, int key
 
 // Builds the parameters for a drag event.
 void Context::GenerateDragEventParameters(Dictionary& parameters)
-{	
+{
 	parameters["drag_element"] = (void*)drag;
 }
 
@@ -1344,7 +1331,7 @@ void Context::ReleaseUnloadedDocuments()
 	}
 }
 
-using ElementObserverList = Vector< ObserverPtr<Element> >;
+using ElementObserverList = Vector<ObserverPtr<Element>>;
 
 class ElementObserverListBackInserter {
 public:
@@ -1356,7 +1343,8 @@ public:
 	using container_type = ElementObserverList;
 
 	ElementObserverListBackInserter(ElementObserverList& elements) : elements(&elements) {}
-	ElementObserverListBackInserter& operator=(Element* element) {
+	ElementObserverListBackInserter& operator=(Element* element)
+	{
 		elements->push_back(element->GetObserverPtr());
 		return *this;
 	}
diff --git externals/rmlui/Source/Core/Core.cpp externals/rmlui/Source/Core/Core.cpp
index eb3c3c20..82cd5771 100644
--- externals/rmlui/Source/Core/Core.cpp
+++ externals/rmlui/Source/Core/Core.cpp
@@ -15,7 +15,7 @@
  *
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -34,10 +34,9 @@
 #include "../../Include/RmlUi/Core/FontEngineInterface.h"
 #include "../../Include/RmlUi/Core/Plugin.h"
 #include "../../Include/RmlUi/Core/RenderInterface.h"
-#include "../../Include/RmlUi/Core/SystemInterface.h"
 #include "../../Include/RmlUi/Core/StyleSheetSpecification.h"
+#include "../../Include/RmlUi/Core/SystemInterface.h"
 #include "../../Include/RmlUi/Core/Types.h"
-
 #include "EventSpecification.h"
 #include "FileInterfaceDefault.h"
 #include "GeometryDatabase.h"
@@ -46,69 +45,59 @@
 #include "StyleSheetParser.h"
 #include "TemplateCache.h"
 #include "TextureDatabase.h"
-#include "EventSpecification.h"
 
 #ifndef RMLUI_NO_FONT_INTERFACE_DEFAULT
-#include "FontEngineDefault/FontEngineInterfaceDefault.h"
+	#include "FontEngineDefault/FontEngineInterfaceDefault.h"
 #endif
 
 #ifdef RMLUI_ENABLE_LOTTIE_PLUGIN
-#include "../Lottie/LottiePlugin.h"
+	#include "../Lottie/LottiePlugin.h"
 #endif
 
 #ifdef RMLUI_ENABLE_SVG_PLUGIN
-#include "../SVG/SVGPlugin.h"
+	#include "../SVG/SVGPlugin.h"
 #endif
 
 #include "Pool.h"
 
-
 namespace Rml {
+using ContextMap = UnorderedMap<String, ContextPtr>;
+REGISTER_GLOBAL(RenderInterface*, render_interface);
+REGISTER_GLOBAL(SystemInterface*, system_interface);
+REGISTER_GLOBAL(FileInterface*, file_interface);
+REGISTER_GLOBAL(FontEngineInterface*, font_interface);
 
-// RmlUi's renderer interface.
-static RenderInterface* render_interface = nullptr;
-/// RmlUi's system interface.
-static SystemInterface* system_interface = nullptr;
-// RmlUi's file I/O interface.
-static FileInterface* file_interface = nullptr;
-// RmlUi's font engine interface.
-static FontEngineInterface* font_interface = nullptr;
-
-// Default interfaces should be created and destroyed on Initialise and Shutdown, respectively.
-static UniquePtr<FileInterface> default_file_interface;
-static UniquePtr<FontEngineInterface> default_font_interface;
+REGISTER_GLOBAL(UniquePtr<FileInterface>, default_file_interface);
+REGISTER_GLOBAL(UniquePtr<FontEngineInterface>, default_font_interface);
 
-static bool initialised = false;
-
-using ContextMap = UnorderedMap< String, ContextPtr >;
-static ContextMap contexts;
+REGISTER_GLOBAL(bool, initialised);
+REGISTER_GLOBAL(ContextMap, contexts);
 
 // The ObserverPtrBlock pool
-extern Pool<ObserverPtrBlock>* observerPtrBlockPool;
+REGISTER_EXTERN_GLOBAL(Pool<ObserverPtrBlock>*, observerPtrBlockPool);
 
 #ifndef RMLUI_VERSION
 	#define RMLUI_VERSION "custom"
 #endif
 
-
 bool Initialise()
 {
-	RMLUI_ASSERTMSG(!initialised, "Rml::Initialise() called, but RmlUi is already initialised!");
+	RMLUI_ASSERTMSG(!GET_OR_MAKE_GLOBAL(initialised), "Rml::Initialise() called, but RmlUi is already initialised!");
 
 	Log::Initialise();
 
 	// Check for valid interfaces, or install default interfaces as appropriate.
-	if (!system_interface)
-	{	
+	if (!GET_OR_MAKE_GLOBAL(system_interface))
+	{
 		Log::Message(Log::LT_ERROR, "No system interface set!");
 		return false;
 	}
 
-	if (!file_interface)
-	{		
+	if (!GET_OR_MAKE_GLOBAL(file_interface))
+	{
 #ifndef RMLUI_NO_FILE_INTERFACE_DEFAULT
-		default_file_interface = MakeUnique<FileInterfaceDefault>();
-		file_interface = default_file_interface.get();
+		GET_OR_MAKE_GLOBAL(default_file_interface) = MakeUnique<FileInterfaceDefault>();
+		GET_OR_MAKE_GLOBAL(file_interface) = GET_OR_MAKE_GLOBAL(default_file_interface).get();
 #else
 		Log::Message(Log::LT_ERROR, "No file interface set!");
 		return false;
@@ -119,11 +108,11 @@ bool Initialise()
 
 	TextureDatabase::Initialise();
 
-	if (!font_interface)
+	if (!GET_OR_MAKE_GLOBAL(font_interface))
 	{
 #ifndef RMLUI_NO_FONT_INTERFACE_DEFAULT
-		default_font_interface = MakeUnique<FontEngineInterfaceDefault>();
-		font_interface = default_font_interface.get();
+		GET_OR_MAKE_GLOBAL(default_font_interface) = MakeUnique<FontEngineInterfaceDefault>();
+		GET_OR_MAKE_GLOBAL(font_interface) = GET_OR_MAKE_GLOBAL(default_font_interface).get();
 #else
 		Log::Message(Log::LT_ERROR, "No font interface set!");
 		return false;
@@ -149,17 +138,17 @@ bool Initialise()
 	// Notify all plugins we're starting up.
 	PluginRegistry::NotifyInitialise();
 
-	initialised = true;
+	GET_OR_MAKE_GLOBAL(initialised) = true;
 
 	return true;
 }
 
 void Shutdown()
 {
-	RMLUI_ASSERTMSG(initialised, "Rml::Shutdown() called, but RmlUi is not initialised!");
+	RMLUI_ASSERTMSG(GET_OR_MAKE_GLOBAL(initialised), "Rml::Shutdown() called, but RmlUi is not initialised!");
 
 	// Clear out all contexts, which should also clean up all attached elements.
-	contexts.clear();
+	GET_OR_MAKE_GLOBAL(contexts).clear();
 
 	// Notify all plugins we're being shutdown.
 	PluginRegistry::NotifyShutdown();
@@ -170,18 +159,18 @@ void Shutdown()
 	StyleSheetParser::Shutdown();
 	StyleSheetSpecification::Shutdown();
 
-	font_interface = nullptr;
-	default_font_interface.reset();
+	GET_OR_MAKE_GLOBAL(font_interface) = nullptr;
+	GET_OR_MAKE_GLOBAL(default_font_interface).reset();
 
 	TextureDatabase::Shutdown();
 
-	initialised = false;
+	GET_OR_MAKE_GLOBAL(initialised) = false;
 
-	render_interface = nullptr;
-	file_interface = nullptr;
-	system_interface = nullptr;
+	GET_OR_MAKE_GLOBAL(render_interface) = nullptr;
+	GET_OR_MAKE_GLOBAL(file_interface) = nullptr;
+	GET_OR_MAKE_GLOBAL(system_interface) = nullptr;
 
-	default_file_interface.reset();
+	GET_OR_MAKE_GLOBAL(default_file_interface).reset();
 
 	Log::Shutdown();
 
@@ -198,60 +187,61 @@ String GetVersion()
 // Sets the interface through which all RmlUi messages will be routed.
 void SetSystemInterface(SystemInterface* _system_interface)
 {
-	system_interface = _system_interface;
+	GET_OR_MAKE_GLOBAL(system_interface) = _system_interface;
 }
 
 // Returns RmlUi's system interface.
 SystemInterface* GetSystemInterface()
 {
-	return system_interface;
+	return GET_OR_MAKE_GLOBAL(system_interface);
 }
 
 // Sets the interface through which all rendering requests are made.
 void SetRenderInterface(RenderInterface* _render_interface)
 {
-	render_interface = _render_interface;
+	GET_OR_MAKE_GLOBAL(render_interface) = _render_interface;
 }
 
 // Returns RmlUi's render interface.
 RenderInterface* GetRenderInterface()
 {
-	return render_interface;
+	return GET_OR_MAKE_GLOBAL(render_interface);
 }
 
 // Sets the interface through which all file I/O requests are made.
 void SetFileInterface(FileInterface* _file_interface)
 {
-	file_interface = _file_interface;
+	GET_OR_MAKE_GLOBAL(file_interface) = _file_interface;
 }
 
 // Returns RmlUi's file interface.
 FileInterface* GetFileInterface()
 {
-	return file_interface;
+	return GET_OR_MAKE_GLOBAL(file_interface);
 }
 
 // Sets the interface through which all font requests are made.
 void SetFontEngineInterface(FontEngineInterface* _font_interface)
 {
-	font_interface = _font_interface;
+	GET_OR_MAKE_GLOBAL(font_interface) = _font_interface;
 }
-	
+
 // Returns RmlUi's file interface.
 FontEngineInterface* GetFontEngineInterface()
 {
-	return font_interface;
+	return GET_OR_MAKE_GLOBAL(font_interface);
 }
 
 // Creates a new element context.
 Context* CreateContext(const String& name, const Vector2i dimensions, RenderInterface* custom_render_interface)
 {
-	if (!initialised)
+	if (!GET_OR_MAKE_GLOBAL(initialised))
 		return nullptr;
 
-	if (!custom_render_interface && !render_interface)
+	if (!custom_render_interface && !GET_OR_MAKE_GLOBAL(render_interface))
 	{
-		Log::Message(Log::LT_WARNING, "Failed to create context '%s', no render interface specified and no default render interface exists.", name.c_str());
+		Log::Message(Log::LT_WARNING, "Failed to create context '%s', no render interface specified and no default render interface exists.",
+			name.c_str());
 		return nullptr;
 	}
 
@@ -272,12 +262,12 @@ Context* CreateContext(const String& name, const Vector2i dimensions, RenderInte
 	if (custom_render_interface)
 		new_context->render_interface = custom_render_interface;
 	else
-		new_context->render_interface = render_interface;
+		new_context->render_interface = GET_OR_MAKE_GLOBAL(render_interface);
 
 	new_context->SetDimensions(dimensions);
 
 	Context* new_context_raw = new_context.get();
-	contexts[name] = std::move(new_context);
+	GET_OR_MAKE_GLOBAL(contexts)[name] = std::move(new_context);
 
 	PluginRegistry::NotifyContextCreate(new_context_raw);
 
@@ -286,10 +276,10 @@ Context* CreateContext(const String& name, const Vector2i dimensions, RenderInte
 
 bool RemoveContext(const String& name)
 {
-	auto it = contexts.find(name);
-	if (it != contexts.end())
+	auto it = GET_OR_MAKE_GLOBAL(contexts).find(name);
+	if (it != GET_OR_MAKE_GLOBAL(contexts).end())
 	{
-		contexts.erase(it);
+		GET_OR_MAKE_GLOBAL(contexts).erase(it);
 		return true;
 	}
 	return false;
@@ -298,8 +288,8 @@ bool RemoveContext(const String& name)
 // Fetches a previously constructed context by name.
 Context* GetContext(const String& name)
 {
-	ContextMap::iterator i = contexts.find(name);
-	if (i == contexts.end())
+	ContextMap::iterator i = GET_OR_MAKE_GLOBAL(contexts).find(name);
+	if (i == GET_OR_MAKE_GLOBAL(contexts).end())
 		return nullptr;
 
 	return i->second.get();
@@ -308,9 +298,9 @@ Context* GetContext(const String& name)
 // Fetches a context by index.
 Context* GetContext(int index)
 {
-	ContextMap::iterator i = contexts.begin();
+	ContextMap::iterator i = GET_OR_MAKE_GLOBAL(contexts).begin();
 	int count = 0;
-	
+
 	if (index < 0 || index >= GetNumContexts())
 		return nullptr;
 
@@ -320,7 +310,7 @@ Context* GetContext(int index)
 		++count;
 	}
 
-	if (i == contexts.end())
+	if (i == GET_OR_MAKE_GLOBAL(contexts).end())
 		return nullptr;
 
 	return i->second.get();
@@ -329,23 +319,23 @@ Context* GetContext(int index)
 // Returns the number of active contexts.
 int GetNumContexts()
 {
-	return (int) contexts.size();
+	return (int)GET_OR_MAKE_GLOBAL(contexts).size();
 }
 
 bool LoadFontFace(const String& file_path, bool fallback_face, Style::FontWeight weight)
 {
-	return font_interface->LoadFontFace(file_path, fallback_face, weight);
+	return GET_OR_MAKE_GLOBAL(font_interface)->LoadFontFace(file_path, fallback_face, weight);
 }
 
 bool LoadFontFace(const byte* data, int data_size, const String& font_family, Style::FontStyle style, Style::FontWeight weight, bool fallback_face)
 {
-	return font_interface->LoadFontFace(data, data_size, font_family, style, weight, fallback_face);
+	return GET_OR_MAKE_GLOBAL(font_interface)->LoadFontFace(data, data_size, font_family, style, weight, fallback_face);
 }
 
 // Registers a generic rmlui plugin
 void RegisterPlugin(Plugin* plugin)
 {
-	if (initialised)
+	if (GET_OR_MAKE_GLOBAL(initialised))
 		plugin->OnInitialise();
 
 	PluginRegistry::RegisterPlugin(plugin);
@@ -356,7 +346,7 @@ void UnregisterPlugin(Plugin* plugin)
 {
 	PluginRegistry::UnregisterPlugin(plugin);
 
-	if(initialised)
+	if (GET_OR_MAKE_GLOBAL(initialised))
 		plugin->OnShutdown();
 }
 
@@ -382,23 +372,23 @@ void ReleaseCompiledGeometry()
 
 void ReleaseMemoryPools()
 {
-	if (observerPtrBlockPool && observerPtrBlockPool->GetNumAllocatedObjects() <= 0)
+	if (GET_OR_MAKE_GLOBAL(observerPtrBlockPool) && GET_OR_MAKE_GLOBAL(observerPtrBlockPool)->GetNumAllocatedObjects() <= 0)
 	{
-		delete observerPtrBlockPool;
-		observerPtrBlockPool = nullptr;
+		delete GET_OR_MAKE_GLOBAL(observerPtrBlockPool);
+		GET_OR_MAKE_GLOBAL(observerPtrBlockPool) = nullptr;
 	}
 }
 
 void ReleaseFontResources()
 {
-	if (font_interface)
+	if (GET_OR_MAKE_GLOBAL(font_interface))
 	{
-		for (const auto& name_context : contexts)
+		for (const auto& name_context : GET_OR_MAKE_GLOBAL(contexts))
 			name_context.second->GetRootElement()->DirtyFontFaceRecursive();
 
-		font_interface->ReleaseFontResources();
+		GET_OR_MAKE_GLOBAL(font_interface)->ReleaseFontResources();
 
-		for (const auto& name_context : contexts)
+		for (const auto& name_context : GET_OR_MAKE_GLOBAL(contexts))
 			name_context.second->Update();
 	}
 }
diff --git externals/rmlui/Source/Core/DataVariable.cpp externals/rmlui/Source/Core/DataVariable.cpp
index 34102a02..5b64996a 100644
--- externals/rmlui/Source/Core/DataVariable.cpp
+++ externals/rmlui/Source/Core/DataVariable.cpp
@@ -27,6 +27,7 @@
  */
 
 #include "../../Include/RmlUi/Core/DataVariable.h"
+#include "../../Include/RmlUi/Core/Context.h"
 
 namespace Rml {
 
@@ -79,10 +80,11 @@ public:
     }
 };
 
+REGISTER_GLOBAL(LiteralIntDefinition, literal_int_definition);
+
 DataVariable MakeLiteralIntVariable(int value)
 {
-    static LiteralIntDefinition literal_int_definition;
-    return DataVariable(&literal_int_definition, reinterpret_cast<void*>(static_cast<intptr_t>(value)));
+    return DataVariable(&GET_OR_MAKE_GLOBAL(literal_int_definition), reinterpret_cast<void*>(static_cast<intptr_t>(value)));
 }
 
 StructDefinition::StructDefinition() : VariableDefinition(DataVariableType::Struct)
diff --git externals/rmlui/Source/Core/Element.cpp externals/rmlui/Source/Core/Element.cpp
index 016ab833..cf4ce2cc 100644
--- externals/rmlui/Source/Core/Element.cpp
+++ externals/rmlui/Source/Core/Element.cpp
@@ -15,7 +15,7 @@
  *
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -26,20 +26,19 @@
  *
  */
 
-  
 #include "../../Include/RmlUi/Core/Element.h"
 #include "../../Include/RmlUi/Core/Context.h"
 #include "../../Include/RmlUi/Core/Core.h"
+#include "../../Include/RmlUi/Core/Dictionary.h"
 #include "../../Include/RmlUi/Core/ElementDocument.h"
 #include "../../Include/RmlUi/Core/ElementInstancer.h"
 #include "../../Include/RmlUi/Core/ElementScroll.h"
 #include "../../Include/RmlUi/Core/ElementUtilities.h"
 #include "../../Include/RmlUi/Core/Factory.h"
-#include "../../Include/RmlUi/Core/Dictionary.h"
 #include "../../Include/RmlUi/Core/Profiling.h"
-#include "../../Include/RmlUi/Core/PropertyIdSet.h"
 #include "../../Include/RmlUi/Core/PropertiesIteratorView.h"
 #include "../../Include/RmlUi/Core/PropertyDefinition.h"
+#include "../../Include/RmlUi/Core/PropertyIdSet.h"
 #include "../../Include/RmlUi/Core/StyleSheet.h"
 #include "../../Include/RmlUi/Core/StyleSheetSpecification.h"
 #include "../../Include/RmlUi/Core/TransformPrimitive.h"
@@ -48,17 +47,17 @@
 #include "DataModel.h"
 #include "ElementAnimation.h"
 #include "ElementBackgroundBorder.h"
+#include "ElementDecoration.h"
 #include "ElementDefinition.h"
 #include "ElementStyle.h"
 #include "EventDispatcher.h"
 #include "EventSpecification.h"
-#include "ElementDecoration.h"
 #include "LayoutEngine.h"
 #include "PluginRegistry.h"
-#include "PropertiesIterator.h"
 #include "Pool.h"
-#include "StyleSheetParser.h"
+#include "PropertiesIterator.h"
 #include "StyleSheetNode.h"
+#include "StyleSheetParser.h"
 #include "TransformState.h"
 #include "TransformUtilities.h"
 #include "XMLParseTools.h"
@@ -92,8 +91,7 @@ static float GetScrollOffsetDelta(ScrollAlignment alignment, float begin_offset,
 }
 
 // Meta objects for element collected in a single struct to reduce memory allocations
-struct ElementMeta
-{
+struct ElementMeta {
 	ElementMeta(Element* el) : event_dispatcher(el), style(el), background_border(el), decoration(el), scroll(el), computed_values(el) {}
 	SmallUnorderedMap<EventId, EventListener*> attribute_event_listeners;
 	EventDispatcher event_dispatcher;
@@ -104,7 +102,8 @@ struct ElementMeta
 	Style::ComputedValues computed_values;
 };
 
-static Pool< ElementMeta > element_meta_chunk_pool(200, true);
+#define element_meta_chunk_pool_params 200, true
+REGISTER_INIT_GLOBAL(Pool<ElementMeta>, element_meta_chunk_pool);
 
 Element::Element(const String& tag) :
 	local_stacking_context(false), local_stacking_context_forced(false), stacking_context_dirty(false), computed_values_are_default_initialized(true),
@@ -129,13 +128,13 @@ Element::Element(const String& tag) :
 
 	z_index = 0;
 
-	meta = element_meta_chunk_pool.AllocateAndConstruct(this);
+	meta = GET_OR_MAKE_INIT_GLOBAL(element_meta_chunk_pool).AllocateAndConstruct(this);
 	data_model = nullptr;
 }
 
 Element::~Element()
 {
-	RMLUI_ASSERT(parent == nullptr);	
+	RMLUI_ASSERT(parent == nullptr);
 
 	PluginRegistry::NotifyElementDestroy(this);
 
@@ -152,7 +151,7 @@ Element::~Element()
 	children.clear();
 	num_non_dom_children = 0;
 
-	element_meta_chunk_pool.DestroyAndDeallocate(meta);
+	GET_OR_MAKE_INIT_GLOBAL(element_meta_chunk_pool).DestroyAndDeallocate(meta);
 }
 
 void Element::Update(float dp_ratio, Vector2f vp_dimensions)
@@ -197,7 +196,8 @@ void Element::UpdateProperties(const float dp_ratio, const Vector2f vp_dimension
 		const ComputedValues* document_values = owner_document ? &owner_document->GetComputedValues() : nullptr;
 
 		// Compute values and clear dirty properties
-		PropertyIdSet dirty_properties = meta->style.ComputeValues(meta->computed_values, parent_values, document_values, computed_values_are_default_initialized, dp_ratio, vp_dimensions);
+		PropertyIdSet dirty_properties = meta->style.ComputeValues(meta->computed_values, parent_values, document_values,
+			computed_values_are_default_initialized, dp_ratio, vp_dimensions);
 
 		computed_values_are_default_initialized = false;
 
@@ -319,7 +319,7 @@ String Element::GetClassNames() const
 // Returns the active style sheet for this element. This may be nullptr.
 const StyleSheet* Element::GetStyleSheet() const
 {
-	if (ElementDocument * document = GetOwnerDocument())
+	if (ElementDocument* document = GetOwnerDocument())
 		return document->GetStyleSheet();
 	return nullptr;
 }
@@ -371,9 +371,7 @@ void Element::SetOffset(Vector2f offset, Element* _offset_parent, bool _offset_f
 
 	// If our offset has definitely changed, or any of our parenting has, then these are set and
 	// updated based on our left / right / top / bottom properties.
-	if (relative_offset_base != offset ||
-		offset_parent != _offset_parent ||
-		offset_fixed != _offset_fixed)
+	if (relative_offset_base != offset || offset_parent != _offset_parent || offset_fixed != _offset_fixed)
 	{
 		relative_offset_base = offset;
 		offset_fixed = _offset_fixed;
@@ -391,8 +389,7 @@ void Element::SetOffset(Vector2f offset, Element* _offset_parent, bool _offset_f
 
 		UpdateOffset();
 
-		if (old_base != relative_offset_base ||
-			old_position != relative_offset_position)
+		if (old_base != relative_offset_base || old_position != relative_offset_position)
 			DirtyAbsoluteOffset();
 	}
 }
@@ -448,8 +445,7 @@ Box::Area Element::GetClientArea() const
 // Sets the dimensions of the element's internal content.
 void Element::SetContentBox(Vector2f _content_offset, Vector2f _content_box)
 {
-	if (content_offset != _content_offset ||
-		content_box != _content_box)
+	if (content_offset != _content_offset || content_box != _content_box)
 	{
 		// Seems to be jittering a wee bit; might need to be looked at.
 		scroll_offset.x += (content_offset.x - _content_offset.x);
@@ -483,7 +479,7 @@ void Element::SetBox(const Box& box)
 // Adds a box to the end of the list describing this element's geometry.
 void Element::AddBox(const Box& box, Vector2f offset)
 {
-	additional_boxes.emplace_back(PositionedBox{ box, offset });
+	additional_boxes.emplace_back(PositionedBox{box, offset});
 
 	OnResize();
 
@@ -505,7 +501,7 @@ const Box& Element::GetBox(int index, Vector2f& offset)
 
 	if (index < 1)
 		return main_box;
-	
+
 	const int additional_box_index = index - 1;
 	if (additional_box_index >= (int)additional_boxes.size())
 		return main_box;
@@ -547,9 +543,7 @@ bool Element::IsPointWithinElement(const Vector2f point)
 
 		const Vector2f box_position = position + box_offset;
 		const Vector2f box_dimensions = box.GetSize(Box::BORDER);
-		if (point.x >= box_position.x &&
-			point.x <= (box_position.x + box_dimensions.x) &&
-			point.y >= box_position.y &&
+		if (point.x >= box_position.x && point.x <= (box_position.x + box_dimensions.x) && point.y >= box_position.y &&
 			point.y <= (box_position.y + box_dimensions.y))
 		{
 			return true;
@@ -641,7 +635,7 @@ const PropertyMap& Element::GetLocalStyleProperties()
 	return meta->style.GetLocalStyleProperties();
 }
 
-float Element::ResolveNumericProperty(const Property *property, float base_value)
+float Element::ResolveNumericProperty(const Property* property, float base_value)
 {
 	return meta->style.ResolveNumericProperty(property, base_value);
 }
@@ -660,7 +654,7 @@ float Element::ResolveNumericProperty(const String& property_name)
 		relative_target = property->definition->GetRelativeTarget();
 
 	float result = meta->style.ResolveLength(property, relative_target);
-	
+
 	return result;
 }
 
@@ -678,12 +672,12 @@ Vector2f Element::GetContainingBlock()
 		{
 			containing_block = parent_box.GetSize();
 		}
-		else if(position_property == Position::Absolute || position_property == Position::Fixed)
+		else if (position_property == Position::Absolute || position_property == Position::Fixed)
 		{
 			containing_block = parent_box.GetSize(Box::PADDING);
 		}
 	}
-	
+
 	return containing_block;
 }
 
@@ -708,7 +702,7 @@ float Element::GetLineHeight()
 }
 
 // Returns this element's TransformState
-const TransformState *Element::GetTransformState() const noexcept
+const TransformState* Element::GetTransformState() const noexcept
 {
 	return transform_state.get();
 }
@@ -716,7 +710,7 @@ const TransformState *Element::GetTransformState() const noexcept
 // Project a 2D point in pixel coordinates onto the element's plane.
 bool Element::Project(Vector2f& point) const noexcept
 {
-	if(!transform_state || !transform_state->GetTransform())
+	if (!transform_state || !transform_state->GetTransform())
 		return true;
 
 	// The input point is in window coordinates. Need to find the projection of the point onto the current element plane,
@@ -725,23 +719,20 @@ bool Element::Project(Vector2f& point) const noexcept
 	if (const Matrix4f* inv_transform = transform_state->GetInverseTransform())
 	{
 		// Pick two points forming a line segment perpendicular to the window.
-		Vector4f window_points[2] = {{ point.x, point.y, -10, 1}, { point.x, point.y, 10, 1 }};
+		Vector4f window_points[2] = {{point.x, point.y, -10, 1}, {point.x, point.y, 10, 1}};
 
 		// Project them into the local element space.
 		window_points[0] = *inv_transform * window_points[0];
 		window_points[1] = *inv_transform * window_points[1];
 
-		Vector3f local_points[2] = {
-			window_points[0].PerspectiveDivide(),
-			window_points[1].PerspectiveDivide()
-		};
+		Vector3f local_points[2] = {window_points[0].PerspectiveDivide(), window_points[1].PerspectiveDivide()};
 
 		// Construct a ray from the two projected points in the local space of the current element.
 		// Find the intersection with the z=0 plane to produce our destination point.
 		Vector3f ray = local_points[1] - local_points[0];
 
 		// Only continue if we are not close to parallel with the plane.
-		if(std::fabs(ray.z) > 1.0f)
+		if (std::fabs(ray.z) > 1.0f)
 		{
 			// Solving the line equation p = p0 + t*ray for t, knowing that p.z = 0, produces the following.
 			float t = -local_points[0].z / ray.z;
@@ -761,7 +752,6 @@ PropertiesIteratorView Element::IterateLocalProperties() const
 	return PropertiesIteratorView(MakeUnique<PropertiesIterator>(meta->style.Iterate()));
 }
 
-
 // Sets or removes a pseudo-class on the element.
 void Element::SetPseudoClass(const String& pseudo_class, bool activate)
 {
@@ -998,7 +988,7 @@ float Element::GetScrollTop()
 void Element::SetScrollTop(float scroll_top)
 {
 	const float new_offset = Math::Clamp(Math::RoundFloat(scroll_top), 0.0f, GetScrollHeight() - GetClientHeight());
-	if(new_offset != scroll_offset.y)
+	if (new_offset != scroll_offset.y)
 	{
 		scroll_offset.y = new_offset;
 		meta->scroll.UpdateScrollbar(ElementScroll::VERTICAL);
@@ -1062,7 +1052,7 @@ Element* Element::Closest(const String& selectors) const
 
 	Element* parent = GetParentNode();
 
-	while(parent)
+	while (parent)
 	{
 		for (const StyleSheetNode* node : leaf_nodes)
 		{
@@ -1071,7 +1061,7 @@ Element* Element::Closest(const String& selectors) const
 				return parent;
 			}
 		}
-		
+
 		parent = parent->GetParentNode();
 	}
 
@@ -1128,7 +1118,7 @@ Element* Element::GetLastChild() const
 
 Element* Element::GetChild(int index) const
 {
-	if (index < 0 || index >= (int) children.size())
+	if (index < 0 || index >= (int)children.size())
 		return nullptr;
 
 	return children[index].get();
@@ -1136,7 +1126,7 @@ Element* Element::GetChild(int index) const
 
 int Element::GetNumChildren(bool include_non_dom_elements) const
 {
-	return (int) children.size() - (include_non_dom_elements ? 0 : num_non_dom_children);
+	return (int)children.size() - (include_non_dom_elements ? 0 : num_non_dom_children);
 }
 
 // Gets the markup and content of the element.
@@ -1149,7 +1139,8 @@ void Element::GetInnerRML(String& content) const
 }
 
 // Gets the markup and content of the element.
-String Element::GetInnerRML() const {
+String Element::GetInnerRML() const
+{
 	String result;
 	GetInnerRML(result);
 	return result;
@@ -1161,10 +1152,10 @@ void Element::SetInnerRML(const String& rml)
 	RMLUI_ZoneScopedC(0x6495ED);
 
 	// Remove all DOM children.
-	while ((int) children.size() > num_non_dom_children)
+	while ((int)children.size() > num_non_dom_children)
 		RemoveChild(children.front().get());
 
-	if(!rml.empty())
+	if (!rml.empty())
 		Factory::InstanceElementText(this, rml);
 }
 
@@ -1254,12 +1245,12 @@ void Element::RemoveEventListener(EventId id, EventListener* listener, bool in_c
 	meta->event_dispatcher.DetachEvent(id, listener, in_capture_phase);
 }
 
-
 // Dispatches the specified event
 bool Element::DispatchEvent(const String& type, const Dictionary& parameters)
 {
 	const EventSpecification& specification = EventSpecificationInterface::GetOrInsert(type);
-	return EventDispatcher::DispatchEvent(this, specification.id, type, parameters, specification.interruptible, specification.bubbles, specification.default_action_phase);
+	return EventDispatcher::DispatchEvent(this, specification.id, type, parameters, specification.interruptible, specification.bubbles,
+		specification.default_action_phase);
 }
 
 // Dispatches the specified event
@@ -1273,7 +1264,8 @@ bool Element::DispatchEvent(const String& type, const Dictionary& parameters, bo
 bool Element::DispatchEvent(EventId id, const Dictionary& parameters)
 {
 	const EventSpecification& specification = EventSpecificationInterface::Get(id);
-	return EventDispatcher::DispatchEvent(this, specification.id, specification.type, parameters, specification.interruptible, specification.bubbles, specification.default_action_phase);
+	return EventDispatcher::DispatchEvent(this, specification.id, specification.type, parameters, specification.interruptible, specification.bubbles,
+		specification.default_action_phase);
 }
 
 // Scrolls the parent element's contents so that this element is visible.
@@ -1383,7 +1375,7 @@ Element* Element::InsertBefore(ElementPtr child, Element* adjacent_element)
 	{
 		child_ptr = child.get();
 
-		if ((int) child_index >= GetNumChildren())
+		if ((int)child_index >= GetNumChildren())
 			num_non_dom_children++;
 		else
 			DirtyLayout();
@@ -1401,7 +1393,7 @@ Element* Element::InsertBefore(ElementPtr child, Element* adjacent_element)
 	else
 	{
 		child_ptr = AppendChild(std::move(child));
-	}	
+	}
 
 	return child_ptr;
 }
@@ -1463,7 +1455,7 @@ ElementPtr Element::RemoveChild(Element* child)
 
 				// If this child (or a descendant of this child) is the context's currently
 				// focused element, set the focus to us instead.
-				if (Context * context = GetContext())
+				if (Context* context = GetContext())
 				{
 					Element* focus_element = context->GetFocusElement();
 					while (focus_element)
@@ -1494,10 +1486,9 @@ ElementPtr Element::RemoveChild(Element* child)
 	return nullptr;
 }
 
-
 bool Element::HasChildNodes() const
 {
-	return (int) children.size() > num_non_dom_children;
+	return (int)children.size() > num_non_dom_children;
 }
 
 Element* Element::GetElementById(const String& id)
@@ -1662,31 +1653,19 @@ void Element::ForceLocalStackingContext()
 }
 
 // Called during the update loop after children are rendered.
-void Element::OnUpdate()
-{
-}
+void Element::OnUpdate() {}
 
 // Called during render after backgrounds, borders, decorators, but before children, are rendered.
-void Element::OnRender()
-{
-}
+void Element::OnRender() {}
 
-void Element::OnResize()
-{
-}
+void Element::OnResize() {}
 
 // Called during a layout operation, when the element is being positioned and sized.
-void Element::OnLayout()
-{
-}
+void Element::OnLayout() {}
 
-void Element::OnDpRatioChange()
-{
-}
+void Element::OnDpRatioChange() {}
 
-void Element::OnStyleSheetChange()
-{
-}
+void Element::OnStyleSheetChange() {}
 
 // Called when attributes on the element are changed.
 void Element::OnAttributeChange(const ElementAttributes& changed_attributes)
@@ -1703,8 +1682,10 @@ void Element::OnAttributeChange(const ElementAttributes& changed_attributes)
 		{
 			meta->style.SetClassNames(value.Get<String>());
 		}
-		else if (((attribute == "colspan" || attribute == "rowspan") && meta->computed_values.display() == Style::Display::TableCell)
-			|| (attribute == "span" && (meta->computed_values.display() == Style::Display::TableColumn || meta->computed_values.display() == Style::Display::TableColumnGroup)))
+		else if (((attribute == "colspan" || attribute == "rowspan") && meta->computed_values.display() == Style::Display::TableCell) ||
+			(attribute == "span" &&
+				(meta->computed_values.display() == Style::Display::TableColumn ||
+					meta->computed_values.display() == Style::Display::TableColumnGroup)))
 		{
 			DirtyLayout();
 		}
@@ -1715,8 +1696,7 @@ void Element::OnAttributeChange(const ElementAttributes& changed_attributes)
 			auto& attribute_event_listeners = meta->attribute_event_listeners;
 			auto& event_dispatcher = meta->event_dispatcher;
 			const auto event_id = EventSpecificationInterface::GetIdOrInsert(attribute.substr(2));
-			const auto remove_event_listener_if_exists = [&attribute_event_listeners, &event_dispatcher, event_id]()
-			{
+			const auto remove_event_listener_if_exists = [&attribute_event_listeners, &event_dispatcher, event_id]() {
 				const auto listener_it = attribute_event_listeners.find(event_id);
 				if (listener_it != attribute_event_listeners.cend())
 				{
@@ -1762,12 +1742,8 @@ void Element::OnAttributeChange(const ElementAttributes& changed_attributes)
 void Element::OnPropertyChange(const PropertyIdSet& changed_properties)
 {
 	RMLUI_ZoneScoped;
-	const bool top_right_bottom_left_changed = (
-		changed_properties.Contains(PropertyId::Top) ||
-		changed_properties.Contains(PropertyId::Right) ||
-		changed_properties.Contains(PropertyId::Bottom) ||
-		changed_properties.Contains(PropertyId::Left)
-	);
+	const bool top_right_bottom_left_changed = (changed_properties.Contains(PropertyId::Top) || changed_properties.Contains(PropertyId::Right) ||
+		changed_properties.Contains(PropertyId::Bottom) || changed_properties.Contains(PropertyId::Left));
 
 	// See if the document layout needs to be updated.
 	if (!IsLayoutDirty())
@@ -1804,14 +1780,13 @@ void Element::OnPropertyChange(const PropertyIdSet& changed_properties)
 		UpdateOffset();
 		DirtyAbsoluteOffset();
 	}
-	
+
 	// Update the visibility.
-	if (changed_properties.Contains(PropertyId::Visibility) ||
-		changed_properties.Contains(PropertyId::Display))
+	if (changed_properties.Contains(PropertyId::Visibility) || changed_properties.Contains(PropertyId::Display))
 	{
 		bool new_visibility =
 			(meta->computed_values.display() != Style::Display::None && meta->computed_values.visibility() == Style::Visibility::Visible);
-			
+
 		if (visible != new_visibility)
 		{
 			visible = new_visibility;
@@ -1831,8 +1806,7 @@ void Element::OnPropertyChange(const PropertyIdSet& changed_properties)
 
 		if (z_index_property.type == Style::ZIndex::Auto)
 		{
-			if (local_stacking_context &&
-				!local_stacking_context_forced)
+			if (local_stacking_context && !local_stacking_context_forced)
 			{
 				// We're no longer acting as a stacking context.
 				local_stacking_context = false;
@@ -1867,38 +1841,28 @@ void Element::OnPropertyChange(const PropertyIdSet& changed_properties)
 			}
 		}
 	}
-	
-	const bool border_radius_changed = (
-		changed_properties.Contains(PropertyId::BorderTopLeftRadius) ||
-		changed_properties.Contains(PropertyId::BorderTopRightRadius) ||
-		changed_properties.Contains(PropertyId::BorderBottomRightRadius) ||
-		changed_properties.Contains(PropertyId::BorderBottomLeftRadius)
-	);
+
+	const bool border_radius_changed =
+		(changed_properties.Contains(PropertyId::BorderTopLeftRadius) || changed_properties.Contains(PropertyId::BorderTopRightRadius) ||
+			changed_properties.Contains(PropertyId::BorderBottomRightRadius) || changed_properties.Contains(PropertyId::BorderBottomLeftRadius));
 
 	// Dirty the background if it's changed.
-    if (border_radius_changed ||
-		changed_properties.Contains(PropertyId::BackgroundColor) ||
-		changed_properties.Contains(PropertyId::Opacity) ||
+	if (border_radius_changed || changed_properties.Contains(PropertyId::BackgroundColor) || changed_properties.Contains(PropertyId::Opacity) ||
 		changed_properties.Contains(PropertyId::ImageColor))
 	{
 		meta->background_border.DirtyBackground();
-    }
+	}
 
 	// Dirty the border if it's changed.
-	if (border_radius_changed ||
-		changed_properties.Contains(PropertyId::BorderTopWidth) ||
-		changed_properties.Contains(PropertyId::BorderRightWidth) ||
-		changed_properties.Contains(PropertyId::BorderBottomWidth) ||
-		changed_properties.Contains(PropertyId::BorderLeftWidth) ||
-		changed_properties.Contains(PropertyId::BorderTopColor) ||
-		changed_properties.Contains(PropertyId::BorderRightColor) ||
-		changed_properties.Contains(PropertyId::BorderBottomColor) ||
-		changed_properties.Contains(PropertyId::BorderLeftColor) ||
-		changed_properties.Contains(PropertyId::Opacity))
+	if (border_radius_changed || changed_properties.Contains(PropertyId::BorderTopWidth) ||
+		changed_properties.Contains(PropertyId::BorderRightWidth) || changed_properties.Contains(PropertyId::BorderBottomWidth) ||
+		changed_properties.Contains(PropertyId::BorderLeftWidth) || changed_properties.Contains(PropertyId::BorderTopColor) ||
+		changed_properties.Contains(PropertyId::BorderRightColor) || changed_properties.Contains(PropertyId::BorderBottomColor) ||
+		changed_properties.Contains(PropertyId::BorderLeftColor) || changed_properties.Contains(PropertyId::Opacity))
 	{
 		meta->background_border.DirtyBorder();
 	}
-	
+
 	// Dirty the decoration if it's changed.
 	if (border_radius_changed || changed_properties.Contains(PropertyId::Decorator))
 	{
@@ -1906,26 +1870,21 @@ void Element::OnPropertyChange(const PropertyIdSet& changed_properties)
 	}
 
 	// Dirty the decoration data when its visual looks may have changed.
-	if (border_radius_changed ||
-		changed_properties.Contains(PropertyId::Opacity) ||
-		changed_properties.Contains(PropertyId::ImageColor))
+	if (border_radius_changed || changed_properties.Contains(PropertyId::Opacity) || changed_properties.Contains(PropertyId::ImageColor))
 	{
 		meta->decoration.DirtyDecoratorsData();
 	}
 
 	// Check for `perspective' and `perspective-origin' changes
-	if (changed_properties.Contains(PropertyId::Perspective) ||
-		changed_properties.Contains(PropertyId::PerspectiveOriginX) ||
+	if (changed_properties.Contains(PropertyId::Perspective) || changed_properties.Contains(PropertyId::PerspectiveOriginX) ||
 		changed_properties.Contains(PropertyId::PerspectiveOriginY))
 	{
 		DirtyTransformState(true, false);
 	}
 
 	// Check for `transform' and `transform-origin' changes
-	if (changed_properties.Contains(PropertyId::Transform) ||
-		changed_properties.Contains(PropertyId::TransformOriginX) ||
-		changed_properties.Contains(PropertyId::TransformOriginY) ||
-		changed_properties.Contains(PropertyId::TransformOriginZ))
+	if (changed_properties.Contains(PropertyId::Transform) || changed_properties.Contains(PropertyId::TransformOriginX) ||
+		changed_properties.Contains(PropertyId::TransformOriginY) || changed_properties.Contains(PropertyId::TransformOriginZ))
 	{
 		DirtyTransformState(false, true);
 	}
@@ -1942,19 +1901,13 @@ void Element::OnPropertyChange(const PropertyIdSet& changed_properties)
 	}
 }
 
-void Element::OnPseudoClassChange(const String& /*pseudo_class*/, bool /*activate*/)
-{
-}
+void Element::OnPseudoClassChange(const String& /*pseudo_class*/, bool /*activate*/) {}
 
 // Called when a child node has been added somewhere in the hierarchy
-void Element::OnChildAdd(Element* /*child*/)
-{
-}
+void Element::OnChildAdd(Element* /*child*/) {}
 
 // Called when a child node has been removed somewhere in the hierarchy
-void Element::OnChildRemove(Element* /*child*/)
-{
-}
+void Element::OnChildRemove(Element* /*child*/) {}
 
 void Element::DirtyLayout()
 {
@@ -1984,18 +1937,16 @@ void Element::ProcessDefaultAction(Event& event)
 		if (GetScrollHeight() > GetClientHeight())
 		{
 			Style::Overflow overflow_property = meta->computed_values.overflow_y();
-			if (overflow_property == Style::Overflow::Auto ||
-				overflow_property == Style::Overflow::Scroll)
+			if (overflow_property == Style::Overflow::Auto || overflow_property == Style::Overflow::Scroll)
 			{
 				// Stop the propagation if the current element has scrollbars.
 				// This prevents scrolling in parent elements, which is often unintended. If instead desired behavior is
 				// to scroll in parent elements when reaching top/bottom, move StopPropagation inside the next if statement.
 				event.StopPropagation();
 
-				const float wheel_delta = event.GetParameter< float >("wheel_delta", 0.f);
+				const float wheel_delta = event.GetParameter<float>("wheel_delta", 0.f);
 
-				if ((wheel_delta < 0 && GetScrollTop() > 0) ||
-					(wheel_delta > 0 && GetScrollHeight() > GetScrollTop() + GetClientHeight()))
+				if ((wheel_delta < 0 && GetScrollTop() > 0) || (wheel_delta > 0 && GetScrollHeight() > GetScrollTop() + GetClientHeight()))
 				{
 					// Defined as three times the default line-height, multiplied by the dp ratio.
 					float default_scroll_length = 3.f * DefaultComputedValues.line_height().value;
@@ -2014,20 +1965,11 @@ void Element::ProcessDefaultAction(Event& event)
 	{
 		switch (event.GetId())
 		{
-		case EventId::Mouseover:
-			SetPseudoClass("hover", true);
-			break;
-		case EventId::Mouseout:
-			SetPseudoClass("hover", false);
-			break;
-		case EventId::Focus:
-			SetPseudoClass("focus", true);
-			break;
-		case EventId::Blur:
-			SetPseudoClass("focus", false);
-			break;
-		default:
-			break;
+		case EventId::Mouseover: SetPseudoClass("hover", true); break;
+		case EventId::Mouseout: SetPseudoClass("hover", false); break;
+		case EventId::Focus: SetPseudoClass("focus", true); break;
+		case EventId::Blur: SetPseudoClass("focus", false); break;
+		default: break;
 		}
 	}
 }
@@ -2093,7 +2035,7 @@ void Element::SetOwnerDocument(ElementDocument* document)
 	}
 }
 
-void Element::SetDataModel(DataModel* new_data_model) 
+void Element::SetDataModel(DataModel* new_data_model)
 {
 	RMLUI_ASSERTMSG(!data_model || !new_data_model, "We must either attach a new data model, or detach the old one.");
 
@@ -2121,7 +2063,7 @@ void Element::Release()
 }
 
 void Element::SetParent(Element* _parent)
-{	
+{
 	// Assumes we are already detached from the hierarchy or we are detaching now.
 	RMLUI_ASSERT(!parent || !_parent);
 
@@ -2145,7 +2087,7 @@ void Element::SetParent(Element* _parent)
 		if (data_model)
 			SetDataModel(nullptr);
 	}
-	else 
+	else
 	{
 		auto it = attributes.find("data-model");
 		if (it == attributes.end())
@@ -2155,7 +2097,8 @@ void Element::SetParent(Element* _parent)
 		else if (parent->data_model)
 		{
 			String name = it->second.Get<String>();
-			Log::Message(Log::LT_ERROR, "Nested data models are not allowed. Data model '%s' given in element %s.", name.c_str(), GetAddress().c_str());
+			Log::Message(Log::LT_ERROR, "Nested data models are not allowed. Data model '%s' given in element %s.", name.c_str(),
+				GetAddress().c_str());
 		}
 		else if (Context* context = GetContext())
 		{
@@ -2197,8 +2140,7 @@ void Element::UpdateOffset()
 	const auto& computed = meta->computed_values;
 	Position position_property = computed.position();
 
-	if (position_property == Position::Absolute ||
-		position_property == Position::Fixed)
+	if (position_property == Position::Absolute || position_property == Position::Fixed)
 	{
 		if (offset_parent != nullptr)
 		{
@@ -2278,7 +2220,8 @@ void Element::BuildLocalStackingContext()
 	stacking_context.clear();
 
 	BuildStackingContext(&stacking_context);
-	std::stable_sort(stacking_context.begin(), stacking_context.end(), [](const Element* lhs, const Element* rhs) { return lhs->GetZIndex() < rhs->GetZIndex(); });
+	std::stable_sort(stacking_context.begin(), stacking_context.end(),
+		[](const Element* lhs, const Element* rhs) { return lhs->GetZIndex() < rhs->GetZIndex(); });
 }
 
 enum class RenderOrder { Block, TableColumnGroup, TableColumn, TableRowGroup, TableRow, TableCell, Inline, Floating, Positioned };
@@ -2295,7 +2238,7 @@ void Element::BuildStackingContext(ElementList* new_stacking_context)
 	// Build the list of ordered children. Our child list is sorted within the stacking context so stacked elements
 	// will render in the right order; ie, positioned elements will render on top of inline elements, which will render
 	// on top of floated elements, which will render on top of block elements.
-	Vector< StackingOrderedChild > ordered_children;
+	Vector<StackingOrderedChild> ordered_children;
 
 	const size_t num_children = children.size();
 	ordered_children.reserve(num_children);
@@ -2334,7 +2277,8 @@ void Element::BuildStackingContext(ElementList* new_stacking_context)
 	}
 
 	// Sort the list!
-	std::stable_sort(ordered_children.begin(), ordered_children.end(), [](const StackingOrderedChild& lhs, const StackingOrderedChild& rhs) { return int(lhs.order) < int(rhs.order); });
+	std::stable_sort(ordered_children.begin(), ordered_children.end(),
+		[](const StackingOrderedChild& lhs, const StackingOrderedChild& rhs) { return int(lhs.order) < int(rhs.order); });
 
 	// Add the list of ordered children into the stacking context in order.
 	for (size_t i = 0; i < ordered_children.size(); ++i)
@@ -2375,9 +2319,7 @@ void Element::BuildStackingContextForTable(Vector<StackingOrderedChild>& ordered
 			ordered_child.order = RenderOrder::TableRowGroup;
 			recurse_into_children = true;
 			break;
-		case Style::Display::TableColumn:
-			ordered_child.order = RenderOrder::TableColumn;
-			break;
+		case Style::Display::TableColumn: ordered_child.order = RenderOrder::TableColumn; break;
 		case Style::Display::TableColumnGroup:
 			ordered_child.order = RenderOrder::TableColumnGroup;
 			recurse_into_children = true;
@@ -2414,9 +2356,7 @@ void Element::DirtyDefinition(DirtyNodes dirty_nodes)
 {
 	switch (dirty_nodes)
 	{
-	case DirtyNodes::Self:
-		dirty_definition = true;
-		break;
+	case DirtyNodes::Self: dirty_definition = true; break;
 	case DirtyNodes::SelfAndSiblings:
 		dirty_definition = true;
 		if (parent)
@@ -2447,8 +2387,8 @@ void Element::UpdateDefinition()
 	}
 }
 
-
-bool Element::Animate(const String & property_name, const Property & target_value, float duration, Tween tween, int num_iterations, bool alternate_direction, float delay, const Property* start_value)
+bool Element::Animate(const String& property_name, const Property& target_value, float duration, Tween tween, int num_iterations,
+	bool alternate_direction, float delay, const Property* start_value)
 {
 	bool result = false;
 	PropertyId property_id = StyleSheetSpecification::GetPropertyId(property_name);
@@ -2464,15 +2404,16 @@ bool Element::Animate(const String & property_name, const Property & target_valu
 	return result;
 }
 
-
-bool Element::AddAnimationKey(const String & property_name, const Property & target_value, float duration, Tween tween)
+bool Element::AddAnimationKey(const String& property_name, const Property& target_value, float duration, Tween tween)
 {
 	ElementAnimation* animation = nullptr;
 
 	PropertyId property_id = StyleSheetSpecification::GetPropertyId(property_name);
 
-	for (auto& existing_animation : animations) {
-		if (existing_animation.GetPropertyId() == property_id) {
+	for (auto& existing_animation : animations)
+	{
+		if (existing_animation.GetPropertyId() == property_id)
+		{
 			animation = &existing_animation;
 			break;
 		}
@@ -2485,8 +2426,8 @@ bool Element::AddAnimationKey(const String & property_name, const Property & tar
 	return result;
 }
 
-
-ElementAnimationList::iterator Element::StartAnimation(PropertyId property_id, const Property* start_value, int num_iterations, bool alternate_direction, float delay, bool initiated_by_animation_property)
+ElementAnimationList::iterator Element::StartAnimation(PropertyId property_id, const Property* start_value, int num_iterations,
+	bool alternate_direction, float delay, bool initiated_by_animation_property)
 {
 	auto it = std::find_if(animations.begin(), animations.end(), [&](const ElementAnimation& el) { return el.GetPropertyId() == property_id; });
 
@@ -2506,8 +2447,8 @@ ElementAnimationList::iterator Element::StartAnimation(PropertyId property_id, c
 	{
 		value = *start_value;
 		if (!value.definition)
-			if(auto default_value = GetProperty(property_id))
-				value.definition = default_value->definition;	
+			if (auto default_value = GetProperty(property_id))
+				value.definition = default_value->definition;
 	}
 	else if (auto default_value = GetProperty(property_id))
 	{
@@ -2518,10 +2459,10 @@ ElementAnimationList::iterator Element::StartAnimation(PropertyId property_id, c
 	{
 		ElementAnimationOrigin origin = (initiated_by_animation_property ? ElementAnimationOrigin::Animation : ElementAnimationOrigin::User);
 		double start_time = Clock::GetElapsedTime() + (double)delay;
-		*it = ElementAnimation{ property_id, origin, value, *this, start_time, 0.0f, num_iterations, alternate_direction };
+		*it = ElementAnimation{property_id, origin, value, *this, start_time, 0.0f, num_iterations, alternate_direction};
 	}
-	
-	if(!it->IsInitalized())
+
+	if (!it->IsInitalized())
 	{
 		animations.erase(it);
 		it = animations.end();
@@ -2530,7 +2471,6 @@ ElementAnimationList::iterator Element::StartAnimation(PropertyId property_id, c
 	return it;
 }
 
-
 bool Element::AddAnimationKeyTime(PropertyId property_id, const Property* target_value, float time, Tween tween)
 {
 	if (!target_value)
@@ -2540,8 +2480,10 @@ bool Element::AddAnimationKeyTime(PropertyId property_id, const Property* target
 
 	ElementAnimation* animation = nullptr;
 
-	for (auto& existing_animation : animations) {
-		if (existing_animation.GetPropertyId() == property_id) {
+	for (auto& existing_animation : animations)
+	{
+		if (existing_animation.GetPropertyId() == property_id)
+		{
 			animation = &existing_animation;
 			break;
 		}
@@ -2554,7 +2496,7 @@ bool Element::AddAnimationKeyTime(PropertyId property_id, const Property* target
 	return result;
 }
 
-bool Element::StartTransition(const Transition & transition, const Property& start_value, const Property & target_value)
+bool Element::StartTransition(const Transition& transition, const Property& start_value, const Property& target_value)
 {
 	auto it = std::find_if(animations.begin(), animations.end(), [&](const ElementAnimation& el) { return el.GetPropertyId() == transition.id; });
 
@@ -2567,19 +2509,17 @@ bool Element::StartTransition(const Transition & transition, const Property& sta
 	if (it == animations.end())
 	{
 		// Add transition as new animation
-		animations.push_back(
-			ElementAnimation{ transition.id, ElementAnimationOrigin::Transition, start_value, *this, start_time, 0.0f, 1, false }
-		);
+		animations.push_back(ElementAnimation{transition.id, ElementAnimationOrigin::Transition, start_value, *this, start_time, 0.0f, 1, false});
 		it = (animations.end() - 1);
 	}
 	else
 	{
 		// Compress the duration based on the progress of the current animation
 		float f = it->GetInterpolationFactor();
-		f = 1.0f - (1.0f - f)*transition.reverse_adjustment_factor;
+		f = 1.0f - (1.0f - f) * transition.reverse_adjustment_factor;
 		duration = duration * f;
 		// Replace old transition
-		*it = ElementAnimation{ transition.id, ElementAnimationOrigin::Transition, start_value, *this, start_time, 0.0f, 1, false };
+		*it = ElementAnimation{transition.id, ElementAnimationOrigin::Transition, start_value, *this, start_time, 0.0f, 1, false};
 	}
 
 	bool result = it->AddKey(duration, target_value, *this, transition.tween, true);
@@ -2594,7 +2534,7 @@ bool Element::StartTransition(const Transition & transition, const Property& sta
 
 void Element::HandleTransitionProperty()
 {
-	if(dirty_transition)
+	if (dirty_transition)
 	{
 		dirty_transition = false;
 
@@ -2611,8 +2551,7 @@ void Element::HandleTransitionProperty()
 			// All transitions should be removed, but only touch the animations that originate from the 'transition' property.
 			// Move all animations to be erased in a valid state at the end of the list, and erase later.
 			it_remove = std::partition(animations.begin(), animations.end(),
-				[](const ElementAnimation& animation) -> bool { return !animation.IsTransition(); }
-			);
+				[](const ElementAnimation& animation) -> bool { return !animation.IsTransition(); });
 		}
 		else
 		{
@@ -2621,17 +2560,14 @@ void Element::HandleTransitionProperty()
 			// Only remove the transitions that are not in our keep list.
 			const auto& keep_transitions_list = keep_transitions->transitions;
 
-			it_remove = std::partition(animations.begin(), animations.end(),
-				[&keep_transitions_list](const ElementAnimation& animation) -> bool {
-					if (!animation.IsTransition())
-						return true;
-					auto it = std::find_if(keep_transitions_list.begin(), keep_transitions_list.end(),
-						[&animation](const Transition& transition) { return animation.GetPropertyId() == transition.id; }
-					);
-					bool keep_animation = (it != keep_transitions_list.end());
-					return keep_animation;
-				}
-			);
+			it_remove = std::partition(animations.begin(), animations.end(), [&keep_transitions_list](const ElementAnimation& animation) -> bool {
+				if (!animation.IsTransition())
+					return true;
+				auto it = std::find_if(keep_transitions_list.begin(), keep_transitions_list.end(),
+					[&animation](const Transition& transition) { return animation.GetPropertyId() == transition.id; });
+				bool keep_animation = (it != keep_transitions_list.end());
+				return keep_animation;
+			});
 		}
 
 		// We can decide what to do with cancelled transitions here.
@@ -2662,9 +2598,8 @@ void Element::HandleAnimationProperty()
 			// Remove existing animations
 			{
 				// We only touch the animations that originate from the 'animation' property.
-				auto it_remove = std::partition(animations.begin(), animations.end(), 
-					[](const ElementAnimation & animation) { return animation.GetOrigin() != ElementAnimationOrigin::Animation; }
-				);
+				auto it_remove = std::partition(animations.begin(), animations.end(),
+					[](const ElementAnimation& animation) { return animation.GetOrigin() != ElementAnimationOrigin::Animation; });
 
 				// We can decide what to do with cancelled animations here.
 				for (auto it = it_remove; it != animations.end(); ++it)
@@ -2727,7 +2662,8 @@ void Element::AdvanceAnimations()
 		}
 
 		// Move all completed animations to the end of the list
-		auto it_completed = std::partition(animations.begin(), animations.end(), [](const ElementAnimation& animation) { return !animation.IsComplete(); });
+		auto it_completed =
+			std::partition(animations.begin(), animations.end(), [](const ElementAnimation& animation) { return !animation.IsComplete(); });
 
 		Vector<Dictionary> dictionary_list;
 		Vector<bool> is_transition;
@@ -2756,15 +2692,12 @@ void Element::AdvanceAnimations()
 	}
 }
 
-
-
 void Element::DirtyTransformState(bool perspective_dirty, bool transform_dirty)
 {
 	dirty_perspective |= perspective_dirty;
 	dirty_transform |= transform_dirty;
 }
 
-
 void Element::UpdateTransformState()
 {
 	if (!dirty_perspective && !dirty_transform)
@@ -2774,12 +2707,12 @@ void Element::UpdateTransformState()
 
 	const Vector2f pos = GetAbsoluteOffset(Box::BORDER);
 	const Vector2f size = GetBox().GetSize(Box::BORDER);
-	
+
 	bool perspective_or_transform_changed = false;
 
 	if (dirty_perspective)
 	{
-		// If perspective is set on this element, then it applies to our children. We just calculate it here, 
+		// If perspective is set on this element, then it applies to our children. We just calculate it here,
 		// and let the children's transform update merge it with their transform.
 		bool had_perspective = (transform_state && transform_state->GetLocalPerspective());
 
@@ -2806,12 +2739,8 @@ void Element::UpdateTransformState()
 		if (have_perspective)
 		{
 			// Equivalent to: Translate(x,y,0) * Perspective(distance) * Translate(-x,-y,0)
-			Matrix4f perspective = Matrix4f::FromRows(
-				{ 1, 0, -vanish.x / distance, 0 },
-				{ 0, 1, -vanish.y / distance, 0 },
-				{ 0, 0, 1, 0 },
-				{ 0, 0, -1 / distance, 1 }
-			);
+			Matrix4f perspective =
+				Matrix4f::FromRows({1, 0, -vanish.x / distance, 0}, {0, 1, -vanish.y / distance, 0}, {0, 0, 1, 0}, {0, 0, -1 / distance, 1});
 
 			if (!transform_state)
 				transform_state = MakeUnique<TransformState>();
@@ -2826,7 +2755,6 @@ void Element::UpdateTransformState()
 		dirty_perspective = false;
 	}
 
-
 	if (dirty_transform)
 	{
 		// We want to find the accumulated transform given all our ancestors. It is assumed here that the parent transform is already updated,
@@ -2848,7 +2776,7 @@ void Element::UpdateTransformState()
 				have_transform = true;
 			}
 
-			if(have_transform)
+			if (have_transform)
 			{
 				// Compute the transform origin
 				Vector3f transform_origin(pos.x + size.x * 0.5f, pos.y + size.y * 0.5f, 0);
@@ -2869,14 +2797,15 @@ void Element::UpdateTransformState()
 				transform = Matrix4f::Translate(transform_origin) * transform * Matrix4f::Translate(-transform_origin);
 			}
 
-			// We may want to include the local offsets here, as suggested by the CSS specs, so that the local transform is applied after the offset I believe
-			// the motivation is. Then we would need to subtract the absolute zero-offsets during geometry submit whenever we have transforms.
+			// We may want to include the local offsets here, as suggested by the CSS specs, so that the local transform is applied after the offset I
+			// believe the motivation is. Then we would need to subtract the absolute zero-offsets during geometry submit whenever we have transforms.
 		}
 
 		if (parent && parent->transform_state)
 		{
 			// Apply the parent's local perspective and transform.
-			// @performance: If we have no local transform and no parent perspective, we can effectively just point to the parent transform instead of copying it.
+			// @performance: If we have no local transform and no parent perspective, we can effectively just point to the parent transform instead of
+			// copying it.
 			const TransformState& parent_state = *parent->transform_state;
 
 			if (auto parent_perspective = parent_state.GetLocalPerspective())
diff --git externals/rmlui/Source/Core/ElementInstancer.cpp externals/rmlui/Source/Core/ElementInstancer.cpp
index 0a2b87d6..d71e5ec8 100644
--- externals/rmlui/Source/Core/ElementInstancer.cpp
+++ externals/rmlui/Source/Core/ElementInstancer.cpp
@@ -15,7 +15,7 @@
  *
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -27,39 +27,39 @@
  */
 
 #include "../../Include/RmlUi/Core/ElementInstancer.h"
+#include "../../Include/RmlUi/Core/Context.h"
 #include "../../Include/RmlUi/Core/ElementText.h"
-#include "XMLParseTools.h"
 #include "Pool.h"
+#include "XMLParseTools.h"
 
 namespace Rml {
 
-ElementInstancer::~ElementInstancer()
-{
-}
-
-static Pool< Element > pool_element(200, true);
-static Pool< ElementText > pool_text_default(200, true);
+ElementInstancer::~ElementInstancer() {}
 
+#define pool_element_params 200, true
+#define pool_text_default_params 200, true
+REGISTER_INIT_GLOBAL(Pool<Element>, pool_element);
+REGISTER_INIT_GLOBAL(Pool<ElementText>, pool_text_default);
 
 ElementPtr ElementInstancerElement::InstanceElement(Element* /*parent*/, const String& tag, const XMLAttributes& /*attributes*/)
 {
-	Element* ptr = pool_element.AllocateAndConstruct(tag);
+	Element* ptr = GET_OR_MAKE_INIT_GLOBAL(pool_element).AllocateAndConstruct(tag);
 	return ElementPtr(ptr);
 }
 
 void ElementInstancerElement::ReleaseElement(Element* element)
 {
-	pool_element.DestroyAndDeallocate(element);
+	GET_OR_MAKE_INIT_GLOBAL(pool_element).DestroyAndDeallocate(element);
 }
 
 ElementInstancerElement::~ElementInstancerElement()
 {
-	int num_elements = pool_element.GetNumAllocatedObjects();
+	int num_elements = GET_OR_MAKE_INIT_GLOBAL(pool_element).GetNumAllocatedObjects();
 	if (num_elements > 0)
 	{
 		Log::Message(Log::LT_WARNING, "--- Found %d leaked element(s) ---", num_elements);
 
-		for (auto it = pool_element.Begin(); it; ++it)
+		for (auto it = GET_OR_MAKE_INIT_GLOBAL(pool_element).Begin(); it; ++it)
 			Log::Message(Log::LT_WARNING, "    %s", it->GetAddress().c_str());
 
 		Log::Message(Log::LT_WARNING, "------");
@@ -68,13 +68,13 @@ ElementInstancerElement::~ElementInstancerElement()
 
 ElementPtr ElementInstancerText::InstanceElement(Element* /*parent*/, const String& tag, const XMLAttributes& /*attributes*/)
 {
-	ElementText* ptr = pool_text_default.AllocateAndConstruct(tag);
+	ElementText* ptr = GET_OR_MAKE_INIT_GLOBAL(pool_text_default).AllocateAndConstruct(tag);
 	return ElementPtr(static_cast<Element*>(ptr));
 }
 
 void ElementInstancerText::ReleaseElement(Element* element)
 {
-	pool_text_default.DestroyAndDeallocate(static_cast<ElementText*>(element));
+	GET_OR_MAKE_INIT_GLOBAL(pool_text_default).DestroyAndDeallocate(static_cast<ElementText*>(element));
 }
 
 } // namespace Rml
diff --git externals/rmlui/Source/Core/Elements/DataFormatter.cpp externals/rmlui/Source/Core/Elements/DataFormatter.cpp
index aa192c03..037c6123 100644
--- externals/rmlui/Source/Core/Elements/DataFormatter.cpp
+++ externals/rmlui/Source/Core/Elements/DataFormatter.cpp
@@ -15,7 +15,7 @@
  *
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -27,12 +27,14 @@
  */
 
 #include "../../../Include/RmlUi/Core/Elements/DataFormatter.h"
+#include "../../../Include/RmlUi/Core/Context.h"
 #include "../../../Include/RmlUi/Core/StringUtilities.h"
 
 namespace Rml {
 
-typedef UnorderedMap< String, DataFormatter* > DataFormatterMap;
-static DataFormatterMap data_formatters;
+typedef UnorderedMap<String, DataFormatter*> DataFormatterMap;
+
+REGISTER_GLOBAL(DataFormatterMap, data_formatters);
 
 DataFormatter::DataFormatter(const String& _name)
 {
@@ -44,12 +46,10 @@ DataFormatter::DataFormatter(const String& _name)
 	{
 		name = CreateString(64, "%p", (void*)this);
 	}
-	data_formatters[name] = this;
+	GET_OR_MAKE_GLOBAL(data_formatters)[name] = this;
 }
 
-DataFormatter::~DataFormatter()
-{
-}
+DataFormatter::~DataFormatter() {}
 
 const String& DataFormatter::GetDataFormatterName()
 {
@@ -58,8 +58,8 @@ const String& DataFormatter::GetDataFormatterName()
 
 DataFormatter* DataFormatter::GetDataFormatter(const String& data_formatter_name)
 {
-	DataFormatterMap::iterator i = data_formatters.find(data_formatter_name);
-	if (i == data_formatters.end())
+	DataFormatterMap::iterator i = GET_OR_MAKE_GLOBAL(data_formatters).find(data_formatter_name);
+	if (i == GET_OR_MAKE_GLOBAL(data_formatters).end())
 	{
 		return nullptr;
 	}
diff --git externals/rmlui/Source/Core/Elements/DataSource.cpp externals/rmlui/Source/Core/Elements/DataSource.cpp
index fcd41b1d..46d6ea29 100644
--- externals/rmlui/Source/Core/Elements/DataSource.cpp
+++ externals/rmlui/Source/Core/Elements/DataSource.cpp
@@ -15,7 +15,7 @@
  *
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -28,8 +28,9 @@
 
 #include "../../../Include/RmlUi/Core/Elements/DataSource.h"
 #include "../../../Include/RmlUi/Core/Elements/DataSourceListener.h"
-#include "../../../Include/RmlUi/Core/StringUtilities.h"
+#include "../../../Include/RmlUi/Core/Context.h"
 #include "../../../Include/RmlUi/Core/Log.h"
+#include "../../../Include/RmlUi/Core/StringUtilities.h"
 #include <algorithm>
 
 namespace Rml {
@@ -38,9 +39,8 @@ const String DataSource::CHILD_SOURCE("#child_data_source");
 const String DataSource::DEPTH("#depth");
 const String DataSource::NUM_CHILDREN("#num_children");
 
-typedef UnorderedMap< String, DataSource* > DataSourceMap;
-static DataSourceMap data_sources;
-
+typedef UnorderedMap<String, DataSource*> DataSourceMap;
+REGISTER_GLOBAL(DataSourceMap, data_sources);
 DataSource::DataSource(const String& _name)
 {
 	if (!_name.empty())
@@ -51,7 +51,7 @@ DataSource::DataSource(const String& _name)
 	{
 		name = CreateString(64, "%p", (void*)this);
 	}
-	data_sources[name] = this;
+	GET_OR_MAKE_GLOBAL(data_sources)[name] = this;
 }
 
 DataSource::~DataSource()
@@ -63,11 +63,10 @@ DataSource::~DataSource()
 			listener->OnDataSourceDestroy(this);
 	}
 
-	DataSourceMap::iterator iterator = data_sources.find(name);
-	if (iterator != data_sources.end() &&
-		iterator->second == this)
+	DataSourceMap::iterator iterator = GET_OR_MAKE_GLOBAL(data_sources).find(name);
+	if (iterator != GET_OR_MAKE_GLOBAL(data_sources).end() && iterator->second == this)
 	{
-		data_sources.erase(name);
+		GET_OR_MAKE_GLOBAL(data_sources).erase(name);
 	}
 }
 
@@ -78,8 +77,8 @@ const String& DataSource::GetDataSourceName()
 
 DataSource* DataSource::GetDataSource(const String& data_source_name)
 {
-	DataSourceMap::iterator i = data_sources.find(data_source_name);
-	if (i == data_sources.end())
+	DataSourceMap::iterator i = GET_OR_MAKE_GLOBAL(data_sources).find(data_source_name);
+	if (i == GET_OR_MAKE_GLOBAL(data_sources).end())
 	{
 		return nullptr;
 	}
diff --git externals/rmlui/Source/Core/EventSpecification.cpp externals/rmlui/Source/Core/EventSpecification.cpp
index 57525d8a..8a6da3cf 100644
--- externals/rmlui/Source/Core/EventSpecification.cpp
+++ externals/rmlui/Source/Core/EventSpecification.cpp
@@ -28,23 +28,24 @@
 
 #include "EventSpecification.h"
 #include "../../Include/RmlUi/Core/ID.h"
-
+#include "../../Include/RmlUi/Core/Context.h"
 
 namespace Rml {
+#define specifications_params EventSpecification{ { EventId::Invalid, "invalid", false, false, DefaultActionPhase::None } }
 
 // An EventId is an index into the specifications vector.
-static Vector<EventSpecification> specifications = { { EventId::Invalid, "invalid", false, false, DefaultActionPhase::None } };
+REGISTER_GLOBAL(Vector<EventSpecification>, specifications); 
 
+using map_type = UnorderedMap<String, EventId>;
 // Reverse lookup map from event type to id.
-static UnorderedMap<String, EventId> type_lookup;
-
+REGISTER_GLOBAL(map_type, type_lookup);
 
 namespace EventSpecificationInterface {
 
 void Initialize()
 {
 	// Must be specified in the same order as in EventId
-	specifications = {
+	GET_OR_MAKE_GLOBAL(specifications) = {
 		//      id                 type      interruptible  bubbles     default_action
 		{EventId::Invalid       , "invalid"       , false , false , DefaultActionPhase::None},
 		{EventId::Mousedown     , "mousedown"     , true  , true  , DefaultActionPhase::TargetAndBubble},
@@ -87,19 +88,19 @@ void Initialize()
 		{EventId::Rowupdate     , "rowupdate"     , false , true  , DefaultActionPhase::None},
 	};
 
-	type_lookup.clear();
-	type_lookup.reserve(specifications.size());
-	for (auto& specification : specifications)
-		type_lookup.emplace(specification.type, specification.id);
+	GET_OR_MAKE_GLOBAL(type_lookup).clear();
+	GET_OR_MAKE_GLOBAL(type_lookup).reserve(GET_OR_MAKE_GLOBAL(specifications).size());
+	for (auto& specification : GET_OR_MAKE_GLOBAL(specifications))
+		GET_OR_MAKE_GLOBAL(type_lookup).emplace(specification.type, specification.id);
 
 #ifdef RMLUI_DEBUG
 	// Verify that all event ids are specified
-	RMLUI_ASSERT((int)specifications.size() == (int)EventId::NumDefinedIds);
+	RMLUI_ASSERT((int)GET_OR_MAKE_GLOBAL(specifications).size() == (int)EventId::NumDefinedIds);
 
-	for (int i = 0; i < (int)specifications.size(); i++)
+	for (int i = 0; i < (int)GET_OR_MAKE_GLOBAL(specifications).size(); i++)
 	{
 		// Verify correct order
-		RMLUI_ASSERT(i == (int)specifications[i].id);
+		RMLUI_ASSERT(i == (int)GET_OR_MAKE_GLOBAL(specifications)[i].id);
 	}
 #endif
 }
@@ -107,33 +108,33 @@ void Initialize()
 static EventSpecification& GetMutable(EventId id)
 {
 	size_t i = static_cast<size_t>(id);
-	if (i < specifications.size())
-		return specifications[i];
-	return specifications[0];
+	if (i < GET_OR_MAKE_GLOBAL(specifications).size())
+		return GET_OR_MAKE_GLOBAL(specifications)[i];
+	return GET_OR_MAKE_GLOBAL(specifications)[0];
 }
 
 // Get event specification for the given type.
 // If not found: Inserts a new entry with given values.
 static EventSpecification& GetOrInsert(const String& event_type, bool interruptible, bool bubbles, DefaultActionPhase default_action_phase)
 {
-	auto it = type_lookup.find(event_type);
+	auto it = GET_OR_MAKE_GLOBAL(type_lookup).find(event_type);
 
-	if (it != type_lookup.end())
+	if (it != GET_OR_MAKE_GLOBAL(type_lookup).end())
 		return GetMutable(it->second);
 
-	const size_t new_id_num = specifications.size();
+	const size_t new_id_num = GET_OR_MAKE_GLOBAL(specifications).size();
 	if (new_id_num >= size_t(EventId::MaxNumIds))
 	{
 		Log::Message(Log::LT_ERROR, "Error while registering event type '%s': Maximum number of allowed events exceeded.", event_type.c_str());
 		RMLUI_ERROR;
-		return specifications.front();
+		return GET_OR_MAKE_GLOBAL(specifications).front();
 	}
 
 	// No specification found for this name, insert a new entry with default values
 	EventId new_id = static_cast<EventId>(new_id_num);
-	specifications.push_back(EventSpecification{ new_id, event_type, interruptible, bubbles, default_action_phase });
-	type_lookup.emplace(event_type, new_id);
-	return specifications.back();
+	GET_OR_MAKE_GLOBAL(specifications).push_back(EventSpecification{ new_id, event_type, interruptible, bubbles, default_action_phase });
+	GET_OR_MAKE_GLOBAL(type_lookup).emplace(event_type, new_id);
+	return GET_OR_MAKE_GLOBAL(specifications).back();
 }
 
 const EventSpecification& Get(EventId id)
@@ -153,8 +154,8 @@ const EventSpecification& GetOrInsert(const String& event_type)
 
 EventId GetIdOrInsert(const String& event_type)
 {
-	auto it = type_lookup.find(event_type);
-	if (it != type_lookup.end())
+	auto it = GET_OR_MAKE_GLOBAL(type_lookup).find(event_type);
+	if (it != GET_OR_MAKE_GLOBAL(type_lookup).end())
 		return it->second;
 
 	return GetOrInsert(event_type).id;
@@ -162,9 +163,9 @@ EventId GetIdOrInsert(const String& event_type)
 
 EventId InsertOrReplaceCustom(const String& event_type, bool interruptible, bool bubbles, DefaultActionPhase default_action_phase)
 {
-	const size_t size_before = specifications.size();
+	const size_t size_before = GET_OR_MAKE_GLOBAL(specifications).size();
 	EventSpecification& specification = GetOrInsert(event_type, interruptible, bubbles, default_action_phase);
-	bool got_existing_entry = (size_before == specifications.size());
+	bool got_existing_entry = (size_before == GET_OR_MAKE_GLOBAL(specifications).size());
 
 	// If we found an existing entry of same type, replace it, but only if it is a custom event id.
 	if (got_existing_entry && (int)specification.id >= (int)EventId::FirstCustomId)
diff --git externals/rmlui/Source/Core/Factory.cpp externals/rmlui/Source/Core/Factory.cpp
index 0779e758..8d69e335 100644
--- externals/rmlui/Source/Core/Factory.cpp
+++ externals/rmlui/Source/Core/Factory.cpp
@@ -90,41 +90,41 @@
 
 namespace Rml {
 
-// Element instancers.
 using ElementInstancerMap = UnorderedMap< String, ElementInstancer* >;
-static ElementInstancerMap element_instancers;
+using DecoratorInstancerMap = UnorderedMap< String, DecoratorInstancer* >;
+using FontEffectInstancerMap = UnorderedMap< String, FontEffectInstancer* >;
+using DataViewInstancerMap = UnorderedMap< String, DataViewInstancer* >;
+using DataControllerInstancerMap = UnorderedMap< String, DataControllerInstancer* >;
+using StructuralDataViewInstancerMap = SmallUnorderedMap< String, DataViewInstancer* >;
 
+// Element instancers.
+REGISTER_GLOBAL(ElementInstancerMap, element_instancers);
 // Decorator instancers.
-using DecoratorInstancerMap = UnorderedMap< String, DecoratorInstancer* >;
-static DecoratorInstancerMap decorator_instancers;
+REGISTER_GLOBAL(DecoratorInstancerMap, decorator_instancers);
 
 // Font effect instancers.
-using FontEffectInstancerMap = UnorderedMap< String, FontEffectInstancer* >;
-static FontEffectInstancerMap font_effect_instancers;
+REGISTER_GLOBAL(FontEffectInstancerMap, font_effect_instancers);
 
 // Data view instancers.
-using DataViewInstancerMap = UnorderedMap< String, DataViewInstancer* >;
-static DataViewInstancerMap data_view_instancers;
+REGISTER_GLOBAL(DataViewInstancerMap, data_view_instancers);
 
 // Data controller instancers.
-using DataControllerInstancerMap = UnorderedMap< String, DataControllerInstancer* >;
-static DataControllerInstancerMap data_controller_instancers;
+REGISTER_GLOBAL(DataControllerInstancerMap, data_controller_instancers);
 
 // Structural data view instancers.
-using StructuralDataViewInstancerMap = SmallUnorderedMap< String, DataViewInstancer* >;
-static StructuralDataViewInstancerMap structural_data_view_instancers;
+REGISTER_GLOBAL(StructuralDataViewInstancerMap, structural_data_view_instancers);
 
 // Structural data view names.
-static StringList structural_data_view_attribute_names;
+REGISTER_GLOBAL(StringList, structural_data_view_attribute_names);
 
 // The context instancer.
-static ContextInstancer* context_instancer = nullptr;
+REGISTER_GLOBAL(ContextInstancer*, context_instancer);
 
 // The event instancer
-static EventInstancer* event_instancer = nullptr;
+REGISTER_GLOBAL(EventInstancer*, event_instancer);
 
 // Event listener instancer.
-static EventListenerInstancer* event_listener_instancer = nullptr;
+REGISTER_GLOBAL(EventListenerInstancer*, event_listener_instancer);
 
 // Default instancers are constructed and destroyed on Initialise and Shutdown, respectively.
 struct DefaultInstancers {
@@ -190,7 +190,7 @@ struct DefaultInstancers {
 	DataControllerInstancerDefault<DataControllerValue> data_controller_value;
 };
 
-static UniquePtr<DefaultInstancers> default_instancers;
+REGISTER_GLOBAL(UniquePtr<DefaultInstancers>, default_instancers);
 
 
 Factory::Factory()
@@ -204,83 +204,83 @@ Factory::~Factory()
 
 bool Factory::Initialise()
 {
-	default_instancers = MakeUnique<DefaultInstancers>();
+	GET_OR_MAKE_GLOBAL(default_instancers) = MakeUnique<DefaultInstancers>();
 
 	// Default context instancer
-	if (!context_instancer)
+	if (!GET_OR_MAKE_GLOBAL(context_instancer))
 	{
-		default_instancers->context_default = MakeUnique<ContextInstancerDefault>();
-		context_instancer = default_instancers->context_default.get();
+		GET_OR_MAKE_GLOBAL(default_instancers)->context_default = MakeUnique<ContextInstancerDefault>();
+		GET_OR_MAKE_GLOBAL(context_instancer) = GET_OR_MAKE_GLOBAL(default_instancers)->context_default.get();
 	}
 
 	// Default event instancer
-	if (!event_instancer)
+	if (!GET_OR_MAKE_GLOBAL(event_instancer))
 	{
-		default_instancers->event_default = MakeUnique<EventInstancerDefault>();
-		event_instancer = default_instancers->event_default.get();
+		GET_OR_MAKE_GLOBAL(default_instancers)->event_default = MakeUnique<EventInstancerDefault>();
+		GET_OR_MAKE_GLOBAL(event_instancer) = GET_OR_MAKE_GLOBAL(default_instancers)->event_default.get();
 	}
 
 	// No default event listener instancer
-	if (!event_listener_instancer)
-		event_listener_instancer = nullptr;
+	if (!GET_OR_MAKE_GLOBAL(event_listener_instancer))
+		GET_OR_MAKE_GLOBAL(event_listener_instancer) = nullptr;
 
 	// Basic element instancers
-	RegisterElementInstancer("*", &default_instancers->element_default);
-	RegisterElementInstancer("img", &default_instancers->element_img);
-	RegisterElementInstancer("#text", &default_instancers->element_text);
-	RegisterElementInstancer("handle", &default_instancers->element_handle);
-	RegisterElementInstancer("body", &default_instancers->element_body);
+	RegisterElementInstancer("*", &GET_OR_MAKE_GLOBAL(default_instancers)->element_default);
+	RegisterElementInstancer("img", &GET_OR_MAKE_GLOBAL(default_instancers)->element_img);
+	RegisterElementInstancer("#text", &GET_OR_MAKE_GLOBAL(default_instancers)->element_text);
+	RegisterElementInstancer("handle", &GET_OR_MAKE_GLOBAL(default_instancers)->element_handle);
+	RegisterElementInstancer("body", &GET_OR_MAKE_GLOBAL(default_instancers)->element_body);
 
 	// Control element instancers
-	RegisterElementInstancer("form", &default_instancers->form);
-	RegisterElementInstancer("input", &default_instancers->input);
-	RegisterElementInstancer("dataselect", &default_instancers->dataselect);
-	RegisterElementInstancer("select", &default_instancers->select);
-	RegisterElementInstancer("label", &default_instancers->element_label);
+	RegisterElementInstancer("form", &GET_OR_MAKE_GLOBAL(default_instancers)->form);
+	RegisterElementInstancer("input", &GET_OR_MAKE_GLOBAL(default_instancers)->input);
+	RegisterElementInstancer("dataselect", &GET_OR_MAKE_GLOBAL(default_instancers)->dataselect);
+	RegisterElementInstancer("select", &GET_OR_MAKE_GLOBAL(default_instancers)->select);
+	RegisterElementInstancer("label", &GET_OR_MAKE_GLOBAL(default_instancers)->element_label);
 
-	RegisterElementInstancer("textarea", &default_instancers->textarea);
-	RegisterElementInstancer("#selection", &default_instancers->selection);
-	RegisterElementInstancer("tabset", &default_instancers->tabset);
+	RegisterElementInstancer("textarea", &GET_OR_MAKE_GLOBAL(default_instancers)->textarea);
+	RegisterElementInstancer("#selection", &GET_OR_MAKE_GLOBAL(default_instancers)->selection);
+	RegisterElementInstancer("tabset", &GET_OR_MAKE_GLOBAL(default_instancers)->tabset);
 
-	RegisterElementInstancer("progress", &default_instancers->progress);
-	RegisterElementInstancer("progressbar", &default_instancers->progress);
+	RegisterElementInstancer("progress", &GET_OR_MAKE_GLOBAL(default_instancers)->progress);
+	RegisterElementInstancer("progressbar", &GET_OR_MAKE_GLOBAL(default_instancers)->progress);
 
-	RegisterElementInstancer("datagrid", &default_instancers->datagrid);
-	RegisterElementInstancer("datagridexpand", &default_instancers->datagrid_expand);
-	RegisterElementInstancer("#rmlctl_datagridcell", &default_instancers->datagrid_cell);
-	RegisterElementInstancer("#rmlctl_datagridrow", &default_instancers->datagrid_row);
+	RegisterElementInstancer("datagrid", &GET_OR_MAKE_GLOBAL(default_instancers)->datagrid);
+	RegisterElementInstancer("datagridexpand", &GET_OR_MAKE_GLOBAL(default_instancers)->datagrid_expand);
+	RegisterElementInstancer("#rmlctl_datagridcell", &GET_OR_MAKE_GLOBAL(default_instancers)->datagrid_cell);
+	RegisterElementInstancer("#rmlctl_datagridrow", &GET_OR_MAKE_GLOBAL(default_instancers)->datagrid_row);
 
 	// Decorator instancers
-	RegisterDecoratorInstancer("tiled-horizontal", &default_instancers->decorator_tiled_horizontal);
-	RegisterDecoratorInstancer("tiled-vertical", &default_instancers->decorator_tiled_vertical);
-	RegisterDecoratorInstancer("tiled-box", &default_instancers->decorator_tiled_box);
-	RegisterDecoratorInstancer("image", &default_instancers->decorator_image);
-	RegisterDecoratorInstancer("ninepatch", &default_instancers->decorator_ninepatch);
-	RegisterDecoratorInstancer("gradient", &default_instancers->decorator_gradient);
+	RegisterDecoratorInstancer("tiled-horizontal", &GET_OR_MAKE_GLOBAL(default_instancers)->decorator_tiled_horizontal);
+	RegisterDecoratorInstancer("tiled-vertical", &GET_OR_MAKE_GLOBAL(default_instancers)->decorator_tiled_vertical);
+	RegisterDecoratorInstancer("tiled-box", &GET_OR_MAKE_GLOBAL(default_instancers)->decorator_tiled_box);
+	RegisterDecoratorInstancer("image", &GET_OR_MAKE_GLOBAL(default_instancers)->decorator_image);
+	RegisterDecoratorInstancer("ninepatch", &GET_OR_MAKE_GLOBAL(default_instancers)->decorator_ninepatch);
+	RegisterDecoratorInstancer("gradient", &GET_OR_MAKE_GLOBAL(default_instancers)->decorator_gradient);
 
 	// Font effect instancers
-	RegisterFontEffectInstancer("blur", &default_instancers->font_effect_blur);
-	RegisterFontEffectInstancer("glow", &default_instancers->font_effect_glow);
-	RegisterFontEffectInstancer("outline", &default_instancers->font_effect_outline);
-	RegisterFontEffectInstancer("shadow", &default_instancers->font_effect_shadow);
+	RegisterFontEffectInstancer("blur", &GET_OR_MAKE_GLOBAL(default_instancers)->font_effect_blur);
+	RegisterFontEffectInstancer("glow", &GET_OR_MAKE_GLOBAL(default_instancers)->font_effect_glow);
+	RegisterFontEffectInstancer("outline", &GET_OR_MAKE_GLOBAL(default_instancers)->font_effect_outline);
+	RegisterFontEffectInstancer("shadow", &GET_OR_MAKE_GLOBAL(default_instancers)->font_effect_shadow);
 
 	// Data binding views
-	RegisterDataViewInstancer(&default_instancers->data_view_attribute,      "attr",    false);
-	RegisterDataViewInstancer(&default_instancers->data_view_attribute_if,   "attrif",  false);
-	RegisterDataViewInstancer(&default_instancers->data_view_class,          "class",   false);
-	RegisterDataViewInstancer(&default_instancers->data_view_if,             "if",      false);
-	RegisterDataViewInstancer(&default_instancers->data_view_visible,        "visible", false);
-	RegisterDataViewInstancer(&default_instancers->data_view_rml,            "rml",     false);
-	RegisterDataViewInstancer(&default_instancers->data_view_style,          "style",   false);
-	RegisterDataViewInstancer(&default_instancers->data_view_text,           "text",    false);
-	RegisterDataViewInstancer(&default_instancers->data_view_value,          "value",   false);
-	RegisterDataViewInstancer(&default_instancers->data_view_checked,        "checked", false);
-	RegisterDataViewInstancer(&default_instancers->structural_data_view_for, "for",     true );
+	RegisterDataViewInstancer(&GET_OR_MAKE_GLOBAL(default_instancers)->data_view_attribute,      "attr",    false);
+	RegisterDataViewInstancer(&GET_OR_MAKE_GLOBAL(default_instancers)->data_view_attribute_if,   "attrif",  false);
+	RegisterDataViewInstancer(&GET_OR_MAKE_GLOBAL(default_instancers)->data_view_class,          "class",   false);
+	RegisterDataViewInstancer(&GET_OR_MAKE_GLOBAL(default_instancers)->data_view_if,             "if",      false);
+	RegisterDataViewInstancer(&GET_OR_MAKE_GLOBAL(default_instancers)->data_view_visible,        "visible", false);
+	RegisterDataViewInstancer(&GET_OR_MAKE_GLOBAL(default_instancers)->data_view_rml,            "rml",     false);
+	RegisterDataViewInstancer(&GET_OR_MAKE_GLOBAL(default_instancers)->data_view_style,          "style",   false);
+	RegisterDataViewInstancer(&GET_OR_MAKE_GLOBAL(default_instancers)->data_view_text,           "text",    false);
+	RegisterDataViewInstancer(&GET_OR_MAKE_GLOBAL(default_instancers)->data_view_value,          "value",   false);
+	RegisterDataViewInstancer(&GET_OR_MAKE_GLOBAL(default_instancers)->data_view_checked,        "checked", false);
+	RegisterDataViewInstancer(&GET_OR_MAKE_GLOBAL(default_instancers)->structural_data_view_for, "for",     true );
 
 	// Data binding controllers
-	RegisterDataControllerInstancer(&default_instancers->data_controller_value, "checked");
-	RegisterDataControllerInstancer(&default_instancers->data_controller_event, "event");
-	RegisterDataControllerInstancer(&default_instancers->data_controller_value, "value");
+	RegisterDataControllerInstancer(&GET_OR_MAKE_GLOBAL(default_instancers)->data_controller_value, "checked");
+	RegisterDataControllerInstancer(&GET_OR_MAKE_GLOBAL(default_instancers)->data_controller_event, "event");
+	RegisterDataControllerInstancer(&GET_OR_MAKE_GLOBAL(default_instancers)->data_controller_value, "value");
 
 	// XML node handlers
 	XMLParser::RegisterNodeHandler("", MakeShared<XMLNodeHandlerDefault>());
@@ -299,56 +299,56 @@ bool Factory::Initialise()
 
 void Factory::Shutdown()
 {
-	element_instancers.clear();
+	GET_OR_MAKE_GLOBAL(element_instancers).clear();
 
-	decorator_instancers.clear();
+	GET_OR_MAKE_GLOBAL(decorator_instancers).clear();
 
-	font_effect_instancers.clear();
+	GET_OR_MAKE_GLOBAL(font_effect_instancers).clear();
 
-	data_controller_instancers.clear();
-	data_view_instancers.clear();
-	structural_data_view_instancers.clear();
-	structural_data_view_attribute_names.clear();
+	GET_OR_MAKE_GLOBAL(data_controller_instancers).clear();
+	GET_OR_MAKE_GLOBAL(data_view_instancers).clear();
+	GET_OR_MAKE_GLOBAL(structural_data_view_instancers).clear();
+	GET_OR_MAKE_GLOBAL(structural_data_view_attribute_names).clear();
 
-	context_instancer = nullptr;
+	GET_OR_MAKE_GLOBAL(context_instancer) = nullptr;
 
-	event_listener_instancer = nullptr;
+	GET_OR_MAKE_GLOBAL(event_listener_instancer) = nullptr;
 
-	event_instancer = nullptr;
+	GET_OR_MAKE_GLOBAL(event_instancer) = nullptr;
 
 	XMLParser::ReleaseHandlers();
 
-	default_instancers.reset();
+	GET_OR_MAKE_GLOBAL(default_instancers).reset();
 }
 
 // Registers the instancer to use when instancing contexts.
 void Factory::RegisterContextInstancer(ContextInstancer* instancer)
 {
-	context_instancer = instancer;
+	GET_OR_MAKE_GLOBAL(context_instancer) = instancer;
 }
 
 // Instances a new context.
 ContextPtr Factory::InstanceContext(const String& name)
 {
-	ContextPtr new_context = context_instancer->InstanceContext(name);
+	ContextPtr new_context = GET_OR_MAKE_GLOBAL(context_instancer)->InstanceContext(name);
 	if (new_context)
-		new_context->SetInstancer(context_instancer);
+		new_context->SetInstancer(GET_OR_MAKE_GLOBAL(context_instancer));
 	return new_context;
 }
 
 void Factory::RegisterElementInstancer(const String& name, ElementInstancer* instancer)
 {
-	element_instancers[StringUtilities::ToLower(name)] = instancer;
+	GET_OR_MAKE_GLOBAL(element_instancers)[StringUtilities::ToLower(name)] = instancer;
 }
 
 // Looks up the instancer for the given element
 ElementInstancer* Factory::GetElementInstancer(const String& tag)
 {
-	ElementInstancerMap::iterator instancer_iterator = element_instancers.find(tag);
-	if (instancer_iterator == element_instancers.end())
+	ElementInstancerMap::iterator instancer_iterator = GET_OR_MAKE_GLOBAL(element_instancers).find(tag);
+	if (instancer_iterator == GET_OR_MAKE_GLOBAL(element_instancers).end())
 	{
-		instancer_iterator = element_instancers.find("*");
-		if (instancer_iterator == element_instancers.end())
+		instancer_iterator = GET_OR_MAKE_GLOBAL(element_instancers).find("*");
+		if (instancer_iterator == GET_OR_MAKE_GLOBAL(element_instancers).end())
 			return nullptr;
 	}
 
@@ -502,14 +502,14 @@ ElementPtr Factory::InstanceDocumentStream(Context* context, Stream* stream, con
 void Factory::RegisterDecoratorInstancer(const String& name, DecoratorInstancer* instancer)
 {
 	RMLUI_ASSERT(instancer);
-	decorator_instancers[StringUtilities::ToLower(name)] = instancer;
+	GET_OR_MAKE_GLOBAL(decorator_instancers)[StringUtilities::ToLower(name)] = instancer;
 }
 
 // Retrieves a decorator instancer registered with the factory.
 DecoratorInstancer* Factory::GetDecoratorInstancer(const String& name)
 {
-	auto iterator = decorator_instancers.find(name);
-	if (iterator == decorator_instancers.end())
+	auto iterator = GET_OR_MAKE_GLOBAL(decorator_instancers).find(name);
+	if (iterator == GET_OR_MAKE_GLOBAL(decorator_instancers).end())
 		return nullptr;
 	
 	return iterator->second;
@@ -519,13 +519,13 @@ DecoratorInstancer* Factory::GetDecoratorInstancer(const String& name)
 void Factory::RegisterFontEffectInstancer(const String& name, FontEffectInstancer* instancer)
 {
 	RMLUI_ASSERT(instancer);
-	font_effect_instancers[StringUtilities::ToLower(name)] = instancer;
+	GET_OR_MAKE_GLOBAL(font_effect_instancers)[StringUtilities::ToLower(name)] = instancer;
 }
 
 FontEffectInstancer* Factory::GetFontEffectInstancer(const String& name)
 {
-	auto iterator = font_effect_instancers.find(name);
-	if (iterator == font_effect_instancers.end())
+	auto iterator = GET_OR_MAKE_GLOBAL(font_effect_instancers).find(name);
+	if (iterator == GET_OR_MAKE_GLOBAL(font_effect_instancers).end())
 		return nullptr;
 
 	return iterator->second;
@@ -573,30 +573,30 @@ void Factory::ClearTemplateCache()
 // Registers an instancer for all RmlEvents
 void Factory::RegisterEventInstancer(EventInstancer* instancer)
 {
-	event_instancer = instancer;
+	GET_OR_MAKE_GLOBAL(event_instancer) = instancer;
 }
 
 // Instance an event object.
 EventPtr Factory::InstanceEvent(Element* target, EventId id, const String& type, const Dictionary& parameters, bool interruptible)
 {
-	EventPtr event = event_instancer->InstanceEvent(target, id, type, parameters, interruptible);
+	EventPtr event = GET_OR_MAKE_GLOBAL(event_instancer)->InstanceEvent(target, id, type, parameters, interruptible);
 	if (event)
-		event->instancer = event_instancer;
+		event->instancer = GET_OR_MAKE_GLOBAL(event_instancer);
 	return event;
 }
 
 // Register an instancer for all event listeners
 void Factory::RegisterEventListenerInstancer(EventListenerInstancer* instancer)
 {
-	event_listener_instancer = instancer;
+	GET_OR_MAKE_GLOBAL(event_listener_instancer) = instancer;
 }
 
 // Instance an event listener with the given string
 EventListener* Factory::InstanceEventListener(const String& value, Element* element)
 {
 	// If we have an event listener instancer, use it
-	if (event_listener_instancer)
-		return event_listener_instancer->InstanceEventListener(value, element);
+	if (GET_OR_MAKE_GLOBAL(event_listener_instancer))
+		return GET_OR_MAKE_GLOBAL(event_listener_instancer)->InstanceEventListener(value, element);
 
 	return nullptr;
 }
@@ -606,13 +606,13 @@ void Factory::RegisterDataViewInstancer(DataViewInstancer* instancer, const Stri
 	bool inserted = false;
 	if (is_structural_view)
 	{
-		inserted = structural_data_view_instancers.emplace(name, instancer).second;
+		inserted = GET_OR_MAKE_GLOBAL(structural_data_view_instancers).emplace(name, instancer).second;
 		if (inserted)
-			structural_data_view_attribute_names.push_back(String("data-") + name);
+			GET_OR_MAKE_GLOBAL(structural_data_view_attribute_names).push_back(String("data-") + name);
 	}
 	else
 	{
-		inserted = data_view_instancers.emplace(name, instancer).second;
+		inserted = GET_OR_MAKE_GLOBAL(data_view_instancers).emplace(name, instancer).second;
 	}
 	
 	if (!inserted)
@@ -621,7 +621,7 @@ void Factory::RegisterDataViewInstancer(DataViewInstancer* instancer, const Stri
 
 void Factory::RegisterDataControllerInstancer(DataControllerInstancer* instancer, const String& name)
 {
-	bool inserted = data_controller_instancers.emplace(name, instancer).second;
+	bool inserted = GET_OR_MAKE_GLOBAL(data_controller_instancers).emplace(name, instancer).second;
 	if (!inserted)
 		Log::Message(Log::LT_WARNING, "Could not register data controller instancer '%s'. The given name is already registered.", name.c_str());
 }
@@ -632,14 +632,14 @@ DataViewPtr Factory::InstanceDataView(const String& type_name, Element* element,
 
 	if (is_structural_view)
 	{
-		auto it = structural_data_view_instancers.find(type_name);
-		if (it != structural_data_view_instancers.end())
+		auto it = GET_OR_MAKE_GLOBAL(structural_data_view_instancers).find(type_name);
+		if (it != GET_OR_MAKE_GLOBAL(structural_data_view_instancers).end())
 			return it->second->InstanceView(element);
 	}
 	else
 	{
-		auto it = data_view_instancers.find(type_name);
-		if (it != data_view_instancers.end())
+		auto it = GET_OR_MAKE_GLOBAL(data_view_instancers).find(type_name);
+		if (it != GET_OR_MAKE_GLOBAL(data_view_instancers).end())
 			return it->second->InstanceView(element);
 	}
 	return nullptr;
@@ -647,20 +647,20 @@ DataViewPtr Factory::InstanceDataView(const String& type_name, Element* element,
 
 DataControllerPtr Factory::InstanceDataController(const String& type_name, Element* element)
 {
-	auto it = data_controller_instancers.find(type_name);
-	if (it != data_controller_instancers.end())
+	auto it = GET_OR_MAKE_GLOBAL(data_controller_instancers).find(type_name);
+	if (it != GET_OR_MAKE_GLOBAL(data_controller_instancers).end())
 		return it->second->InstanceController(element);
 	return DataControllerPtr();
 }
 
 bool Factory::IsStructuralDataView(const String& type_name)
 {
-	return structural_data_view_instancers.find(type_name) != structural_data_view_instancers.end();
+	return GET_OR_MAKE_GLOBAL(structural_data_view_instancers).find(type_name) != GET_OR_MAKE_GLOBAL(structural_data_view_instancers).end();
 }
 
 const StringList& Factory::GetStructuralDataViewAttributeNames()
 {
-	return structural_data_view_attribute_names;
+	return GET_OR_MAKE_GLOBAL(structural_data_view_attribute_names);
 }
 
 } // namespace Rml
diff --git externals/rmlui/Source/Core/FontEngineDefault/FontProvider.cpp externals/rmlui/Source/Core/FontEngineDefault/FontProvider.cpp
index 346addf8..a6509591 100644
--- externals/rmlui/Source/Core/FontEngineDefault/FontProvider.cpp
+++ externals/rmlui/Source/Core/FontEngineDefault/FontProvider.cpp
@@ -27,52 +27,52 @@
  */
 
 #include "FontProvider.h"
-#include "FontFace.h"
-#include "FontFamily.h"
-#include "FreeTypeInterface.h"
-#include "../LayoutInlineBoxText.h"
+#include "../../../Include/RmlUi/Core/Context.h"
 #include "../../../Include/RmlUi/Core/Core.h"
 #include "../../../Include/RmlUi/Core/FileInterface.h"
 #include "../../../Include/RmlUi/Core/Log.h"
 #include "../../../Include/RmlUi/Core/Math.h"
 #include "../../../Include/RmlUi/Core/StringUtilities.h"
+#include "../LayoutInlineBoxText.h"
+#include "FontFace.h"
+#include "FontFamily.h"
+#include "FreeTypeInterface.h"
 #include <algorithm>
 
 namespace Rml {
-
-static FontProvider* g_font_provider = nullptr;
+REGISTER_GLOBAL(FontProvider*, g_font_provider);
 
 FontProvider::FontProvider()
 {
-	RMLUI_ASSERT(!g_font_provider);
+	RMLUI_ASSERT(!GET_OR_MAKE_GLOBAL(g_font_provider));
 }
 
 FontProvider::~FontProvider()
 {
-	RMLUI_ASSERT(g_font_provider == this);
+	RMLUI_ASSERT(GET_OR_MAKE_GLOBAL(g_font_provider) == this);
 }
 
 bool FontProvider::Initialise()
 {
-	RMLUI_ASSERT(!g_font_provider);
+	RMLUI_ASSERT(!GET_OR_MAKE_GLOBAL(g_font_provider));
 	if (!FreeType::Initialise())
 		return false;
-	g_font_provider = new FontProvider;
+	GET_OR_MAKE_GLOBAL(g_font_provider) = new FontProvider;
 	return true;
 }
 
 void FontProvider::Shutdown()
 {
-	RMLUI_ASSERT(g_font_provider);
-	delete g_font_provider;
-	g_font_provider = nullptr;
+	RMLUI_ASSERT(GET_OR_MAKE_GLOBAL(g_font_provider));
+	delete GET_OR_MAKE_GLOBAL(g_font_provider);
+	GET_OR_MAKE_GLOBAL(g_font_provider) = nullptr;
 	FreeType::Shutdown();
 }
 
 FontProvider& FontProvider::Get()
 {
-	RMLUI_ASSERT(g_font_provider);
-	return *g_font_provider;
+	RMLUI_ASSERT(GET_OR_MAKE_GLOBAL(g_font_provider));
+	return *GET_OR_MAKE_GLOBAL(g_font_provider);
 }
 
 FontFaceHandleDefault* FontProvider::GetFontFaceHandle(const String& family, Style::FontStyle style, Style::FontWeight weight, int size)
@@ -105,8 +105,8 @@ FontFaceHandleDefault* FontProvider::GetFallbackFontFace(int index, int font_siz
 
 void FontProvider::ReleaseFontResources()
 {
-	RMLUI_ASSERT(g_font_provider);
-	for (auto& name_family : g_font_provider->font_families)
+	RMLUI_ASSERT(GET_OR_MAKE_GLOBAL(g_font_provider));
+	for (auto& name_family : GET_OR_MAKE_GLOBAL(g_font_provider)->font_families)
 		name_family.second->ReleaseFontResources();
 }
 
@@ -133,18 +133,16 @@ bool FontProvider::LoadFontFace(const String& file_name, bool fallback_face, Sty
 	return result;
 }
 
-
 bool FontProvider::LoadFontFace(const byte* data, int data_size, const String& font_family, Style::FontStyle style, Style::FontWeight weight,
 	bool fallback_face)
 {
 	const String source = "memory";
-	
+
 	bool result = Get().LoadFontFace(data, data_size, fallback_face, nullptr, source, font_family, style, weight);
-	
+
 	return result;
 }
 
-
 bool FontProvider::LoadFontFace(const byte* data, int data_size, bool fallback_face, UniquePtr<byte[]> face_memory, const String& source,
 	String font_family, Style::FontStyle style, Style::FontWeight weight)
 {
@@ -180,7 +178,7 @@ bool FontProvider::LoadFontFace(const byte* data, int data_size, bool fallback_f
 
 			int best_width_distance = Math::AbsoluteValue((int)it->width - search_width);
 			auto it_best_width = it;
-			
+
 			// Search forward to find the best 'width' with the same weight.
 			for (++it; it != face_variations.end(); ++it)
 			{
@@ -265,5 +263,4 @@ bool FontProvider::AddFace(FontFaceHandleFreetype face, const String& family, St
 	return static_cast<bool>(font_face_result);
 }
 
-
 } // namespace Rml
diff --git externals/rmlui/Source/Core/FontEngineDefault/FreeTypeInterface.cpp externals/rmlui/Source/Core/FontEngineDefault/FreeTypeInterface.cpp
index 4b0632f1..d7e6b195 100644
--- externals/rmlui/Source/Core/FontEngineDefault/FreeTypeInterface.cpp
+++ externals/rmlui/Source/Core/FontEngineDefault/FreeTypeInterface.cpp
@@ -28,20 +28,18 @@
 
 #include "FreeTypeInterface.h"
 #include "../../../Include/RmlUi/Core/ComputedValues.h"
+#include "../../../Include/RmlUi/Core/Context.h"
 #include "../../../Include/RmlUi/Core/Log.h"
 #include <algorithm>
-#include <string.h>
-#include <limits.h>
-
 #include <ft2build.h>
+#include <limits.h>
+#include <string.h>
 #include FT_FREETYPE_H
 #include FT_MULTIPLE_MASTERS_H
 #include FT_TRUETYPE_TABLES_H
 
 namespace Rml {
-
-static FT_Library ft_library = nullptr;
-
+REGISTER_GLOBAL(FT_Library, ft_library);
 static bool BuildGlyph(FT_Face ft_face, Character character, FontGlyphMap& glyphs, float bitmap_scaling_factor);
 static void BuildGlyphMap(FT_Face ft_face, int size, FontGlyphMap& glyphs, float bitmap_scaling_factor, bool load_default_glyphs);
 static void GenerateMetrics(FT_Face ft_face, FontMetrics& metrics, float bitmap_scaling_factor);
@@ -56,9 +54,9 @@ static int ConvertFixed16_16ToInt(int32_t fx)
 
 bool FreeType::Initialise()
 {
-	RMLUI_ASSERT(!ft_library);
+	RMLUI_ASSERT(!GET_OR_MAKE_GLOBAL(ft_library));
 
-	FT_Error result = FT_Init_FreeType(&ft_library);
+	FT_Error result = FT_Init_FreeType(&GET_OR_MAKE_GLOBAL(ft_library));
 	if (result != 0)
 	{
 		Log::Message(Log::LT_ERROR, "Failed to initialise FreeType, error %d.", result);
@@ -71,19 +69,19 @@ bool FreeType::Initialise()
 
 void FreeType::Shutdown()
 {
-	if (ft_library != nullptr)
+	if (GET_OR_MAKE_GLOBAL(ft_library) != nullptr)
 	{
-		FT_Done_FreeType(ft_library);
-		ft_library = nullptr;
+		FT_Done_FreeType(GET_OR_MAKE_GLOBAL(ft_library));
+		GET_OR_MAKE_GLOBAL(ft_library) = nullptr;
 	}
 }
 
 bool FreeType::GetFaceVariations(const byte* data, int data_length, Vector<FaceVariation>& out_face_variations)
 {
-	RMLUI_ASSERT(ft_library);
+	RMLUI_ASSERT(GET_OR_MAKE_GLOBAL(ft_library));
 
 	FT_Face face = nullptr;
-	FT_Error error = FT_New_Memory_Face(ft_library, (const FT_Byte*)data, data_length, 0, &face);
+	FT_Error error = FT_New_Memory_Face(GET_OR_MAKE_GLOBAL(ft_library), (const FT_Byte*)data, data_length, 0, &face);
 	if (error)
 		return false;
 
@@ -117,20 +115,15 @@ bool FreeType::GetFaceVariations(const byte* data, int data_length, Vector<FaceV
 			uint16_t width = (axis_index_width < num_axis ? (uint16_t)ConvertFixed16_16ToInt(var->namedstyle[i].coords[axis_index_width]) : 0);
 			int named_instance_index = (i + 1);
 
-			out_face_variations.push_back(
-				FaceVariation{
-					weight == 0 ? Style::FontWeight::Normal : (Style::FontWeight)weight,
-					width == 0 ? (uint16_t)100 : width,
-					named_instance_index
-				}
-			);
+			out_face_variations.push_back(FaceVariation{weight == 0 ? Style::FontWeight::Normal : (Style::FontWeight)weight,
+				width == 0 ? (uint16_t)100 : width, named_instance_index});
 		}
 	}
 
 	std::sort(out_face_variations.begin(), out_face_variations.end());
 
 #if FREETYPE_MAJOR >= 2 && FREETYPE_MINOR >= 9
-	FT_Done_MM_Var(ft_library, var);
+	FT_Done_MM_Var(GET_OR_MAKE_GLOBAL(ft_library), var);
 #endif
 
 	FT_Done_Face(face);
@@ -140,10 +133,10 @@ bool FreeType::GetFaceVariations(const byte* data, int data_length, Vector<FaceV
 
 FontFaceHandleFreetype FreeType::LoadFace(const byte* data, int data_length, const String& source, int named_style_index)
 {
-	RMLUI_ASSERT(ft_library);
+	RMLUI_ASSERT(GET_OR_MAKE_GLOBAL(ft_library));
 
 	FT_Face face = nullptr;
-	FT_Error error = FT_New_Memory_Face(ft_library, (const FT_Byte*)data, data_length, (named_style_index << 16), &face);
+	FT_Error error = FT_New_Memory_Face(GET_OR_MAKE_GLOBAL(ft_library), (const FT_Byte*)data, data_length, (named_style_index << 16), &face);
 	if (error)
 	{
 		Log::Message(Log::LT_ERROR, "FreeType error %d while loading face from %s.", error, source.c_str());
@@ -230,7 +223,6 @@ bool FreeType::AppendGlyph(FontFaceHandleFreetype face, int font_size, Character
 	return true;
 }
 
-
 int FreeType::GetKerning(FontFaceHandleFreetype face, int font_size, Character lhs, Character rhs)
 {
 	FT_Face ft_face = (FT_Face)face;
@@ -248,13 +240,8 @@ int FreeType::GetKerning(FontFaceHandleFreetype face, int font_size, Character l
 
 	FT_Vector ft_kerning;
 
-	FT_Error ft_error = FT_Get_Kerning(
-		ft_face,
-		FT_Get_Char_Index(ft_face, (FT_ULong)lhs),
-		FT_Get_Char_Index(ft_face, (FT_ULong)rhs),
-		FT_KERNING_DEFAULT,
-		&ft_kerning
-	);
+	FT_Error ft_error = FT_Get_Kerning(ft_face, FT_Get_Char_Index(ft_face, (FT_ULong)lhs), FT_Get_Char_Index(ft_face, (FT_ULong)rhs),
+		FT_KERNING_DEFAULT, &ft_kerning);
 
 	if (ft_error)
 		return 0;
@@ -270,8 +257,6 @@ bool FreeType::HasKerning(FontFaceHandleFreetype face)
 	return FT_HAS_KERNING(ft_face);
 }
 
-
-
 static void BuildGlyphMap(FT_Face ft_face, int size, FontGlyphMap& glyphs, const float bitmap_scaling_factor, const bool load_default_glyphs)
 {
 	if (load_default_glyphs)
@@ -292,10 +277,10 @@ static void BuildGlyphMap(FT_Face ft_face, int size, FontGlyphMap& glyphs, const
 	if (it == glyphs.end())
 	{
 		FontGlyph glyph;
-		glyph.dimensions = { size / 3, (size * 2) / 3 };
+		glyph.dimensions = {size / 3, (size * 2) / 3};
 		glyph.bitmap_dimensions = glyph.dimensions;
 		glyph.advance = glyph.dimensions.x + 2;
-		glyph.bearing = { 1, glyph.dimensions.y };
+		glyph.bearing = {1, glyph.dimensions.y};
 
 		glyph.bitmap_owned_data.reset(new byte[glyph.bitmap_dimensions.x * glyph.bitmap_dimensions.y]);
 		glyph.bitmap_data = glyph.bitmap_owned_data.get();
@@ -324,21 +309,24 @@ static bool BuildGlyph(FT_Face ft_face, const Character character, FontGlyphMap&
 	FT_Error error = FT_Load_Glyph(ft_face, index, FT_LOAD_COLOR);
 	if (error != 0)
 	{
-		Log::Message(Log::LT_WARNING, "Unable to load glyph for character '%u' on the font face '%s %s'; error code: %d.", (unsigned int)character, ft_face->family_name, ft_face->style_name, error);
+		Log::Message(Log::LT_WARNING, "Unable to load glyph for character '%u' on the font face '%s %s'; error code: %d.", (unsigned int)character,
+			ft_face->family_name, ft_face->style_name, error);
 		return false;
 	}
 
 	error = FT_Render_Glyph(ft_face->glyph, FT_RENDER_MODE_NORMAL);
 	if (error != 0)
 	{
-		Log::Message(Log::LT_WARNING, "Unable to render glyph for character '%u' on the font face '%s %s'; error code: %d.", (unsigned int)character, ft_face->family_name, ft_face->style_name, error);
+		Log::Message(Log::LT_WARNING, "Unable to render glyph for character '%u' on the font face '%s %s'; error code: %d.", (unsigned int)character,
+			ft_face->family_name, ft_face->style_name, error);
 		return false;
 	}
 
 	auto result = glyphs.emplace(character, FontGlyph{});
 	if (!result.second)
 	{
-		Log::Message(Log::LT_WARNING, "Glyph character '%u' is already loaded in the font face '%s %s'.", (unsigned int)character, ft_face->family_name, ft_face->style_name);
+		Log::Message(Log::LT_WARNING, "Glyph character '%u' is already loaded in the font face '%s %s'.", (unsigned int)character,
+			ft_face->family_name, ft_face->style_name);
 		return false;
 	}
 
diff --git externals/rmlui/Source/Core/GeometryDatabase.cpp externals/rmlui/Source/Core/GeometryDatabase.cpp
index b4a9160e..cd3dfe61 100644
--- externals/rmlui/Source/Core/GeometryDatabase.cpp
+++ externals/rmlui/Source/Core/GeometryDatabase.cpp
@@ -27,6 +27,7 @@
  */
 
 #include "GeometryDatabase.h"
+#include "../../Include/RmlUi/Core/Context.h"
 #include "../../Include/RmlUi/Core/Geometry.h"
 #include <algorithm>
 
@@ -114,21 +115,21 @@ private:
 };
 
 
-static Database geometry_database;
+REGISTER_GLOBAL(Database, geometry_database);
 
 GeometryDatabaseHandle Insert(Geometry* geometry)
 {
-	return geometry_database.insert(geometry);
+	return GET_OR_MAKE_GLOBAL(geometry_database).insert(geometry);
 }
 
 void Erase(GeometryDatabaseHandle handle)
 {
-	geometry_database.erase(handle);
+	GET_OR_MAKE_GLOBAL(geometry_database).erase(handle);
 }
 
 void ReleaseAll()
 {
-	geometry_database.for_each([](Geometry* geometry) {
+	GET_OR_MAKE_GLOBAL(geometry_database).for_each([](Geometry* geometry) {
 		geometry->Release();
 	});
 }
@@ -138,11 +139,11 @@ void ReleaseAll()
 
 bool PrepareForTests()
 {
-	if (geometry_database.size() > 0)
+	if (GET_OR_MAKE_GLOBAL(geometry_database).size() > 0)
 		return false;
 
 	// Even with size()==0 we can have items in the geometry list which should all be duplicated by the free list. We want to clear them for the tests.
-	geometry_database.clear();
+	GET_OR_MAKE_GLOBAL(geometry_database).clear();
 
 	return true;
 }
@@ -153,7 +154,7 @@ bool ListMatchesDatabase(const Vector<Geometry>& geometry_list)
 	std::for_each(geometry_list.begin(), geometry_list.end(), [&](const Geometry& geometry) { geometry_list_ptrs.push_back(&geometry); });
 
 	Vector<const Geometry*> database_ptrs;
-	geometry_database.for_each([&](const Geometry* geometry) { database_ptrs.push_back(geometry); });
+	GET_OR_MAKE_GLOBAL(geometry_database).for_each([&](const Geometry* geometry) { database_ptrs.push_back(geometry); });
 
 	const bool result = std::is_permutation(geometry_list_ptrs.begin(), geometry_list_ptrs.end(), database_ptrs.begin(), database_ptrs.end());
 	return result;
diff --git externals/rmlui/Source/Core/GlobalContext.cpp externals/rmlui/Source/Core/GlobalContext.cpp
new file mode 100644
index 00000000..39575cc1
--- /dev/null
+++ externals/rmlui/Source/Core/GlobalContext.cpp
@@ -0,0 +1,17 @@
+#include "../../Include/RmlUi/Core/Context.h"
+
+namespace Rml {
+
+thread_local GlobalContext* sCtx;
+
+Rml::GlobalContext* GlobalContext::GetGlobalContextForThread()
+{
+	return sCtx;
+}
+
+void GlobalContext::SetGlobalContextForThread(Rml::GlobalContext* context)
+{
+	sCtx = context;
+}
+
+} // namespace Rml
\ No newline at end of file
diff --git externals/rmlui/Source/Core/LayoutEngine.cpp externals/rmlui/Source/Core/LayoutEngine.cpp
index 07d3f52a..18d4a984 100644
--- externals/rmlui/Source/Core/LayoutEngine.cpp
+++ externals/rmlui/Source/Core/LayoutEngine.cpp
@@ -28,6 +28,7 @@
 
 #include "LayoutEngine.h"
 #include "../../Include/RmlUi/Core/ComputedValues.h"
+#include "../../Include/RmlUi/Core/Context.h"
 #include "../../Include/RmlUi/Core/Element.h"
 #include "../../Include/RmlUi/Core/Profiling.h"
 #include "../../Include/RmlUi/Core/Types.h"
@@ -53,9 +54,12 @@ static constexpr std::size_t ChunkSizeBig = sizeof(LayoutBlockBox);
 static constexpr std::size_t ChunkSizeMedium = MAX(sizeof(LayoutInlineBox), sizeof(LayoutInlineBoxText));
 static constexpr std::size_t ChunkSizeSmall = MAX(sizeof(LayoutLineBox), sizeof(LayoutBlockBoxSpace));
 
-static Pool< LayoutChunk<ChunkSizeBig> > layout_chunk_pool_big(50, true);
-static Pool< LayoutChunk<ChunkSizeMedium> > layout_chunk_pool_medium(50, true);
-static Pool< LayoutChunk<ChunkSizeSmall> > layout_chunk_pool_small(50, true);
+#define layout_chunk_pool_big_params 50, true
+#define layout_chunk_pool_medium_params 50, true
+#define layout_chunk_pool_small_params 50, true
+REGISTER_INIT_GLOBAL(Pool< LayoutChunk<ChunkSizeBig> >, layout_chunk_pool_big);
+REGISTER_INIT_GLOBAL(Pool< LayoutChunk<ChunkSizeMedium> >, layout_chunk_pool_medium);
+REGISTER_INIT_GLOBAL(Pool< LayoutChunk<ChunkSizeSmall> >, layout_chunk_pool_small);
 
 static inline bool ValidateTopLevelElement(Element* element)
 {
@@ -136,11 +140,11 @@ void* LayoutEngine::AllocateLayoutChunk(size_t size)
 
 	// Note: If any change is made here, make sure a corresponding change is applied to the deallocation procedure below.
 	if (size <= ChunkSizeSmall)
-		return layout_chunk_pool_small.AllocateAndConstruct();
+		return GET_OR_MAKE_INIT_GLOBAL(layout_chunk_pool_small).AllocateAndConstruct();
 	else if (size <= ChunkSizeMedium)
-		return layout_chunk_pool_medium.AllocateAndConstruct();
+		return GET_OR_MAKE_INIT_GLOBAL(layout_chunk_pool_medium).AllocateAndConstruct();
 	else if (size <= ChunkSizeBig)
-		return layout_chunk_pool_big.AllocateAndConstruct();
+		return GET_OR_MAKE_INIT_GLOBAL(layout_chunk_pool_big).AllocateAndConstruct();
 
 	RMLUI_ERROR;
 	return nullptr;
@@ -150,11 +154,11 @@ void LayoutEngine::DeallocateLayoutChunk(void* chunk, size_t size)
 {
 	// Note: If any change is made here, make sure a corresponding change is applied to the allocation procedure above.
 	if (size <= ChunkSizeSmall)
-		layout_chunk_pool_small.DestroyAndDeallocate((LayoutChunk<ChunkSizeSmall>*)chunk);
+		GET_OR_MAKE_INIT_GLOBAL(layout_chunk_pool_small).DestroyAndDeallocate((LayoutChunk<ChunkSizeSmall>*)chunk);
 	else if (size <= ChunkSizeMedium)
-		layout_chunk_pool_medium.DestroyAndDeallocate((LayoutChunk<ChunkSizeMedium>*)chunk);
+		GET_OR_MAKE_INIT_GLOBAL(layout_chunk_pool_medium).DestroyAndDeallocate((LayoutChunk<ChunkSizeMedium>*)chunk);
 	else if (size <= ChunkSizeBig)
-		layout_chunk_pool_big.DestroyAndDeallocate((LayoutChunk<ChunkSizeBig>*)chunk);
+		GET_OR_MAKE_INIT_GLOBAL(layout_chunk_pool_big).DestroyAndDeallocate((LayoutChunk<ChunkSizeBig>*)chunk);
 	else
 	{
 		RMLUI_ERROR;
diff --git externals/rmlui/Source/Core/Memory.cpp externals/rmlui/Source/Core/Memory.cpp
index 407c1c1f..51951cdf 100644
--- externals/rmlui/Source/Core/Memory.cpp
+++ externals/rmlui/Source/Core/Memory.cpp
@@ -30,6 +30,7 @@
 #include <memory>
 #include <stdlib.h>
 #include <stdint.h>
+#include "../../Include/RmlUi/Core/Context.h"
 
 namespace Rml {
 
@@ -86,10 +87,12 @@ void BasicStackAllocator::deallocate(void* obj) noexcept
     p = obj;
 }
 
+#define stack_allocator_params 10 * 1024
+REGISTER_INIT_GLOBAL(BasicStackAllocator, stack_allocator);
+
 BasicStackAllocator& GetGlobalBasicStackAllocator()
 {
-	static BasicStackAllocator stack_allocator(10 * 1024);
-	return stack_allocator;
+	return GET_OR_MAKE_INIT_GLOBAL(stack_allocator);
 }
 
 }
diff --git externals/rmlui/Source/Core/ObserverPtr.cpp externals/rmlui/Source/Core/ObserverPtr.cpp
index 6c67d022..463d1e1e 100644
--- externals/rmlui/Source/Core/ObserverPtr.cpp
+++ externals/rmlui/Source/Core/ObserverPtr.cpp
@@ -15,7 +15,7 @@
  *
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -27,24 +27,24 @@
  */
 
 #include "../../Include/RmlUi/Core/ObserverPtr.h"
+#include "../../Include/RmlUi/Core/Context.h"
 #include "Pool.h"
 
 namespace Rml {
 
 // The ObserverPtrBlock pool
-Pool<ObserverPtrBlock>* observerPtrBlockPool = nullptr;
+REGISTER_GLOBAL(Pool<ObserverPtrBlock>*, observerPtrBlockPool);
 
 static Pool<ObserverPtrBlock>& GetPool()
 {
 	// Wrap pool in a function to ensure it is initialized before use.
 	// This pool must outlive all other global variables that derive from EnableObserverPtr. This even includes
 	// user variables which we have no control over. For this reason, we intentionally let this leak.
-	if (observerPtrBlockPool == nullptr)
-		observerPtrBlockPool = new Pool<ObserverPtrBlock>(128, true);
-	return *observerPtrBlockPool;
+	if (GET_OR_MAKE_GLOBAL(observerPtrBlockPool) == nullptr)
+		GET_OR_MAKE_GLOBAL(observerPtrBlockPool) = new Pool<ObserverPtrBlock>(128, true);
+	return *GET_OR_MAKE_GLOBAL(observerPtrBlockPool);
 }
 
-
 void DeallocateObserverPtrBlockIfEmpty(ObserverPtrBlock* block)
 {
 	RMLUI_ASSERT(block->num_observers >= 0);
@@ -59,6 +59,4 @@ ObserverPtrBlock* AllocateObserverPtrBlock()
 	return GetPool().AllocateAndConstruct();
 }
 
-
-
 } // namespace Rml
diff --git externals/rmlui/Source/Core/PluginRegistry.cpp externals/rmlui/Source/Core/PluginRegistry.cpp
index 4487edd5..5220f2de 100644
--- externals/rmlui/Source/Core/PluginRegistry.cpp
+++ externals/rmlui/Source/Core/PluginRegistry.cpp
@@ -27,15 +27,16 @@
  */
 
 #include "PluginRegistry.h"
+#include "../../Include/RmlUi/Core/Context.h"
 #include "../../Include/RmlUi/Core/Plugin.h"
 #include <algorithm>
 
 namespace Rml {
 
 typedef Vector< Plugin* > PluginList;
-static PluginList basic_plugins;
-static PluginList document_plugins;
-static PluginList element_plugins;
+REGISTER_GLOBAL(PluginList, basic_plugins);
+REGISTER_GLOBAL(PluginList, document_plugins);
+REGISTER_GLOBAL(PluginList, element_plugins);
 
 PluginRegistry::PluginRegistry()
 {
@@ -46,11 +47,11 @@ void PluginRegistry::RegisterPlugin(Plugin* plugin)
 	int event_classes = plugin->GetEventClasses();
 	
 	if (event_classes & Plugin::EVT_BASIC)
-		basic_plugins.push_back(plugin);
+		GET_OR_MAKE_GLOBAL(basic_plugins).push_back(plugin);
 	if (event_classes & Plugin::EVT_DOCUMENT)
-		document_plugins.push_back(plugin);
+		GET_OR_MAKE_GLOBAL(document_plugins).push_back(plugin);
 	if (event_classes & Plugin::EVT_ELEMENT)
-		element_plugins.push_back(plugin);
+		GET_OR_MAKE_GLOBAL(element_plugins).push_back(plugin);
 }
 
 void PluginRegistry::UnregisterPlugin(Plugin* plugin)
@@ -58,79 +59,79 @@ void PluginRegistry::UnregisterPlugin(Plugin* plugin)
 	int event_classes = plugin->GetEventClasses();
 
 	if(event_classes & Plugin::EVT_BASIC)
-		basic_plugins.erase(std::remove(basic_plugins.begin(), basic_plugins.end(), plugin), basic_plugins.end());
+		GET_OR_MAKE_GLOBAL(basic_plugins).erase(std::remove(GET_OR_MAKE_GLOBAL(basic_plugins).begin(), GET_OR_MAKE_GLOBAL(basic_plugins).end(), plugin), GET_OR_MAKE_GLOBAL(basic_plugins).end());
 	if(event_classes & Plugin::EVT_DOCUMENT)
-		document_plugins.erase(std::remove(document_plugins.begin(), document_plugins.end(), plugin), document_plugins.end());
+		GET_OR_MAKE_GLOBAL(document_plugins).erase(std::remove(GET_OR_MAKE_GLOBAL(document_plugins).begin(), GET_OR_MAKE_GLOBAL(document_plugins).end(), plugin), GET_OR_MAKE_GLOBAL(document_plugins).end());
 	if(event_classes & Plugin::EVT_ELEMENT)
-		element_plugins.erase(std::remove(element_plugins.begin(), element_plugins.end(), plugin), element_plugins.end());
+		GET_OR_MAKE_GLOBAL(element_plugins).erase(std::remove(GET_OR_MAKE_GLOBAL(element_plugins).begin(), GET_OR_MAKE_GLOBAL(element_plugins).end(), plugin), GET_OR_MAKE_GLOBAL(element_plugins).end());
 }
 
 // Calls OnInitialise() on all plugins.
 void PluginRegistry::NotifyInitialise()
 {
-	for (size_t i = 0; i < basic_plugins.size(); ++i)
-		basic_plugins[i]->OnInitialise();
+	for (size_t i = 0; i < GET_OR_MAKE_GLOBAL(basic_plugins).size(); ++i)
+		GET_OR_MAKE_GLOBAL(basic_plugins)[i]->OnInitialise();
 }
 
 // Calls OnShutdown() on all plugins.
 void PluginRegistry::NotifyShutdown()
 {
-	while (!basic_plugins.empty())
+	while (!GET_OR_MAKE_GLOBAL(basic_plugins).empty())
 	{
-		basic_plugins.back()->OnShutdown();
-		basic_plugins.pop_back();
+		GET_OR_MAKE_GLOBAL(basic_plugins).back()->OnShutdown();
+		GET_OR_MAKE_GLOBAL(basic_plugins).pop_back();
 	}
-	document_plugins.clear();
-	element_plugins.clear();
+	GET_OR_MAKE_GLOBAL(document_plugins).clear();
+	GET_OR_MAKE_GLOBAL(element_plugins).clear();
 }
 
 // Calls OnContextCreate() on all plugins.
 void PluginRegistry::NotifyContextCreate(Context* context)
 {
-	for (size_t i = 0; i < basic_plugins.size(); ++i)
-		basic_plugins[i]->OnContextCreate(context);
+	for (size_t i = 0; i < GET_OR_MAKE_GLOBAL(basic_plugins).size(); ++i)
+		GET_OR_MAKE_GLOBAL(basic_plugins)[i]->OnContextCreate(context);
 }
 
 // Calls OnContextDestroy() on all plugins.
 void PluginRegistry::NotifyContextDestroy(Context* context)
 {
-	for (size_t i = 0; i < basic_plugins.size(); ++i)
-		basic_plugins[i]->OnContextDestroy(context);
+	for (size_t i = 0; i < GET_OR_MAKE_GLOBAL(basic_plugins).size(); ++i)
+		GET_OR_MAKE_GLOBAL(basic_plugins)[i]->OnContextDestroy(context);
 }
 
 // Calls OnDocumentOpen() on all plugins.
 void PluginRegistry::NotifyDocumentOpen(Context* context, const String& document_path)
 {
-	for (size_t i = 0; i < document_plugins.size(); ++i)
-		document_plugins[i]->OnDocumentOpen(context, document_path);
+	for (size_t i = 0; i < GET_OR_MAKE_GLOBAL(document_plugins).size(); ++i)
+		GET_OR_MAKE_GLOBAL(document_plugins)[i]->OnDocumentOpen(context, document_path);
 }
 
 // Calls OnDocumentLoad() on all plugins.
 void PluginRegistry::NotifyDocumentLoad(ElementDocument* document)
 {
-	for (size_t i = 0; i < document_plugins.size(); ++i)
-		document_plugins[i]->OnDocumentLoad(document);
+	for (size_t i = 0; i < GET_OR_MAKE_GLOBAL(document_plugins).size(); ++i)
+		GET_OR_MAKE_GLOBAL(document_plugins)[i]->OnDocumentLoad(document);
 }
 
 // Calls OnDocumentUnload() on all plugins.
 void PluginRegistry::NotifyDocumentUnload(ElementDocument* document)
 {
-	for (size_t i = 0; i < document_plugins.size(); ++i)
-		document_plugins[i]->OnDocumentUnload(document);
+	for (size_t i = 0; i < GET_OR_MAKE_GLOBAL(document_plugins).size(); ++i)
+		GET_OR_MAKE_GLOBAL(document_plugins)[i]->OnDocumentUnload(document);
 }
 
 // Calls OnElementCreate() on all plugins.
 void PluginRegistry::NotifyElementCreate(Element* element)
 {
-	for (size_t i = 0; i < element_plugins.size(); ++i)
-		element_plugins[i]->OnElementCreate(element);
+	for (size_t i = 0; i < GET_OR_MAKE_GLOBAL(element_plugins).size(); ++i)
+		GET_OR_MAKE_GLOBAL(element_plugins)[i]->OnElementCreate(element);
 }
 
 // Calls OnElementDestroy() on all plugins.
 void PluginRegistry::NotifyElementDestroy(Element* element)
 {
-	for (size_t i = 0; i < element_plugins.size(); ++i)
-		element_plugins[i]->OnElementDestroy(element);
+	for (size_t i = 0; i < GET_OR_MAKE_GLOBAL(element_plugins).size(); ++i)
+		GET_OR_MAKE_GLOBAL(element_plugins)[i]->OnElementDestroy(element);
 }
 
 } // namespace Rml
diff --git externals/rmlui/Source/Core/StringUtilities.cpp externals/rmlui/Source/Core/StringUtilities.cpp
index 017a5971..c2b3213f 100644
--- externals/rmlui/Source/Core/StringUtilities.cpp
+++ externals/rmlui/Source/Core/StringUtilities.cpp
@@ -38,7 +38,7 @@ namespace Rml {
 static int FormatString(String& string, size_t max_size, const char* format, va_list argument_list)
 {
 	const int INTERNAL_BUFFER_SIZE = 1024;
-	static char buffer[INTERNAL_BUFFER_SIZE];
+	char buffer[INTERNAL_BUFFER_SIZE];
 	char* buffer_ptr = buffer;
 
 	if (max_size + 1 > INTERNAL_BUFFER_SIZE)
diff --git externals/rmlui/Source/Core/StyleSheet.cpp externals/rmlui/Source/Core/StyleSheet.cpp
index 9bfa117a..cc9a5c99 100644
--- externals/rmlui/Source/Core/StyleSheet.cpp
+++ externals/rmlui/Source/Core/StyleSheet.cpp
@@ -27,6 +27,7 @@
  */
 
 #include "../../Include/RmlUi/Core/StyleSheet.h"
+#include "../../Include/RmlUi/Core/Context.h"
 #include "../../Include/RmlUi/Core/DecoratorInstancer.h"
 #include "../../Include/RmlUi/Core/Element.h"
 #include "../../Include/RmlUi/Core/Profiling.h"
@@ -163,14 +164,15 @@ const Sprite* StyleSheet::GetSprite(const String& name) const
 	return spritesheet_list.GetSprite(name);
 }
 
+REGISTER_GLOBAL(Vector< const StyleSheetNode* >, applicable_nodes);
+
 // Returns the compiled element definition for a given element hierarchy.
 SharedPtr<const ElementDefinition> StyleSheet::GetElementDefinition(const Element* element) const
 {
 	RMLUI_ASSERT_NONRECURSIVE;
 
 	// Using static to avoid allocations. Make sure we don't call this function recursively.
-	static Vector< const StyleSheetNode* > applicable_nodes;
-	applicable_nodes.clear();
+	GET_OR_MAKE_GLOBAL(applicable_nodes).clear();
 
 	auto AddApplicableNodes = [element](const StyleSheetIndex::NodeIndex& node_index, const String& key) {
 		auto it_nodes = node_index.find(Hash<String>()(key));
@@ -184,7 +186,7 @@ SharedPtr<const ElementDefinition> StyleSheet::GetElementDefinition(const Elemen
 				// node, including all ancestor nodes. What this involves is traversing the style nodes backwards, trying to match nodes in the
 				// element's hierarchy to nodes in the style hierarchy.
 				if (node->IsApplicable(element))
-					applicable_nodes.push_back(node);
+					GET_OR_MAKE_GLOBAL(applicable_nodes).push_back(node);
 			}
 		}
 	};
@@ -211,15 +213,15 @@ SharedPtr<const ElementDefinition> StyleSheet::GetElementDefinition(const Elemen
 	for (const StyleSheetNode* node : styled_node_index.other)
 	{
 		if (node->IsApplicable(element))
-			applicable_nodes.push_back(node);
+			GET_OR_MAKE_GLOBAL(applicable_nodes).push_back(node);
 	}
 
 	// If this element definition won't actually store any information, don't bother with it.
-	if (applicable_nodes.empty())
+	if (GET_OR_MAKE_GLOBAL(applicable_nodes).empty())
 		return nullptr;
 
 	// Sort the applicable nodes by specificity first, then by pointer value in case we have duplicate specificities.
-	std::sort(applicable_nodes.begin(), applicable_nodes.end(), [](const StyleSheetNode* a, const StyleSheetNode* b) {
+	std::sort(GET_OR_MAKE_GLOBAL(applicable_nodes).begin(), GET_OR_MAKE_GLOBAL(applicable_nodes).end(), [](const StyleSheetNode* a, const StyleSheetNode* b) {
 		const int a_specificity = a->GetSpecificity();
 		const int b_specificity = b->GetSpecificity();
 		if (a_specificity == b_specificity)
@@ -228,11 +230,11 @@ SharedPtr<const ElementDefinition> StyleSheet::GetElementDefinition(const Elemen
 	});
 
 	// Check if this puppy has already been cached in the node index.
-	SharedPtr<const ElementDefinition>& definition = node_cache[applicable_nodes];
+	SharedPtr<const ElementDefinition>& definition = node_cache[GET_OR_MAKE_GLOBAL(applicable_nodes)];
 	if (!definition)
 	{
 		// Otherwise, create a new definition and add it to our cache.
-		definition = MakeShared<const ElementDefinition>(applicable_nodes);
+		definition = MakeShared<const ElementDefinition>(GET_OR_MAKE_GLOBAL(applicable_nodes));
 	}
 
 	return definition;
diff --git externals/rmlui/Source/Core/StyleSheetFactory.cpp externals/rmlui/Source/Core/StyleSheetFactory.cpp
index 3c78cc35..de723d46 100644
--- externals/rmlui/Source/Core/StyleSheetFactory.cpp
+++ externals/rmlui/Source/Core/StyleSheetFactory.cpp
@@ -27,6 +27,7 @@
  */
 
 #include "StyleSheetFactory.h"
+#include "../../Include/RmlUi/Core/Context.h"
 #include "../../Include/RmlUi/Core/Log.h"
 #include "../../Include/RmlUi/Core/StyleSheetContainer.h"
 #include "StreamFile.h"
@@ -35,9 +36,9 @@
 #include "StyleSheetSelector.h"
 
 namespace Rml {
-
-static UniquePtr<StyleSheetFactory> instance;
-
+namespace {
+REGISTER_GLOBAL(UniquePtr<StyleSheetFactory>, instance);
+}
 StyleSheetFactory::StyleSheetFactory() :
 	selectors{
 		{"nth-child", StructuralSelectorType::Nth_Child},
@@ -59,32 +60,32 @@ StyleSheetFactory::~StyleSheetFactory() {}
 
 bool StyleSheetFactory::Initialise()
 {
-	RMLUI_ASSERT(instance == nullptr);
-	instance = UniquePtr<StyleSheetFactory>(new StyleSheetFactory);
+	RMLUI_ASSERT(GET_OR_MAKE_GLOBAL(instance) == nullptr);
+	GET_OR_MAKE_GLOBAL(instance) = UniquePtr<StyleSheetFactory>(new StyleSheetFactory);
 	return true;
 }
 
 void StyleSheetFactory::Shutdown()
 {
-	instance.reset();
+	GET_OR_MAKE_GLOBAL(instance).reset();
 }
 
 const StyleSheetContainer* StyleSheetFactory::GetStyleSheetContainer(const String& sheet_name)
 {
 	// Look up the sheet definition in the cache
-	auto it = instance->stylesheets.find(sheet_name);
-	if (it != instance->stylesheets.end())
+	auto it = GET_OR_MAKE_GLOBAL(instance)->stylesheets.find(sheet_name);
+	if (it != GET_OR_MAKE_GLOBAL(instance)->stylesheets.end())
 		return it->second.get();
 
 	// Don't currently have the sheet, attempt to load it
-	UniquePtr<const StyleSheetContainer> sheet = instance->LoadStyleSheetContainer(sheet_name);
+	UniquePtr<const StyleSheetContainer> sheet = GET_OR_MAKE_GLOBAL(instance)->LoadStyleSheetContainer(sheet_name);
 	if (!sheet)
 		return nullptr;
 
 	const StyleSheetContainer* result = sheet.get();
 
 	// Add it to the cache.
-	instance->stylesheets[sheet_name] = std::move(sheet);
+	GET_OR_MAKE_GLOBAL(instance)->stylesheets[sheet_name] = std::move(sheet);
 
 	return result;
 }
@@ -92,7 +93,7 @@ const StyleSheetContainer* StyleSheetFactory::GetStyleSheetContainer(const Strin
 // Clear the style sheet cache.
 void StyleSheetFactory::ClearStyleSheetCache()
 {
-	instance->stylesheets.clear();
+	GET_OR_MAKE_GLOBAL(instance)->stylesheets.clear();
 }
 
 // Returns one of the available node selectors.
@@ -102,11 +103,11 @@ StructuralSelector StyleSheetFactory::GetSelector(const String& name)
 	const size_t parameter_start = name.find('(');
 
 	if (parameter_start == String::npos)
-		it = instance->selectors.find(name);
+		it = GET_OR_MAKE_GLOBAL(instance)->selectors.find(name);
 	else
-		it = instance->selectors.find(name.substr(0, parameter_start));
+		it = GET_OR_MAKE_GLOBAL(instance)->selectors.find(name.substr(0, parameter_start));
 
-	if (it == instance->selectors.end())
+	if (it == GET_OR_MAKE_GLOBAL(instance)->selectors.end())
 		return StructuralSelector(StructuralSelectorType::Invalid, 0, 0);
 
 	const StructuralSelectorType selector_type = it->second;
diff --git externals/rmlui/Source/Core/StyleSheetParser.cpp externals/rmlui/Source/Core/StyleSheetParser.cpp
index 3fe6695a..3eaac1d8 100644
--- externals/rmlui/Source/Core/StyleSheetParser.cpp
+++ externals/rmlui/Source/Core/StyleSheetParser.cpp
@@ -30,6 +30,7 @@
 #include "ComputeProperty.h"
 #include "StyleSheetFactory.h"
 #include "StyleSheetNode.h"
+#include "../../Include/RmlUi/Core/Context.h"
 #include "../../Include/RmlUi/Core/DecoratorInstancer.h"
 #include "../../Include/RmlUi/Core/Factory.h"
 #include "../../Include/RmlUi/Core/Log.h"
@@ -159,8 +160,7 @@ public:
 	}
 };
 
-
-static UniquePtr<SpritesheetPropertyParser> spritesheet_property_parser;
+REGISTER_GLOBAL(UniquePtr<SpritesheetPropertyParser>, spritesheet_property_parser);
 
 /*
  * Media queries need a special parser because they have unique properties that 
@@ -218,7 +218,7 @@ public:
 };
 
 
-static UniquePtr<MediaQueryPropertyParser> media_query_property_parser;
+REGISTER_GLOBAL(UniquePtr<MediaQueryPropertyParser>, media_query_property_parser);
 
 
 StyleSheetParser::StyleSheetParser()
@@ -234,14 +234,14 @@ StyleSheetParser::~StyleSheetParser()
 
 void StyleSheetParser::Initialise()
 {
-	spritesheet_property_parser = MakeUnique<SpritesheetPropertyParser>();
-	media_query_property_parser = MakeUnique<MediaQueryPropertyParser>();
+	GET_OR_MAKE_GLOBAL(spritesheet_property_parser) = MakeUnique<SpritesheetPropertyParser>();
+	GET_OR_MAKE_GLOBAL(media_query_property_parser) = MakeUnique<MediaQueryPropertyParser>();
 }
 
 void StyleSheetParser::Shutdown()
 {
-	spritesheet_property_parser.reset();
-	media_query_property_parser.reset();
+	GET_OR_MAKE_GLOBAL(spritesheet_property_parser).reset();
+	GET_OR_MAKE_GLOBAL(media_query_property_parser).reset();
 }
 
 static bool IsValidIdentifier(const String& str)
@@ -421,7 +421,7 @@ bool StyleSheetParser::ParseDecoratorBlock(const String& at_name, DecoratorSpeci
 
 bool StyleSheetParser::ParseMediaFeatureMap(PropertyDictionary& properties, const String & rules)
 {
-	media_query_property_parser->SetTargetProperties(&properties);
+	GET_OR_MAKE_GLOBAL(media_query_property_parser)->SetTargetProperties(&properties);
 
 	enum ParseState { Global, Name, Value };
 	ParseState state = Name;
@@ -470,7 +470,7 @@ bool StyleSheetParser::ParseMediaFeatureMap(PropertyDictionary& properties, cons
 
 			current_string = StringUtilities::StripWhitespace(current_string);
 
-			if(!media_query_property_parser->Parse(name, current_string))
+			if(!GET_OR_MAKE_GLOBAL(media_query_property_parser)->Parse(name, current_string))
 				Log::Message(Log::LT_WARNING, "Syntax error parsing media-query property declaration '%s: %s;' in %s: %d.", name.c_str(), current_string.c_str(), stream_file_name.c_str(), line_number);
 
 			current_string.clear();
@@ -626,11 +626,11 @@ bool StyleSheetParser::Parse(MediaBlockList& style_sheets, Stream* _stream, int
 					else if (at_rule_identifier == "spritesheet")
 					{
 						// The spritesheet parser is reasonably heavy to initialize, so we make it a static global.
-						ReadProperties(*spritesheet_property_parser);
+						ReadProperties(*GET_OR_MAKE_GLOBAL(spritesheet_property_parser));
 
-						const String& image_source = spritesheet_property_parser->GetImageSource();
-						const SpriteDefinitionList& sprite_definitions = spritesheet_property_parser->GetSpriteDefinitions();
-						const float image_resolution_factor = spritesheet_property_parser->GetImageResolutionFactor();
+						const String& image_source = GET_OR_MAKE_GLOBAL(spritesheet_property_parser)->GetImageSource();
+						const SpriteDefinitionList& sprite_definitions = GET_OR_MAKE_GLOBAL(spritesheet_property_parser)->GetSpriteDefinitions();
+						const float image_resolution_factor = GET_OR_MAKE_GLOBAL(spritesheet_property_parser)->GetImageResolutionFactor();
 						
 						if (sprite_definitions.empty())
 						{
@@ -650,7 +650,7 @@ bool StyleSheetParser::Parse(MediaBlockList& style_sheets, Stream* _stream, int
 							current_block.stylesheet->spritesheet_list.AddSpriteSheet(at_rule_name, image_source, stream_file_name, (int)line_number, display_scale, sprite_definitions);
 						}
 
-						spritesheet_property_parser->Clear();
+						GET_OR_MAKE_GLOBAL(spritesheet_property_parser)->Clear();
 						at_rule_name.clear();
 						state = State::Global;
 					}
diff --git externals/rmlui/Source/Core/StyleSheetSpecification.cpp externals/rmlui/Source/Core/StyleSheetSpecification.cpp
index 17f74d0a..9f305d07 100644
--- externals/rmlui/Source/Core/StyleSheetSpecification.cpp
+++ externals/rmlui/Source/Core/StyleSheetSpecification.cpp
@@ -27,6 +27,7 @@
  */
 
 #include "../../Include/RmlUi/Core/StyleSheetSpecification.h"
+#include "../../Include/RmlUi/Core/Context.h"
 #include "../../Include/RmlUi/Core/PropertyIdSet.h"
 #include "../../Include/RmlUi/Core/PropertyDefinition.h"
 #include "PropertyParserNumber.h"
@@ -42,10 +43,9 @@
 #include "IdNameMap.h"
 
 namespace Rml {
-
-static StyleSheetSpecification* instance = nullptr;
-
-
+namespace {
+REGISTER_GLOBAL(StyleSheetSpecification*, instance);
+}
 struct DefaultStyleSheetParsers {
 	PropertyParserNumber number = PropertyParserNumber(Property::NUMBER);
 	PropertyParserNumber length = PropertyParserNumber(Property::LENGTH, Property::PX);
@@ -68,16 +68,16 @@ StyleSheetSpecification::StyleSheetSpecification() :
 	// Reserve space for all defined ids and some more for custom properties
 	properties((size_t)PropertyId::MaxNumIds, 2 * (size_t)ShorthandId::NumDefinedIds)
 {
-	RMLUI_ASSERT(instance == nullptr);
-	instance = this;
+	RMLUI_ASSERT(GET_OR_MAKE_GLOBAL(instance) == nullptr);
+	GET_OR_MAKE_GLOBAL(instance) = this;
 
 	default_parsers.reset(new DefaultStyleSheetParsers);
 }
 
 StyleSheetSpecification::~StyleSheetSpecification()
 {
-	RMLUI_ASSERT(instance == this);
-	instance = nullptr;
+	RMLUI_ASSERT(GET_OR_MAKE_GLOBAL(instance) == this);
+	GET_OR_MAKE_GLOBAL(instance) = nullptr;
 }
 
 PropertyDefinition& StyleSheetSpecification::RegisterProperty(PropertyId id, const String& property_name, const String& default_value, bool inherited, bool forces_layout)
@@ -92,12 +92,12 @@ ShorthandId StyleSheetSpecification::RegisterShorthand(ShorthandId id, const Str
 
 bool StyleSheetSpecification::Initialise()
 {
-	if (instance == nullptr)
+	if (GET_OR_MAKE_GLOBAL(instance) == nullptr)
 	{
 		new StyleSheetSpecification();
 
-		instance->RegisterDefaultParsers();
-		instance->RegisterDefaultProperties();
+		GET_OR_MAKE_GLOBAL(instance)->RegisterDefaultParsers();
+		GET_OR_MAKE_GLOBAL(instance)->RegisterDefaultProperties();
 	}
 
 	return true;
@@ -105,31 +105,31 @@ bool StyleSheetSpecification::Initialise()
 
 void StyleSheetSpecification::Shutdown()
 {
-	if (instance != nullptr)
+	if (GET_OR_MAKE_GLOBAL(instance) != nullptr)
 	{
-		delete instance;
+		delete GET_OR_MAKE_GLOBAL(instance);
 	}
 }
 
 // Registers a parser for use in property definitions.
 bool StyleSheetSpecification::RegisterParser(const String& parser_name, PropertyParser* parser)
 {
-	ParserMap::iterator iterator = instance->parsers.find(parser_name);
-	if (iterator != instance->parsers.end())
+	ParserMap::iterator iterator = GET_OR_MAKE_GLOBAL(instance)->parsers.find(parser_name);
+	if (iterator != GET_OR_MAKE_GLOBAL(instance)->parsers.end())
 	{
 		Log::Message(Log::LT_WARNING, "Parser with name %s already exists!", parser_name.c_str());
 		return false;
 	}
 
-	instance->parsers[parser_name] = parser;
+	GET_OR_MAKE_GLOBAL(instance)->parsers[parser_name] = parser;
 	return true;
 }
 
 // Returns the parser registered with a specific name.
 PropertyParser* StyleSheetSpecification::GetParser(const String& parser_name)
 {
-	ParserMap::iterator iterator = instance->parsers.find(parser_name);
-	if (iterator == instance->parsers.end())
+	ParserMap::iterator iterator = GET_OR_MAKE_GLOBAL(instance)->parsers.find(parser_name);
+	if (iterator == GET_OR_MAKE_GLOBAL(instance)->parsers.end())
 		return nullptr;
 
 	return (*iterator).second;
@@ -138,85 +138,85 @@ PropertyParser* StyleSheetSpecification::GetParser(const String& parser_name)
 // Registers a property with a new definition.
 PropertyDefinition& StyleSheetSpecification::RegisterProperty(const String& property_name, const String& default_value, bool inherited, bool forces_layout)
 {
-	RMLUI_ASSERTMSG((size_t)instance->properties.property_map->GetId(property_name) < (size_t)PropertyId::FirstCustomId, "Custom property name matches an internal property, please make a unique name for the given property.");
-	return instance->RegisterProperty(PropertyId::Invalid, property_name, default_value, inherited, forces_layout); 
+	RMLUI_ASSERTMSG((size_t)GET_OR_MAKE_GLOBAL(instance)->properties.property_map->GetId(property_name) < (size_t)PropertyId::FirstCustomId, "Custom property name matches an internal property, please make a unique name for the given property.");
+	return GET_OR_MAKE_GLOBAL(instance)->RegisterProperty(PropertyId::Invalid, property_name, default_value, inherited, forces_layout); 
 }
 
 // Returns a property definition.
 const PropertyDefinition* StyleSheetSpecification::GetProperty(const String& property_name)
 {
-	return instance->properties.GetProperty(property_name);
+	return GET_OR_MAKE_GLOBAL(instance)->properties.GetProperty(property_name);
 }
 
 const PropertyDefinition* StyleSheetSpecification::GetProperty(PropertyId id)
 {
-	return instance->properties.GetProperty(id);
+	return GET_OR_MAKE_GLOBAL(instance)->properties.GetProperty(id);
 }
 
 const PropertyIdSet& StyleSheetSpecification::GetRegisteredProperties()
 {
-	return instance->properties.GetRegisteredProperties();
+	return GET_OR_MAKE_GLOBAL(instance)->properties.GetRegisteredProperties();
 }
 
 const PropertyIdSet & StyleSheetSpecification::GetRegisteredInheritedProperties()
 {
-	return instance->properties.GetRegisteredInheritedProperties();
+	return GET_OR_MAKE_GLOBAL(instance)->properties.GetRegisteredInheritedProperties();
 }
 
 const PropertyIdSet& StyleSheetSpecification::GetRegisteredPropertiesForcingLayout()
 {
-	return instance->properties.GetRegisteredPropertiesForcingLayout();
+	return GET_OR_MAKE_GLOBAL(instance)->properties.GetRegisteredPropertiesForcingLayout();
 }
 
 // Registers a shorthand property definition.
 ShorthandId StyleSheetSpecification::RegisterShorthand(const String& shorthand_name, const String& property_names, ShorthandType type)
 {
-	RMLUI_ASSERTMSG(instance->properties.property_map->GetId(shorthand_name) == PropertyId::Invalid, "Custom shorthand name matches a property name, please make a unique name.");
-	RMLUI_ASSERTMSG((size_t)instance->properties.shorthand_map->GetId(shorthand_name) < (size_t)ShorthandId::FirstCustomId, "Custom shorthand name matches an internal shorthand, please make a unique name for the given shorthand property.");
-	return instance->properties.RegisterShorthand(shorthand_name, property_names, type);
+	RMLUI_ASSERTMSG(GET_OR_MAKE_GLOBAL(instance)->properties.property_map->GetId(shorthand_name) == PropertyId::Invalid, "Custom shorthand name matches a property name, please make a unique name.");
+	RMLUI_ASSERTMSG((size_t)GET_OR_MAKE_GLOBAL(instance)->properties.shorthand_map->GetId(shorthand_name) < (size_t)ShorthandId::FirstCustomId, "Custom shorthand name matches an internal shorthand, please make a unique name for the given shorthand property.");
+	return GET_OR_MAKE_GLOBAL(instance)->properties.RegisterShorthand(shorthand_name, property_names, type);
 }
 
 // Returns a shorthand definition.
 const ShorthandDefinition* StyleSheetSpecification::GetShorthand(const String& shorthand_name)
 {
-	return instance->properties.GetShorthand(shorthand_name);
+	return GET_OR_MAKE_GLOBAL(instance)->properties.GetShorthand(shorthand_name);
 }
 
 const ShorthandDefinition* StyleSheetSpecification::GetShorthand(ShorthandId id)
 {
-	return instance->properties.GetShorthand(id);
+	return GET_OR_MAKE_GLOBAL(instance)->properties.GetShorthand(id);
 }
 
 // Parses a property declaration, setting any parsed and validated properties on the given dictionary.
 bool StyleSheetSpecification::ParsePropertyDeclaration(PropertyDictionary& dictionary, const String& property_name, const String& property_value)
 {
-	return instance->properties.ParsePropertyDeclaration(dictionary, property_name, property_value);
+	return GET_OR_MAKE_GLOBAL(instance)->properties.ParsePropertyDeclaration(dictionary, property_name, property_value);
 }
 
 PropertyId StyleSheetSpecification::GetPropertyId(const String& property_name)
 {
-	return instance->properties.property_map->GetId(property_name);
+	return GET_OR_MAKE_GLOBAL(instance)->properties.property_map->GetId(property_name);
 }
 
 ShorthandId StyleSheetSpecification::GetShorthandId(const String& shorthand_name)
 {
-	return instance->properties.shorthand_map->GetId(shorthand_name);
+	return GET_OR_MAKE_GLOBAL(instance)->properties.shorthand_map->GetId(shorthand_name);
 }
 
 const String& StyleSheetSpecification::GetPropertyName(PropertyId id)
 {
-	return instance->properties.property_map->GetName(id);
+	return GET_OR_MAKE_GLOBAL(instance)->properties.property_map->GetName(id);
 }
 
 const String& StyleSheetSpecification::GetShorthandName(ShorthandId id)
 {
-	return instance->properties.shorthand_map->GetName(id);
+	return GET_OR_MAKE_GLOBAL(instance)->properties.shorthand_map->GetName(id);
 }
 
 PropertyIdSet StyleSheetSpecification::GetShorthandUnderlyingProperties(ShorthandId id)
 {
 	PropertyIdSet result;
-	const ShorthandDefinition* shorthand = instance->properties.GetShorthand(id);
+	const ShorthandDefinition* shorthand = GET_OR_MAKE_GLOBAL(instance)->properties.GetShorthand(id);
 	if (!shorthand)
 		return result;
 
@@ -237,7 +237,7 @@ PropertyIdSet StyleSheetSpecification::GetShorthandUnderlyingProperties(Shorthan
 
 const PropertySpecification& StyleSheetSpecification::GetPropertySpecification()
 {
-	return instance->properties;
+	return GET_OR_MAKE_GLOBAL(instance)->properties;
 }
 
 // Registers RmlUi's default parsers.
@@ -434,8 +434,8 @@ void StyleSheetSpecification::RegisterDefaultProperties()
 	RegisterShorthand(ShorthandId::Flex, "flex", "flex-grow, flex-shrink, flex-basis", ShorthandType::Flex);
 	RegisterShorthand(ShorthandId::FlexFlow, "flex-flow", "flex-direction, flex-wrap", ShorthandType::FallThrough);
 
-	RMLUI_ASSERTMSG(instance->properties.shorthand_map->AssertAllInserted(ShorthandId::NumDefinedIds), "Missing specification for one or more Shorthand IDs.");
-	RMLUI_ASSERTMSG(instance->properties.property_map->AssertAllInserted(PropertyId::NumDefinedIds), "Missing specification for one or more Property IDs.");
+	RMLUI_ASSERTMSG(GET_OR_MAKE_GLOBAL(instance)->properties.shorthand_map->AssertAllInserted(ShorthandId::NumDefinedIds), "Missing specification for one or more Shorthand IDs.");
+	RMLUI_ASSERTMSG(GET_OR_MAKE_GLOBAL(instance)->properties.property_map->AssertAllInserted(PropertyId::NumDefinedIds), "Missing specification for one or more Property IDs.");
 }
 
 } // namespace Rml
diff --git externals/rmlui/Source/Core/SystemInterface.cpp externals/rmlui/Source/Core/SystemInterface.cpp
index 74efc9e5..8ec8e9aa 100644
--- externals/rmlui/Source/Core/SystemInterface.cpp
+++ externals/rmlui/Source/Core/SystemInterface.cpp
@@ -15,7 +15,7 @@
  *
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -27,42 +27,39 @@
  */
 
 #include "../../Include/RmlUi/Core/SystemInterface.h"
+#include "../../Include/RmlUi/Core/Context.h"
 #include "../../Include/RmlUi/Core/Log.h"
 #include "../../Include/RmlUi/Core/StringUtilities.h"
 #include "../../Include/RmlUi/Core/URL.h"
 
 #ifdef RMLUI_PLATFORM_WIN32
-#include <windows.h>
+	#include <windows.h>
 #else
-#include <stdio.h>
+	#include <stdio.h>
 #endif
 
 namespace Rml {
 
-static String clipboard_text;
+REGISTER_GLOBAL(String, clipboard_text);
 
-SystemInterface::SystemInterface()
-{
-}
+SystemInterface::SystemInterface() {}
 
-SystemInterface::~SystemInterface()
-{
-}
+SystemInterface::~SystemInterface() {}
 
 #ifdef RMLUI_PLATFORM_WIN32
 bool SystemInterface::LogMessage(Log::Type logtype, const String& message)
 {
 	// By default we just send a platform message
-#if !defined(WINAPI_FAMILY) || (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP)
+	#if !defined(WINAPI_FAMILY) || (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP)
 	if (logtype == Log::LT_ASSERT)
 	{
-		String message_user = CreateString(1024, "%s\nWould you like to interrupt execution?", message.c_str());	
+		String message_user = CreateString(1024, "%s\nWould you like to interrupt execution?", message.c_str());
 
 		// Return TRUE if the user presses NO (continue execution)
 		return (IDNO == MessageBoxA(nullptr, message_user.c_str(), "Assertion Failure", MB_YESNO | MB_ICONSTOP | MB_DEFBUTTON2 | MB_TASKMODAL));
 	}
 	else
-#endif
+	#endif
 	{
 		OutputDebugStringA(message.c_str());
 		OutputDebugStringA("\r\n");
@@ -72,28 +69,26 @@ bool SystemInterface::LogMessage(Log::Type logtype, const String& message)
 #else
 bool SystemInterface::LogMessage(Log::Type /*logtype*/, const String& message)
 {
-#ifdef RMLUI_PLATFORM_EMSCRIPTEN
+	#ifdef RMLUI_PLATFORM_EMSCRIPTEN
 	puts(message.c_str());
-#else
+	#else
 	fprintf(stderr, "%s\n", message.c_str());
-#endif
+	#endif
 	return true;
 }
-#endif	
+#endif
 
-void SystemInterface::SetMouseCursor(const String& /*cursor_name*/)
-{
-}
+void SystemInterface::SetMouseCursor(const String& /*cursor_name*/) {}
 
 void SystemInterface::SetClipboardText(const String& text)
 {
 	// The default implementation will only copy and paste within the application
-	clipboard_text = text;
+	GET_OR_MAKE_GLOBAL(clipboard_text) = text;
 }
 
 void SystemInterface::GetClipboardText(String& text)
 {
-	text = clipboard_text;
+	text = GET_OR_MAKE_GLOBAL(clipboard_text);
 }
 
 int SystemInterface::TranslateString(String& translated, const String& input)
@@ -114,8 +109,7 @@ void SystemInterface::JoinPath(String& translated_path, const String& document_p
 	// If the path is a Windows-style absolute path, return it directly.
 	size_t drive_pos = path.find(':');
 	size_t slash_pos = Math::Min(path.find('/'), path.find('\\'));
-	if (drive_pos != String::npos &&
-		drive_pos < slash_pos)
+	if (drive_pos != String::npos && drive_pos < slash_pos)
 	{
 		translated_path = path;
 		return;
diff --git externals/rmlui/Source/Core/TemplateCache.cpp externals/rmlui/Source/Core/TemplateCache.cpp
index b93ba75c..a02c3eca 100644
--- externals/rmlui/Source/Core/TemplateCache.cpp
+++ externals/rmlui/Source/Core/TemplateCache.cpp
@@ -30,25 +30,26 @@
 #include "StreamFile.h"
 #include "Template.h"
 #include "../../Include/RmlUi/Core/Log.h"
+#include "../../Include/RmlUi/Core/Context.h"
 
 namespace Rml {
 
-static TemplateCache* instance = nullptr;
+REGISTER_GLOBAL(TemplateCache*, instance);
 
 TemplateCache::TemplateCache()
 {
-	RMLUI_ASSERT(instance == nullptr);
-	instance = this;
+	RMLUI_ASSERT(GET_OR_MAKE_GLOBAL(instance) == nullptr);
+	GET_OR_MAKE_GLOBAL(instance) = this;
 }
 
 TemplateCache::~TemplateCache()
 {
-	for (Templates::iterator itr = instance->templates.begin(); itr != instance->templates.end(); ++itr)
+	for (Templates::iterator itr = GET_OR_MAKE_GLOBAL(instance)->templates.begin(); itr != GET_OR_MAKE_GLOBAL(instance)->templates.end(); ++itr)
 	{
 		delete (*itr).second;
 	}
 
-	instance = nullptr;
+	GET_OR_MAKE_GLOBAL(instance) = nullptr;
 }
 
 bool TemplateCache::Initialise()
@@ -60,14 +61,14 @@ bool TemplateCache::Initialise()
 
 void TemplateCache::Shutdown()
 {
-	delete instance;
+	delete GET_OR_MAKE_GLOBAL(instance);
 }
 
 Template* TemplateCache::LoadTemplate(const String& name)
 {
 	// Check if the template is already loaded
-	Templates::iterator itr = instance->templates.find(name);
-	if (itr != instance->templates.end())
+	Templates::iterator itr = GET_OR_MAKE_GLOBAL(instance)->templates.find(name);
+	if (itr != GET_OR_MAKE_GLOBAL(instance)->templates.end())
 		return (*itr).second;
 
 	// Nope, we better load it
@@ -90,8 +91,8 @@ Template* TemplateCache::LoadTemplate(const String& name)
 		}
 		else
 		{
-			instance->templates[name] = new_template;
-			instance->template_ids[new_template->GetName()] = new_template;
+			GET_OR_MAKE_GLOBAL(instance)->templates[name] = new_template;
+			GET_OR_MAKE_GLOBAL(instance)->template_ids[new_template->GetName()] = new_template;
 		}
 	}
 	else
@@ -105,8 +106,8 @@ Template* TemplateCache::LoadTemplate(const String& name)
 Template* TemplateCache::GetTemplate(const String& name)
 {
 	// Check if the template is already loaded
-	Templates::iterator itr = instance->template_ids.find(name);
-	if (itr != instance->template_ids.end())
+	Templates::iterator itr = GET_OR_MAKE_GLOBAL(instance)->template_ids.find(name);
+	if (itr != GET_OR_MAKE_GLOBAL(instance)->template_ids.end())
 		return (*itr).second;
 
 	return nullptr;
@@ -114,11 +115,11 @@ Template* TemplateCache::GetTemplate(const String& name)
 
 void TemplateCache::Clear()
 {
-	for (Templates::iterator i = instance->templates.begin(); i != instance->templates.end(); ++i)
+	for (Templates::iterator i = GET_OR_MAKE_GLOBAL(instance)->templates.begin(); i != GET_OR_MAKE_GLOBAL(instance)->templates.end(); ++i)
 		delete (*i).second;
 
-	instance->templates.clear();
-	instance->template_ids.clear();
+	GET_OR_MAKE_GLOBAL(instance)->templates.clear();
+	GET_OR_MAKE_GLOBAL(instance)->template_ids.clear();
 }
 
 } // namespace Rml
diff --git externals/rmlui/Source/Core/TextureDatabase.cpp externals/rmlui/Source/Core/TextureDatabase.cpp
index 9111ccc1..f4d059c4 100644
--- externals/rmlui/Source/Core/TextureDatabase.cpp
+++ externals/rmlui/Source/Core/TextureDatabase.cpp
@@ -28,23 +28,24 @@
 
 #include "TextureDatabase.h"
 #include "../../Include/RmlUi/Core/Core.h"
+#include "../../Include/RmlUi/Core/Context.h"
 #include "../../Include/RmlUi/Core/StringUtilities.h"
 #include "../../Include/RmlUi/Core/SystemInterface.h"
 #include "TextureResource.h"
 
 namespace Rml {
 
-static TextureDatabase* texture_database = nullptr;
+REGISTER_GLOBAL(TextureDatabase*, texture_database);
 
 TextureDatabase::TextureDatabase()
 {
-	RMLUI_ASSERT(texture_database == nullptr);
-	texture_database = this;
+	RMLUI_ASSERT(GET_OR_MAKE_GLOBAL(texture_database) == nullptr);
+	GET_OR_MAKE_GLOBAL(texture_database) = this;
 }
 
 TextureDatabase::~TextureDatabase()
 {
-	RMLUI_ASSERT(texture_database == this);
+	RMLUI_ASSERT(GET_OR_MAKE_GLOBAL(texture_database) == this);
 
 #ifdef RMLUI_DEBUG
 	// All textures not owned by the database should have been released at this point.
@@ -63,7 +64,7 @@ TextureDatabase::~TextureDatabase()
 	}
 #endif
 
-	texture_database = nullptr;
+	GET_OR_MAKE_GLOBAL(texture_database) = nullptr;
 }
 
 void TextureDatabase::Initialise()
@@ -73,7 +74,7 @@ void TextureDatabase::Initialise()
 
 void TextureDatabase::Shutdown()
 {
-	delete texture_database;
+	delete GET_OR_MAKE_GLOBAL(texture_database);
 }
 
 SharedPtr<TextureResource> TextureDatabase::Fetch(const String& source, const String& source_directory)
@@ -84,38 +85,38 @@ SharedPtr<TextureResource> TextureDatabase::Fetch(const String& source, const St
 	else
 		GetSystemInterface()->JoinPath(path, StringUtilities::Replace(source_directory, '|', ':'), source);
 
-	auto iterator = texture_database->textures.find(path);
-	if (iterator != texture_database->textures.end())
+	auto iterator = GET_OR_MAKE_GLOBAL(texture_database)->textures.find(path);
+	if (iterator != GET_OR_MAKE_GLOBAL(texture_database)->textures.end())
 		return iterator->second;
 
 	auto resource = MakeShared<TextureResource>();
 	resource->Set(path);
 
-	texture_database->textures[path] = resource;
+	GET_OR_MAKE_GLOBAL(texture_database)->textures[path] = resource;
 	return resource;
 }
 
 void TextureDatabase::AddCallbackTexture(TextureResource* texture)
 {
-	if (texture_database)
-		texture_database->callback_textures.insert(texture);
+	if (GET_OR_MAKE_GLOBAL(texture_database))
+		GET_OR_MAKE_GLOBAL(texture_database)->callback_textures.insert(texture);
 }
 
 void TextureDatabase::RemoveCallbackTexture(TextureResource* texture)
 {
-	if (texture_database)
-		texture_database->callback_textures.erase(texture);
+	if (GET_OR_MAKE_GLOBAL(texture_database))
+		GET_OR_MAKE_GLOBAL(texture_database)->callback_textures.erase(texture);
 }
 
 StringList TextureDatabase::GetSourceList()
 {
 	StringList result;
 
-	if (texture_database)
+	if (GET_OR_MAKE_GLOBAL(texture_database))
 	{
-		result.reserve(texture_database->textures.size());
+		result.reserve(GET_OR_MAKE_GLOBAL(texture_database)->textures.size());
 
-		for (const auto& pair : texture_database->textures)
+		for (const auto& pair : GET_OR_MAKE_GLOBAL(texture_database)->textures)
 			result.push_back(pair.first);
 	}
 
@@ -124,25 +125,25 @@ StringList TextureDatabase::GetSourceList()
 
 void TextureDatabase::ReleaseTextures(RenderInterface* render_interface)
 {
-	if (texture_database)
+	if (GET_OR_MAKE_GLOBAL(texture_database))
 	{
-		for (const auto& texture : texture_database->textures)
+		for (const auto& texture : GET_OR_MAKE_GLOBAL(texture_database)->textures)
 			texture.second->Release(render_interface);
 
-		for (const auto& texture : texture_database->callback_textures)
+		for (const auto& texture : GET_OR_MAKE_GLOBAL(texture_database)->callback_textures)
 			texture->Release(render_interface);
 	}
 }
 
 bool TextureDatabase::HoldsReferenceToRenderInterface(RenderInterface* render_interface)
 {
-	if (texture_database)
+	if (GET_OR_MAKE_GLOBAL(texture_database))
 	{
-		for (const auto& texture : texture_database->textures)
+		for (const auto& texture : GET_OR_MAKE_GLOBAL(texture_database)->textures)
 			if (texture.second->HoldsRenderInterface(render_interface))
 				return true;
 
-		for (const auto& texture : texture_database->callback_textures)
+		for (const auto& texture : GET_OR_MAKE_GLOBAL(texture_database)->callback_textures)
 			if (texture->HoldsRenderInterface(render_interface))
 				return true;
 	}
diff --git externals/rmlui/Source/Core/XMLParser.cpp externals/rmlui/Source/Core/XMLParser.cpp
index 7592005a..73f1cd8d 100644
--- externals/rmlui/Source/Core/XMLParser.cpp
+++ externals/rmlui/Source/Core/XMLParser.cpp
@@ -15,7 +15,7 @@
  *
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -26,22 +26,22 @@
  *
  */
 
-#include "DocumentHeader.h"
+#include "../../Include/RmlUi/Core/XMLParser.h"
+#include "../../Include/RmlUi/Core/Context.h"
+#include "../../Include/RmlUi/Core/Factory.h"
 #include "../../Include/RmlUi/Core/Log.h"
 #include "../../Include/RmlUi/Core/Profiling.h"
 #include "../../Include/RmlUi/Core/Stream.h"
 #include "../../Include/RmlUi/Core/Types.h"
-#include "../../Include/RmlUi/Core/XMLNodeHandler.h"
 #include "../../Include/RmlUi/Core/URL.h"
-#include "../../Include/RmlUi/Core/XMLParser.h"
-#include "../../Include/RmlUi/Core/Factory.h"
+#include "../../Include/RmlUi/Core/XMLNodeHandler.h"
+#include "DocumentHeader.h"
 
 namespace Rml {
 
-using NodeHandlers = UnorderedMap< String, SharedPtr<XMLNodeHandler> >;
-static NodeHandlers node_handlers;
-static SharedPtr<XMLNodeHandler> default_node_handler;
-
+using NodeHandlers = UnorderedMap<String, SharedPtr<XMLNodeHandler>>;
+REGISTER_GLOBAL(NodeHandlers, node_handlers);
+REGISTER_GLOBAL(SharedPtr<XMLNodeHandler>, default_node_handler);
 XMLParser::XMLParser(Element* root)
 {
 	RegisterCDATATag("script");
@@ -60,8 +60,7 @@ XMLParser::XMLParser(Element* root)
 	header = MakeUnique<DocumentHeader>();
 }
 
-XMLParser::~XMLParser()
-{}
+XMLParser::~XMLParser() {}
 
 // Registers a custom node handler to be used to a given tag.
 XMLNodeHandler* XMLParser::RegisterNodeHandler(const String& _tag, SharedPtr<XMLNodeHandler> handler)
@@ -71,29 +70,29 @@ XMLNodeHandler* XMLParser::RegisterNodeHandler(const String& _tag, SharedPtr<XML
 	// Check for a default node registration.
 	if (tag.empty())
 	{
-		default_node_handler = std::move(handler);
-		return default_node_handler.get();
+		GET_OR_MAKE_GLOBAL(default_node_handler) = std::move(handler);
+		return GET_OR_MAKE_GLOBAL(default_node_handler).get();
 	}
 
 	XMLNodeHandler* result = handler.get();
-	node_handlers[tag] = std::move(handler);
+	GET_OR_MAKE_GLOBAL(node_handlers)[tag] = std::move(handler);
 	return result;
 }
 
 XMLNodeHandler* XMLParser::GetNodeHandler(const String& tag)
 {
-	auto it = node_handlers.find(tag);
-	if (it != node_handlers.end())
+	auto it = GET_OR_MAKE_GLOBAL(node_handlers).find(tag);
+	if (it != GET_OR_MAKE_GLOBAL(node_handlers).end())
 		return it->second.get();
-	
+
 	return nullptr;
 }
 
 // Releases all registered node handlers. This is called internally.
 void XMLParser::ReleaseHandlers()
 {
-	default_node_handler.reset();
-	node_handlers.clear();
+	GET_OR_MAKE_GLOBAL(default_node_handler).reset();
+	GET_OR_MAKE_GLOBAL(node_handlers).clear();
 }
 
 DocumentHeader* XMLParser::GetDocumentHeader()
@@ -104,13 +103,13 @@ DocumentHeader* XMLParser::GetDocumentHeader()
 // Pushes the default element handler onto the parse stack.
 void XMLParser::PushDefaultHandler()
 {
-	active_handler = default_node_handler.get();
+	active_handler = GET_OR_MAKE_GLOBAL(default_node_handler).get();
 }
 
 bool XMLParser::PushHandler(const String& tag)
 {
-	NodeHandlers::iterator i = node_handlers.find(StringUtilities::ToLower(tag));
-	if (i == node_handlers.end())
+	NodeHandlers::iterator i = GET_OR_MAKE_GLOBAL(node_handlers).find(StringUtilities::ToLower(tag));
+	if (i == GET_OR_MAKE_GLOBAL(node_handlers).end())
 		return false;
 
 	active_handler = i->second.get();
@@ -136,8 +135,8 @@ void XMLParser::HandleElementStart(const String& _name, const XMLAttributes& att
 	const String name = StringUtilities::ToLower(_name);
 
 	// Check for a specific handler that will override the child handler.
-	NodeHandlers::iterator itr = node_handlers.find(name);
-	if (itr != node_handlers.end())
+	NodeHandlers::iterator itr = GET_OR_MAKE_GLOBAL(node_handlers).find(name);
+	if (itr != GET_OR_MAKE_GLOBAL(node_handlers).end())
 		active_handler = itr->second.get();
 
 	// Store the current active handler, so we can use it through this function (as active handler may change)
@@ -171,19 +170,20 @@ void XMLParser::HandleElementEnd(const String& _name)
 	// Pop the frame
 	stack.pop();
 	// Restore active handler to the previous frame's child handler
-	active_handler = stack.top().child_handler;	
+	active_handler = stack.top().child_handler;
 
 	// Check frame names
 	if (name != frame.tag)
 	{
-		Log::Message(Log::LT_ERROR, "Closing tag '%s' mismatched on %s:%d was expecting '%s'.", name.c_str(), GetSourceURL().GetURL().c_str(), GetLineNumber(), frame.tag.c_str());
+		Log::Message(Log::LT_ERROR, "Closing tag '%s' mismatched on %s:%d was expecting '%s'.", name.c_str(), GetSourceURL().GetURL().c_str(),
+			GetLineNumber(), frame.tag.c_str());
 	}
 
 	// Call element end handler
 	if (frame.node_handler)
 	{
 		frame.node_handler->ElementEnd(this, name);
-	}	
+	}
 }
 
 /// Called when the parser encounters data.
diff --git externals/rmlui/Source/Debugger/Geometry.cpp externals/rmlui/Source/Debugger/Geometry.cpp
index 17a17be7..2dab2959 100644
--- externals/rmlui/Source/Debugger/Geometry.cpp
+++ externals/rmlui/Source/Debugger/Geometry.cpp
@@ -34,7 +34,7 @@
 namespace Rml {
 namespace Debugger {
 
-static Context* context;
+REGISTER_GLOBAL(Context*, context);
 
 Geometry::Geometry()
 {
@@ -42,16 +42,16 @@ Geometry::Geometry()
 
 void Geometry::SetContext(Context* _context)
 {
-	context = _context;
+	GET_OR_MAKE_GLOBAL(context) = _context;
 }
 
 // Renders a one-pixel rectangular outline.
 void Geometry::RenderOutline(const Vector2f origin, const Vector2f dimensions, const Colourb colour, float width)
 {
-	if (context == nullptr)
+	if (GET_OR_MAKE_GLOBAL(context) == nullptr)
 		return;
 
-	RenderInterface* render_interface = context->GetRenderInterface();
+	RenderInterface* render_interface = GET_OR_MAKE_GLOBAL(context)->GetRenderInterface();
 
 	Vertex vertices[4 * 4];
 	int indices[6 * 4];
@@ -67,10 +67,10 @@ void Geometry::RenderOutline(const Vector2f origin, const Vector2f dimensions, c
 // Renders a box.
 void Geometry::RenderBox(const Vector2f origin, const Vector2f dimensions, const Colourb colour)
 {
-	if (context == nullptr)
+	if (GET_OR_MAKE_GLOBAL(context) == nullptr)
 		return;
 
-	RenderInterface* render_interface = context->GetRenderInterface();
+	RenderInterface* render_interface = GET_OR_MAKE_GLOBAL(context)->GetRenderInterface();
 
 	Vertex vertices[4];
 	int indices[6];
